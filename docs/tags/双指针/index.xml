<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>双指针 on 人类低质量男性求职准备</title>
    <link>https://zzydev.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <description>Recent content in 双指针 on 人类低质量男性求职准备</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>zzydev</copyright>
    <lastBuildDate>Thu, 02 Jun 2022 23:10:53 +0800</lastBuildDate><atom:link href="https://zzydev.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lc11_盛最多水的容器</title>
      <link>https://zzydev.top/posts/leetcode/lc11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 02 Jun 2022 23:10:53 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l &amp;lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] &amp;gt;= height[r]) r --; else if (height[l] &amp;lt; height[r]) l ++; } return res; } };</description>
    </item>
    
    <item>
      <title>Lc03_无重复字符的最长子串</title>
      <link>https://zzydev.top/posts/leetcode/lc03_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 02 Jun 2022 18:33:15 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc03_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>双指针经典模板： class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map&amp;lt;int, int&amp;gt; hash; int res = 0; for (int l = 0, r = 0; r &amp;lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] &amp;gt; 1) hash[s[l ++]] --; if (res &amp;lt; r - l + 1) res = r - l + 1; } return res; } };</description>
    </item>
    
  </channel>
</rss>
