<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hard on 人类低质量男性求职准备</title>
    <link>https://zzydev.top/tags/hard/</link>
    <description>Recent content in hard on 人类低质量男性求职准备</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>zzydev</copyright>
    <lastBuildDate>Tue, 07 Jun 2022 17:36:53 +0800</lastBuildDate><atom:link href="https://zzydev.top/tags/hard/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lc41_缺失的第一个正数</title>
      <link>https://zzydev.top/posts/leetcode/lc41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</link>
      <pubDate>Tue, 07 Jun 2022 17:36:53 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</guid>
      <description>原题链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if (!n) return 1; // 最小正整数 做一次映射 结果加回来 for (auto&amp;amp; x : nums) if (x != INT_MIN) x -- ;</description>
    </item>
    
    <item>
      <title>Lc37_解数独</title>
      <link>https://zzydev.top/posts/leetcode/lc37_%E8%A7%A3%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Mon, 06 Jun 2022 17:36:27 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc37_%E8%A7%A3%E6%95%B0%E7%8B%AC/</guid>
      <description>原题链接 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: bool row[9][9], col[9][9], cell[3][3][9]; void solveSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { //先记录已经填了数字的 for (int i = 0; i</description>
    </item>
    
    <item>
      <title>Lc32_最长有效括号</title>
      <link>https://zzydev.top/posts/leetcode/lc32_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 06 Jun 2022 16:15:25 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc32_%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>原题链接 合法的括号序列： 左边的括号数量大于等于右边括号的数量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int longestValidParentheses(string s) { int n = s.size(); if (n &amp;lt;</description>
    </item>
    
    <item>
      <title>Lc25_K个一组翻转链表</title>
      <link>https://zzydev.top/posts/leetcode/lc25_k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 03 Jun 2022 22:53:33 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc25_k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>原题链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next)</description>
    </item>
    
    <item>
      <title>Lc23_合并K个升序链表</title>
      <link>https://zzydev.top/posts/leetcode/lc23_%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 03 Jun 2022 22:47:50 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc23_%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>原题链接 使用优先队列，将所有链表的头指针加入到优先队列中（小根堆） 当小根堆不为空时，每次将堆顶元素t放入新构建的链表中，再将t的下一个节点加</description>
    </item>
    
    <item>
      <title>Lc10_正则表达式匹配</title>
      <link>https://zzydev.top/posts/leetcode/lc10_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Thu, 02 Jun 2022 22:49:42 +0800</pubDate>
      
      <guid>https://zzydev.top/posts/leetcode/lc10_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>如果p[j] == &amp;lsquo;*&amp;rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] &amp;amp;&amp;amp; s[i] == p[j - 1]以此类推 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
    </item>
    
  </channel>
</rss>
