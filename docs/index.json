[{"content":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。\n如果你在这个在线 Demo中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：\n明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！\n这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？\n因为虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。\n多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。\n但如果我们把 ProfilePage 改造为一个像这样的函数组件：\n1 2 3 4 5 6 7 8 9 10 11 function ProfilePage(props) { const showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + props.user); }; const handleClick = () =\u0026gt; { setTimeout(showMessage, 3000); }; return ( \u0026lt;button onClick={handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt; ); } 事情就会大不一样。\nprops 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。\n总结：“函数组件会捕获 render 内部的状态”，函数组件真正地把数据和渲染绑定到了一起。\n函数组件是一个更加匹配React设计理念、也更有利于逻辑拆分与重用的组件表达形式，React-Hooks 便应运而生。\n从核心 API 看 Hooks 的基本形态 useState()：为函数组件引入状态 1 2 3 4 5 6 7 8 9 10 11 12 const [state, setState] = useState(initialState); //状态和修改状态的 API 名都是可以自定义的 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;); //它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值 // 定义为数组 const [author, setAuthor] = useState([\u0026#34;xiuyan\u0026#34;, \u0026#34;cuicui\u0026#34;, \u0026#34;yisi\u0026#34;]); // 定义为数值 const [length, setLength] = useState(100); // 定义为字符串 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;) useEffect()：允许函数组件执行副作用操作 ","permalink":"https://zzydev.top/posts/headfirstreact/react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","summary":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用","title":"React Hooks设计动机与工作模式"},{"content":"React 的核心特征是“数据驱动视图”，即 UI = render(data)\n基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。\n父子组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 子组件 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } //父组件 class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 按钮的监听函数，用于更新 text 值 changeText = () =\u0026gt; { this.setState({ text: \u0026#34;改变后的父组件文本\u0026#34; }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;button onClick={this.changeText}\u0026gt; 点击修改父组件传入子组件的文本 \u0026lt;/button\u0026gt; {/* 引入子组件，并通过 props 下发具体的状态值实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 子-父组件通信 考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。假如父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，以此来间接地实现数据从子组件到父组件的流动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Child extends React.Component { // 初始化子组件的 state state = { text: \u0026#39;子组件的文本\u0026#39; } // 子组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text) } render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本的动作放在了 Child 里 */} \u0026lt;button onClick={this.changeText}\u0026gt; 点击更新父组件的文本 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 这个方法会作为 props 传给子组件，用于更新父组件 text 值。newText 正是开放给子组件的数据通信入口 changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`父组件的文本内容是：[${this.state.text}]`}\u0026lt;/p\u0026gt; {/* 引入子组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;Child changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } 兄弟组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } class NewChild extends React.Component { state = { text: \u0026#34;来自 newChild 的文本\u0026#34; }; // NewChild 组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text); }; render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本（同时也是 Child 组件的文本）的动作放在了 NewChild 里 */} \u0026lt;button onClick={this.changeText}\u0026gt;点击更新 Child 组件的文本\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 传给 NewChild 组件按钮的监听函数，用于更新父组件 text 值（这个 text 值同时也是 Child 的 props） changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; {/* 引入 Child 组件，并通过 props 中下发具体的状态值 实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; {/* 引入 NewChild 组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;NewChild changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 利用“发布-订阅”模式驱动数据流 使用发布-订阅模式的优点在于，监听事件的位置和触发事件的位置是不受限的，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。\n发布-订阅模型 API 设计思路 on()：负责注册事件的监听器，指定事件触发时的回调函数。 emit()：负责触发事件，可以通过传参使其在触发的时候携带数据 。 off()：负责监听器的删除。 发布-订阅模型编码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class myEventEmitter { constructor() { // eventMap 用来存储事件和监听函数之间的关系 this.eventMap = {}; } // type 这里就代表事件的名称 on(type, handler) { // hanlder 必须是一个函数，如果不是直接报错 if (!(handler instanceof Function)) { throw new Error(\u0026#34;hanlder必须是一个函数\u0026#34;); } // 判断 type 事件对应的队列是否存在 if (!this.eventMap[type]) { // 若不存在，新建该队列 this.eventMap[type] = []; } // 若存在，直接往队列里推入 handler this.eventMap[type].push(handler); } // 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体 emit(type, params) { // 假设该事件是有订阅的（对应的事件队列存在） if (this.eventMap[type]) { // 将事件队列里的 handler 依次执行出队 this.eventMap[type].forEach((handler, index) =\u0026gt; { // 注意别忘了读取 params handler(params); }); } } off(type, handler) { if (this.eventMap[type]) { // indexOf找不到元素会返回-1，splice从右往左截取，右移运算会将-1变成4294967295 this.eventMap[type].splice(this.eventMap[type].indexOf(handler) \u0026gt;\u0026gt;\u0026gt; 0, 1); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 注意这个 myEvent 是提前实例化并挂载到全局的，此处不再重复示范实例化过程 const globalEvent = window.myEvent; class B extends React.Component { // 这里省略掉其他业务逻辑 state = { newParams: \u0026#34;\u0026#34;, }; handler = (params) =\u0026gt; { this.setState({ newParams: params, }); }; bindHandler = () =\u0026gt; { globalEvent.on(\u0026#34;someEvent\u0026#34;, this.handler); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.bindHandler}\u0026gt;点我监听A的动作\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;A传入的内容是[{this.state.newParams}]\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } } class A extends React.Component { // 这里省略掉其他业务逻辑 state = { infoToB: \u0026#34;哈哈哈哈我来自A\u0026#34;, }; reportToB = () =\u0026gt; { // 这里的 infoToB 表示 A 自身状态中需要让 B 感知的那部分数据 globalEvent.emit(\u0026#34;someEvent\u0026#34;, this.state.infoToB); }; render() { return \u0026lt;button onClick={this.reportToB}\u0026gt;点我把state传递给B\u0026lt;/button\u0026gt;; } } export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;/div\u0026gt; ); } 使用Context维护全局状态 useContext\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //作用是创建一个context对象,可以选择性地传入一个defaultValue const AppContext = React.createContext(defaultValue) //从创建出的context对象中，可以读取到 Provider 和 Consumer const { Provider, Consumer } = AppContext //使用 Provider 对组件树中的根组件进行包裹， //然后传入名为“value”的属性，这个 value 就是后续在组件树中流动的“数据”， //它可以被 Consumer 消费。 \u0026lt;Provider value={title: this.state.title, content: this.state.content}\u0026gt; \u0026lt;Title /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/Provider\u0026gt; //Consumer，顾名思义就是“数据的消费者”，它可以读取 Provider 下发下来的数据 //其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。 \u0026lt;Consumer\u0026gt; {value =\u0026gt; \u0026lt;div\u0026gt;{value.title}\u0026lt;/div\u0026gt;} \u0026lt;/Consumer\u0026gt; //注意: 当 Consumer 没有对应的 Provider 时， //value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。 Redux createStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const createStore = (reducer, enhancer) =\u0026gt; { if (enhancer) { return enhancer(createStore)(reducer); } let currentState = void 0; let currentListeners = []; const getState = () =\u0026gt; currentState; const dispatch = (action) =\u0026gt; { currentState = reducer(currentState, action); currentListeners.forEach((listener) =\u0026gt; listener()); }; const subscribe = (listener) =\u0026gt; { currentListeners.push(listener); return () =\u0026gt; { const index = currentListeners.indexOf(listener); currentListeners.splice(index, 1); }; }; //手动触发一次订阅，加上默认值 dispatch({ type: \u0026#34;@z—redux/INIT\u0026#34; }); return { getState, dispatch, subscribe, }; }; export default createStore; applyMiddleware.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const applyMiddleware = (...middleware) =\u0026gt; { return (createStore) =\u0026gt; (reducer) =\u0026gt; { const store = createStore(reducer); let dispatch = store.dispatch; const midApi = { getState: store.getState, dispatch: (action, ...args) =\u0026gt; dispatch(action, ...args), }; const chain = middleware.map((middleware) =\u0026gt; middleware(midApi)); dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch, }; }; }; const compose = (...funcs) =\u0026gt; { if (funcs.length === 0) { return (arg) =\u0026gt; arg; } if (funcs.length === 1) { return funcs[0]; } return funcs.reduce( (a, b) =\u0026gt; (...args) =\u0026gt; a(b(...args)) ); }; export default applyMiddleware; combineReducer.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const combineReducers = (reducers) =\u0026gt; (state = {}, action) =\u0026gt; { let nextState = {}; let hasChange = false; for (let key in reducers) { const reducer = reducers[key]; nextState[key] = reducer(state[key], action); hasChange = hasChange || nextState[key] !== state[key]; } hasChange = hasChange || Object.keys(nextState) !== Object.keys(state); return hasChange ? nextState : state; }; export default combineReducers; React-Redux 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import { useReducer } from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; import { useCallback, useState, useEffect, useLayoutEffect, useContext, } from \u0026#34;react\u0026#34;; const Context = React.createContext(); export const Provider = ({ store, children }) =\u0026gt; { return \u0026lt;Context.Provider value={store}\u0026gt;{children}\u0026lt;/Context.Provider\u0026gt;; }; export const connect = (mapStateToProps = (state) =\u0026gt; state, mapDispatchToProps) =\u0026gt; (WrapperComponent) =\u0026gt; (props) =\u0026gt; { const store = useContext(Context); const { getState, dispatch, subscribe } = store; const stateProps = mapStateToProps(getState()); let dispatchProps = { dispatch }; if (typeof mapDispatchToProps === \u0026#34;object\u0026#34;) { dispatchProps = { ...bindActionCreators(mapDispatchToProps, dispatch), dispatch, }; } else if (typeof mapDispatchToProps === \u0026#34;function\u0026#34;) { dispatchProps = mapDispatchToProps(dispatch); } const forceUpdate = useForceUpdate(); useLayoutEffect(() =\u0026gt; { const unsubscribe = subscribe(() =\u0026gt; { forceUpdate(); }); return () =\u0026gt; { if (unsubscribe) { unsubscribe(); } }; }, []); return \u0026lt;WrapperComponent {...props} {...stateProps} {...dispatchProps} /\u0026gt;; }; function bindActionCreator(creator, dispatch) { return (...args) =\u0026gt; dispatch(creator(...args)); } export const bindActionCreators = (creators, dispatch) =\u0026gt; { let obj = {}; for (let key in creators) { obj[key] = bindActionCreator(creators[key], dispatch); } return obj; }; const useForceUpdate = () =\u0026gt; { const [state, setState] = useState(0); //const [, setState] = useReducer((prev) =\u0026gt; prev + 1, 0); const update = useCallback(() =\u0026gt; { setState((prev) =\u0026gt; prev + 1); }, []); return update; }; ","permalink":"https://zzydev.top/posts/headfirstreact/%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8react%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%E7%9A%84/","summary":"React 的核心特征是“数据驱动视图”，即 UI = render(data) 基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更","title":"数据是如何在React组件之间流动的？"},{"content":"","permalink":"https://zzydev.top/posts/leetcode/lc16_%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"","title":"Lc16_最接近的三数之和"},{"content":"","permalink":"https://zzydev.top/posts/leetcode/lc15_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"","title":"Lc15_三数之和"},{"content":"语法题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (str.size() \u0026lt;= i || str[i] != c) return res; res += c; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc14_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","summary":"语法题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (str.size() \u0026lt;= i || str[i] != c) return res; res +=","title":"Lc14_最长公共前缀"},{"content":"定义字母（罗马数字）到数字（阿拉伯数字）的映射。 从前往后扫描，如果发现 s[i+1]的数字比 s[i] 的数字大，那么减去 s[i]的值即可，否则直接累计 s[i] 的值。\n时间复杂度：仅扫描一遍字符串，时间复杂度为 O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int romanToInt(string s) { unordered_map\u0026lt;char,int\u0026gt; hash { {\u0026#39;I\u0026#39;, 1}, {\u0026#39;V\u0026#39;, 5}, {\u0026#39;X\u0026#39;, 10}, {\u0026#39;L\u0026#39;, 50}, {\u0026#39;C\u0026#39;, 100}, {\u0026#39;D\u0026#39;, 500}, {\u0026#39;M\u0026#39;, 1000} }; int res = 0; for (int i = 0; i \u0026lt; s.size(); i ++) { if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) { res -= hash[s[i]]; } else { res += hash[s[i]]; } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc13_%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","summary":"定义字母（罗马数字）到数字（阿拉伯数字）的映射。 从前往后扫描，如果发现 s[i+1]的数字比 s[i] 的数字大，那么减去 s[i]的值即可，否则直接累计","title":"Lc13_罗马数字转整数"},{"content":"罗马数字的计数方法：\n相同的数字连写，所表示的数等于这些数字相加的和，如：III=3； 较小的数字在较大的数字的右边，所表示的数等于这些数字相加的和，如：VIII=8, XII=12； 较小的数字在较大的数字的左边（限于 IV、IX、XL、XC、CD 和 CM），所表示的数等于较大的数字减较小的数字得到的数，如：IV=4, IX=9； 连写的数字最多三次，如：III=3； 将所有减法操作看做一个整体，当成一种新的单位，如：CD = 400。从大到小整理所有单位得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: string intToRoman(int num) { int values[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string reps[] = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; 13; i ++) { while (num \u0026gt;= values[i]) { num -= values[i]; res += reps[i]; } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc12_%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","summary":"罗马数字的计数方法： 相同的数字连写，所表示的数等于这些数字相加的和，如：III=3； 较小的数字在较大的数字的右边，所表示的数等于这些数字相加","title":"Lc12_整数转罗马数字"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l \u0026lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] \u0026gt;= height[r]) r --; else if (height[l] \u0026lt; height[r]) l ++; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l \u0026lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] \u0026gt;= height[r]) r --; else if (height[l] \u0026lt; height[r]) l ++; } return res; } };","title":"Lc11_盛最多水的容器"},{"content":" 如果p[j] == \u0026lsquo;*\u0026rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] \u0026amp;\u0026amp; s[i] == p[j - 1]以此类推\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool isMatch(string s, string p) { // s字符串 p字符规律 int n = s.size(), m = p.size(); // 减少边界处理 s = s + \u0026#39; \u0026#39;, p = p + \u0026#39; \u0026#39;; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; f(n + 1, vector\u0026lt;bool\u0026gt; (m + 1)); f[0][0] = true; for (int i = 0; i \u0026lt; n; i ++) { for (int j = 1; j \u0026lt; m; j ++) { if (j + 1 \u0026lt;= m \u0026amp;\u0026amp; p[j + 1] == \u0026#39;*\u0026#39;) continue; if (i \u0026amp;\u0026amp; p[j] != \u0026#39;*\u0026#39;) { f[i][j] = f[i - 1][j - 1] \u0026amp;\u0026amp; (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;); } else if(p[j] == \u0026#39;*\u0026#39;){ f[i][j] = f[i][j - 2] || i \u0026amp;\u0026amp; f[i - 1][j] \u0026amp;\u0026amp; (s[i] == p[j - 1]); } } } return f[n][m]; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc10_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","summary":"如果p[j] == \u0026lsquo;*\u0026rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] \u0026amp;\u0026amp; s[i] == p[j - 1]以此类推 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15","title":"Lc10_正则表达式匹配"},{"content":"解法一 1 2 3 4 5 6 7 8 9 class Solution { public: bool isPalindrome(int x) { string t = to_string(x); auto res = t; reverse(t.begin(), t.end()); return res == t; } }; 解法二 如果负数直接返回 false， 比较正序逆序数字是否一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool isPalindrome(int x) { if (x \u0026lt; 0) return false; long long t = 0; int ans = x; while (x) { t = t * 10 + x % 10; x /= 10; } return ans == t; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc09_%E5%9B%9E%E6%96%87%E6%95%B0/","summary":"解法一 1 2 3 4 5 6 7 8 9 class Solution { public: bool isPalindrome(int x) { string t = to_string(x); auto res = t; reverse(t.begin(), t.end()); return res == t; } }; 解法二 如果负数直接返回 false， 比较正序逆序数字是否一样 1 2 3 4 5","title":"Lc09_回文数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int myAtoi(string s) { int k = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == \u0026#39; \u0026#39;) k ++; //去除前导空格 if (k == s.size()) return 0; int minus = 1; if (s[k] == \u0026#39;-\u0026#39;) k ++, minus = -1; else if (s[k] == \u0026#39;+\u0026#39;) k ++; int res = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[k] \u0026lt;= \u0026#39;9\u0026#39;) { int x = s[k] - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x) / 10) return INT_MAX; //minus = -1，那res是负数，所以 -res * 10 - x \u0026lt; INT_MIN就会溢出 if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (INT_MIN + x) / 10) return INT_MIN; if (-res * 10 - x == INT_MIN) return INT_MIN; res = res * 10 + x; k ++ ; } res *= minus; return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc08_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0aoti/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int myAtoi(string s) { int k = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == \u0026#39; \u0026#39;) k ++; //去除前导空格 if (k == s.size()) return 0; int minus = 1; if (s[k] == \u0026#39;-\u0026#39;)","title":"Lc08_字符串转换整数(aoti)"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x % 10) / 10) return 0; if (x \u0026lt; 0 \u0026amp;\u0026amp; res \u0026lt; (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x /= 10; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc07_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x % 10) / 10) return 0; if (x \u0026lt; 0 \u0026amp;\u0026amp; res \u0026lt; (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x","title":"Lc07_整数反转"},{"content":"题解 题目要求**假设环境不允许存储 64 位整数（有符号或无符号）**所以只能使用 int\n我们要保证 res * 10 + x % 10 不越界，那么有当 x \u0026gt; 0 时， res * 10 + x % 10 \u0026lt; INT_MAX 通过等价变形 res * 10 \u0026lt; INT_MAX - x % 10 。\n由于 x \u0026gt; 0 所以，(INT_MAX - x % 10) / 10不会溢出\n同理，当 x \u0026lt; 0，INT_MIN - x % 10 负数减负数也不会溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: string convert(string s, int numRows) { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; numRows; i ++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; s.size(); j += 2 * numRows - 2) { res += s[j]; } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; s.size() || k \u0026lt; s.size(); j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; s.size()) res += s[j]; if (k \u0026lt; s.size()) res += s[k]; } } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc06_z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","summary":"题解 题目要求**假设环境不允许存储 64 位整数（有符号或无符号）**所以只能使用 int 我们要保证 res * 10 + x % 10 不越界，那么有当 x \u0026gt; 0 时， res * 10 + x %","title":"Lc06_Z字形变换"},{"content":"暴力枚举：\n首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到遇到不同字符为止。\n分两种情况讨论：\n回文串长度是奇数 如：\u0026ldquo;babab\u0026rdquo; 回文串长度是偶数 如：\u0026ldquo;bbcc\u0026rdquo; 如果遇到不同字符，则我们就找到了以 i 为中心的回文串边界。\n时间复杂度：一共两层循环，$O(n^2)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestPalindrome(string s) { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.size(); i ++) { //偶数 int l = i, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) l --, r ++; if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); //奇数 l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) l --, r ++; if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc05_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","summary":"暴力枚举： 首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到遇到不同字符为止。 分两种情况讨论： 回文串长度是奇数 如：\u0026ldquo;ba","title":"Lc05_最长回文子串"},{"content":"双指针经典模板：\nclass Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;int, int\u0026gt; hash; int res = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] \u0026gt; 1) hash[s[l ++]] --; if (res \u0026lt; r - l + 1) res = r - l + 1; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc03_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","summary":"双指针经典模板： class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;int, int\u0026gt; hash; int res = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] \u0026gt; 1) hash[s[l ++]] --; if (res \u0026lt; r - l + 1) res = r - l + 1; } return res; } };","title":"Lc03_无重复字符的最长子串"},{"content":"题解： 模拟加法过程：\n举个 🌰：我们计算 abc + efg，我们应该先计算 c + g 如果结果大于等于 10 则进 1，然后继续计算 b + f 再加上之前的 进位 。\n也就是说，每一位的结果是 ：上一位进位加上当前位所有数的和\n注：一般来说，模拟加法的题目都要 reverse 处理一下，但是这道题是从个位开始，就不用 reverse\n时间复杂度：O(n + m) n 和 m 是两个链表的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int carry = 0; auto dummy = new ListNode(0); auto ret = dummy; while (l1 || l2 || carry) { if (l1) { carry += l1-\u0026gt;val; l1 = l1-\u0026gt;next; } if (l2) { carry += l2-\u0026gt;val; l2 = l2-\u0026gt;next; } dummy-\u0026gt;next = new ListNode(carry % 10); carry /= 10; dummy = dummy-\u0026gt;next; } return ret-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc02_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","summary":"题解： 模拟加法过程： 举个 🌰：我们计算 abc + efg，我们应该先计算 c + g 如果结果大于等于 10 则进 1，然后继续计算 b + f 再加上之前的 进位 。 也就是说，","title":"Lc02_两数相加"},{"content":"React15的生命周期 Mounting 阶段：组件的初始化渲染（挂载） 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成所谓的“首次渲染”。\n注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。\ncomponentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里**执行真实 DOM 相关的操作，**类似于异步请求、数据初始化这样的操作也大可以放在这个生命周期来做。\nUpdating 阶段：组件的更新 componentWillReceiProps(nextProps) 到底是由什么触发的？ 在这个生命周期方法里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）我们可以通过 this.props 拿到，由此便能够感知到 props 的变化。\ncomponentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。\n如果父组件导致组件重新渲染，即使props没有更改也会调用此方法（componentWillReceiProps） 如果只想处理更改，请确保当前值与变更值的比较 \u0026mdash;-React官方\n组件自身 setState 触发的更新 componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。\nrender 与性能：初识 shouldComponentUpdate(nextProps, nextState) React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行re-render（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。\nUnmounting 阶段：组件的卸载 组件销毁的常见原因有以下两个。\n组件在父组件中被移除了：这种情况相对比较直观 组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被干掉。 React16的生命周期 Mounting 阶段：组件的初始化渲染（挂载） 认识 getDerivedStateFromProps(props,state) getDerivedStateFromProps这个API，其设计的初衷不是试图替换掉componentWillMount ，而是试图替换掉componentWillReceiveProps，因此它有且仅有一个用途:使用 props 来派生/更新 state\ngetDerivedStateFromProps 是一个静态方法，静态方法不依赖组件实例而存在，因此你在这个方法内部是访问不到 this 的。\n该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。\ngetDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番。\ngetDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：\n1 2 3 { fatherText: props.text } 该对象并不会替换掉组件原始的这个 state：\n1 this.state = { text: \u0026#34;子组件的文本\u0026#34; }; 而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示： Updating 阶段：组件的更新 React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：\n在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；\n而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。\n为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？ 做合理的减法：\ngetDerivedStateFromProps 直接被定义为 static 方法，static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。 这是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。 消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate方法需要一个返回值，它的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state\u0026amp;props 的信息。\n重点把握它与componentDidUpdate 间的通信过程：\n1 2 3 4 5 6 7 8 9 10 11 // 组件更新时调用 getSnapshotBeforeUpdate(prevProps, prevState) { console.log(\u0026#34;getSnapshotBeforeUpdate方法执行\u0026#34;); return \u0026#34;haha\u0026#34;; } // 组件更新后调用 componentDidUpdate(prevProps, prevState, valueFromSnapshot) { console.log(\u0026#34;componentDidUpdate方法执行\u0026#34;); console.log(\u0026#34;从 getSnapshotBeforeUpdate 获取到的值是\u0026#34;, valueFromSnapshot); } 这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。\nReact16为何两次求变？ Fiber 会使原本同步的渲染过程变成异步的。 同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”。\n换个角度看生命周期工作流 Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：\n总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。\n为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。\n细说生命周期“废旧立新”背后的思考 在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。\n带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：\ncomponentWillMount； componentWillUpdate； componentWillReceiveProps。 这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。\n在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:\nsetState()； fetch 发起异步请求； 操作真实 DOM。 这些操作的问题（或不必要性）包括但不限于以下 3 点：\n完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做。\n比如在 componentWillMount 里发起异步请求。很多同学因为太年轻，以为这样做就可以让异步请求回来得“早一点”，从而避免首次渲染白屏。\n但是异步请求再怎么快也快不过（React 15 下）同步的生命周期。componentWillMount 结束后，render 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题，得不偿失。\n在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。\n比如 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。\n又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。\ngetDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了——避免开发者触碰 this，就是在避免各种危险的骚操作。\n即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。\n比如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。\n总的来说，React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制。在这个改造的过程中，React 团队针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践**。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。\n","permalink":"https://zzydev.top/posts/headfirstreact/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"React15的生命周期 Mounting 阶段：组件的初始化渲染（挂载） 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM","title":"React生命周期"},{"content":" JSX 的本质：JavaScript 的语法扩展 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。\nBabel 具备将 JSX 语法转换为 javascript 的能力\nBabel 的在线地址\nJSX 是如何映射为 DOM 的：起底 createElement 源码 createElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //React的创建元素方法 export function createElement(type, config, children) { // propName 变量用于储存后面需要用到的元素属性 let propName; // props 变量用于储存元素属性的键值对集合 const props = {}; // key、ref、self、source 均为 React 元素的属性，此处不必深究 let key = null; let ref = null; let self = null; let source = null; // config 对象中存储的是元素的属性 if (config != null) { // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值 if (hasValidRef(config)) { ref = config.ref; } // 此处将 key 值字符串化 if (hasValidKey(config)) { key = \u0026#34;\u0026#34; + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面 for (propName in config) { if ( // 筛选出可以提进 props 对象里的属性 hasOwnProperty.call(config, propName) \u0026amp;\u0026amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度 const childrenLength = arguments.length - 2; // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了 if (childrenLength === 1) { // 直接把这个参数的值赋给props.children props.children = children; // 处理嵌套多个子元素的情况 } else if (childrenLength \u0026gt; 1) { // 声明一个子元素数组 const childArray = Array(childrenLength); // 把子元素推进数组里 for (let i = 0; i \u0026lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } // 最后把这个数组赋值给props.children props.children = childArray; } // 处理 defaultProps if (type \u0026amp;\u0026amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props ); } 入参解读：创造一个元素需要知道哪些信息 1 export function createElement(type, config, children) type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。 config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。 children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。 createElement 函数拆解 createElement 的每一个步骤几乎都是在格式化数据\ncreateElement 就像是开发者和 ReactElement 调用之间的一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。整个过程如下图所示：\n出参解读 初识虚拟 dom ReactElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const ReactElement = function (type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; if (DEV) { /*这里是一些针对 __DEV__ 环境下的处理，对于理解主要逻辑意义不大，故省略*/ } return element; }; ReactElement 把传入的参数按照一定的规范，“组装”进了 element 对象里，并把它返回给了 React.createElement，最终 React.createElement 又把它交回到了开发者手中。\n想要验证这一点，可以打印输出 JSX 部分：\n1 2 3 4 5 6 7 8 const AppJSX = ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt;I am the title\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;content\u0026#34;\u0026gt;I am the content\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); console.log(AppJSX); 你会发现它确实是一个标准的 ReactElement 对象实例，如下图：\n这个 ReactElement 对象实例，本质上是 以 JavaScript 对象形式存在的对 DOM 的描述 ，也就是 虚拟 DOM 中的一个节点 。\n“虚拟 DOM”需要通过 ReactDOM.render方法变成渲染到页面上的真实 DOM\n在每一个 React 项目的入口文件中，都少不了对 ReactDOM.render 函数的调用。\n","permalink":"https://zzydev.top/posts/headfirstreact/jsx%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E4%B8%BAdom%E7%9A%84/","summary":"JSX 的本质：JavaScript 的语法扩展 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”","title":"JSX 是如何变成为 DOM 的"},{"content":"手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } 手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj; if (type !== \u0026#34;object\u0026#34;) return type; return Object.prototype .toString() .call(obj) .replace(/^\\[object (\\S+)\\]$/, \u0026#34;S1\u0026#34;); } 手写浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 function shallowClone(target) { if (typeof target === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; target !== null) { const cloneTarget = Array.isArray() ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; } } 手写深拷贝 小杯\n1 2 3 4 5 6 7 8 9 10 11 function deepClone(obj) { let cloneObj = {}; for (let key in obj) { if (typeof key === \u0026#34;obj\u0026#34; \u0026amp;\u0026amp; key !== null) { cloneObj[key] = deepClone(obj[key]); } else { cloneObj[key] = obj[key]; } } return cloneObj; } 超大杯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const isComplexDataType = (obj) =\u0026gt; (typeof obj === \u0026#34;object\u0026#34; || typeof obj === \u0026#34;function\u0026#34;) \u0026amp;\u0026amp; obj !== null; function deepClone(obj, hash = new WeakMap()) { if (obj instanceof Date) return +new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (hash.has(obj)) return hash.get(obj); //获取对象所有属性及其对应的特征 let allDesc = Object.getOwnPropertyDescriptors(obj); //继承原对象的原型链 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc); hash.set(obj, cloneObj); for (let key of Reflect.ownKeys()) { cloneObj[key] = isComplexDataType(obj[key]) \u0026amp;\u0026amp; typeof obj[key] !== \u0026#34;function\u0026#34; ? deepClone(obj[key], hash) : obj[key]; } return cloneObj; } JS WeakMap 应该什么时候使用\n手写深比较 1 2 3 4 5 6 7 8 9 10 11 12 13 const isObject = (obj) =\u0026gt; typeof obj === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj !== null; function isEqual(obj1, obj2) { if (isObject(obj1) ^ isObject(obj2)) return false; if (obj1 === obj2) return true; const obj1Key = Object.keys(obj1); const obj2Key = Object.keys(obj2); if (obj1Key.length !== obj2Key.length) return false; for (let key in obj) { const res = isEqual(obj1[key], obj2[key]); if (!res) return false; } return true; } 手写 call 、apply 、bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Function.prototype.myCall = function (context, ...args) { // xxx.myCall() this就是这里的xxx myApply和myBind中的this同理 context.func = this; context.func(...args); delete context.func; }; Function.prototype.myBind = function () { const args = Array.from(arguments); const t = args.shift(); const self = this; return function () { return self.apply(t, args); }; }; Function.prototype.myApply = function (context, args) { context.func = this; context.func(...args); delete context.func; }; 手写 Object.create() 1 2 3 4 5 6 //这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型 Object.create = function (prototype) { var cls = function () {}; cls.prototype = prototype; return new cls(); }; 手写 new 1 2 3 4 5 6 7 8 9 10 11 12 function myNew(...args) { // 取出 args 数组第一个参数，即目标构造函数 const constructor = args.shift(); // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性 // 即实现 obj.__proto__ = constructor.prototype const obj = Object.create(constructor.prototype); // 执行构造函数，得到构造函数返回结果 // 注意这里我们使用 apply，将构造函数内的 this 指向为 obj const result = constructor.apply(obj, args); // 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象 return typeof result === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; result != null ? result : obj; } 手写防抖节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Throttle(事件节流)： 第一个人说了算 // fn是我们需要包装的事件回调, interval是时间间隔的阈值 function throttle(fn, interval) { // last为上一次触发回调的时间 let last = 0; // 将throttle处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 记录本次触发回调的时间 let now = new Date(); // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last \u0026gt;= interval) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.apply(context, args); } }; } // 用throttle来包装scroll的回调 const better_scroll = throttle(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); // Debounce(事件防抖)： 最后一个人说了算 // fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间 function debounce(fn, delay) { // 定时器 let timer = null; // 将debounce处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 每次事件被触发时，都去清除之前的旧定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(function () { fn.apply(context, args); }, delay); }; } // 用debounce来包装scroll的回调 const better_scroll = debounce(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); 手写 String.prototype.trim 1 2 3 String.prototype.trim = function () { return this.replace(/^\\s+/, \u0026#34;\u0026#34;).replace(/\\s+$/, \u0026#34;\u0026#34;); }; 手写 Array.flat 1 2 3 4 5 6 7 const flat = (arr) =\u0026gt; { const isDeep = arr.some((item) =\u0026gt; item instanceof Array); if (!isDeep) return arr; const res = Array.prototype.concat.apply([], arr); return flat(res); }; 手写去重 1 2 3 4 const unique = (arr) =\u0026gt; { const set = new Set(arr); return [...arr]; }; 手写 setInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const mySetInterval = (fn, delay) =\u0026gt; { let timer = null, isClear = false; function loop() { if (isClear) { isClear = false; clearTimeout(timer); return; } fn(); timer = setTimeout(loop, delay); } timer = setTimeout(loop, delay); return () =\u0026gt; { isClear = true; }; }; 手写 判断类数组 1 2 3 4 5 6 7 8 9 10 const isArrayLikeObject = (arr) =\u0026gt; { if (typeof arr !== \u0026#34;object\u0026#34; || arr === null) return false; const lengthMaxVal = Math.pow(2, 53) - 1; if (!Object.prototype.hasOwnProperty.call(arr, \u0026#34;length\u0026#34;)) return false; if (typeof arr.length !== \u0026#34;number\u0026#34;) return false; if (!isFinite(arr.length)) return false; if (Array !== arr.constructor) return false; if (arr.length \u0026gt; 0 \u0026amp;\u0026amp; arr.length \u0026lt; lengthMaxVal) return true; return false; }; 手写 模拟私有 1 2 3 4 5 6 7 8 9 function cls() { this.a = \u0026#34;who care\u0026#34;; return { getVal: () =\u0026gt; this.a, }; } let obj = new cls(); obj.getVal(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const myWm = new WeakMap(); class Fish { constructor(name) { myWm.set(this, { _fishbone: [ \u0026#34;草鱼\u0026#34;, \u0026#34;鲫鱼\u0026#34;, \u0026#34;青鱼\u0026#34;, \u0026#34;鲤鱼\u0026#34;, \u0026#34;鲢鱼\u0026#34;, \u0026#34;鳙鱼\u0026#34;, \u0026#34;鳊鱼\u0026#34;, \u0026#34;翘嘴\u0026#34;, \u0026#34;餐条\u0026#34;, ], }); this.name = name; } isBone() { return myWm.get(this)._fishbone.includes(this.name); } } // 测试，买了两条鱼 let fish1 = new Fish(\u0026#34;草鱼\u0026#34;); let fish2 = new Fish(\u0026#34;回鱼\u0026#34;); // 返回 true，有刺 console.log(fish1.isBone()); // 返回 false，没有肌间刺 console.log(fish2.isBone()); 获取当前 url 中的参数的值 1 2 3 4 5 const query = (name) =\u0026gt; { const search = location.search; const params = new URLSearchParams(search); return params.get(name); }; 将 URL 参数解析为 JS 对象 1 2 3 4 5 6 7 8 9 function queryToObject() { const res = {}; const search = location.search; const pList = new URLSearchParams(search); pList.forEach((key, val) =\u0026gt; { res[key] = val; }); return res; } ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C/","summary":"手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } 手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj;","title":"有手就行"},{"content":"使用 C++中的哈希表——unordered_map\u0026lt;int, int\u0026gt;\n循环一遍 nums 数组，在每步循环中我们判断 target - nums[i] 是否在哈希表中 ：\n如果是就找到和为 target 的一对数字，直接返回答案即可； 如果否就将 nums[i] 插入哈希表中；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt; hash; for (int i = 0; i \u0026lt; nums.size();i ++) { if (hash.count(target - nums[i])) { return {hash[target - nums[i]], i}; } else { hash[nums[i]] = i; } } return {}; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"使用 C++中的哈希表——unordered_map\u0026lt;int, int\u0026gt; 循环一遍 nums 数组，在每步循环中我们判断 target - nums[i] 是否在哈希表中 ： 如果是就找到和","title":"Lc01_两数之和"}]