[{"content":" 本文只记录一些个人觉得比较容易遗忘或需要注意的点，抑或是一些跟本人接触过的其他静态语言不太一样的语法，并不是一份完整的学习教程。\n\u0026nbsp;函数类型的书写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 函数类型 function info(username: string, age: number): number { return age; } type Func = (username: string, age: number) =\u0026gt; number; let info: Func = function (username, age) { return age; }; let info = (username: string, age: number): number =\u0026gt; { return age; }; // 接口当名字的函数类型 interface ActionContext { (state: any, commit: any): void; } let actionContext: ActionContext = (state, commit) =\u0026gt; { console.log(state); }; \u0026nbsp;异步函数、Generator 函数等类型签名 1 2 3 4 5 async function asyncFunc(): Promise\u0026lt;void\u0026gt; {} function* genFunc(): Iterable\u0026lt;void\u0026gt; {} async function* asyncGenFunc(): AsyncIterable\u0026lt;void\u0026gt; {} \u0026nbsp;object、Object 以及 { } 在任何情况下，你都不应该使用 Object、String 等这些装箱类型\nobject 的引入就是为了解决对 Object 类型的错误使用，它代表所有非原始类型的类型，即数组、对象与函数类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //在 TypeScript 中就表现为 Object 包含了所有的类型: const tmp1: Object = undefined; const tmp2: Object = null; const tmp3: Object = void 0; const tmp4: Object = \u0026#34;zzydev\u0026#34;; const tmp5: Object = 233; const tmp6: Object = { name: \u0026#34;zzydev\u0026#34; }; const tmp7: Object = () =\u0026gt; {}; const tmp8: Object = []; /* 和 Object 类似的还有 Boolean、Number、String、Symbol，这几个装箱类型同样包含了一些超出预期的类型。 以 String 为例，它同样包括 undefined、null、void，以及代表的拆箱类型string， 但并不包括其他装箱类型对应的拆箱类型，如boolean与基本对象类型， */ const tmp9: String = undefined; const tmp10: String = null; const tmp11: String = void 0; const tmp12: String = \u0026#34;zzydev\u0026#34;; const tmp13: String = 233; // ❎ const tmp14: String = { name: \u0026#34;zzydev\u0026#34; }; // ❎ const tmp15: String = () =\u0026gt; {}; // ❎ const tmp16: String = []; // ❎ //{}作为类型签名就是一个合法的，但内部无属性定义的空对象，这类似于Object，⚠️它意味着任何非null/undefined的值： const tmp25: {} = undefined; // ❎ const tmp26: {} = null; // ❎ const tmp27: {} = void 0; // ❎ const tmp28: {} = \u0026#34;zzydev\u0026#34;; const tmp29: {} = 233; const tmp30: {} = { name: \u0026#34;zzydev\u0026#34; }; const tmp31: {} = () =\u0026gt; {}; const tmp32: {} = []; //⚠️ 虽然能够将其作为变量的类型，但你实际上无法对这个变量进行任何赋值操作： const tmp30: {} = { name: \u0026#34;zzydev\u0026#34; }; tmp30.age = 18; // ❎ 类型“{}”上不存在属性“age”。 const tmp31: Object = { name: \u0026#34;zzydev\u0026#34; }; tmp31.age = 18; // ❎ 属性name不存在于类型Object上 当你不确定某个变量的具体类型，但能确定它不是原始类型，推荐 👍 使用 Record\u0026lt;string, unknown\u0026gt; 或 Record\u0026lt;string, any\u0026gt; 表示对象，unknown[] 或 any[] 表示数组，(...args: any[]) =\u0026gt; any表示函数这样。同样要避免使用{}。{}意味着任何非null/undefined的值，从这个层面上看，使用它和使用any一样恶劣。\n\u0026nbsp;对象取值的坑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let obj = {username: \u0026#34;zzy\u0026#34;, age: 18} // 类型推导 obj[\u0026#34;username\u0026#34;] // ✅ //let 声明，只需要推导至这个值从属的类型即可。 username在这里是string类型 let username = \u0026#34;username\u0026#34; obj[username] // ❎ //而 const 声明的原始类型变量将不再可变，因此类型可以直接一步到位收窄到最精确的字面量类型 // username在这里是”username“字面量类型 const username = \u0026#34;username\u0026#34; obj[username] // ✅ -------------------------------------------------- let obj:object | Object = {username: \u0026#34;zzy\u0026#34;, age: 18} const username = \u0026#34;username\u0026#34; let res = obj[username] // ❎ let res = (obj as any)[username] // ✅ 对于 let 声明，只需要推导至这个值从属的类型即可。而 const 声明的原始类型变量将不再可变，因此类型可以直接一步到位收窄到最精确的字面量类型，但对象类型变量仍可变（但同样会要求其属性值类型保持一致）。 \u0026nbsp;联合类型 们还可以将各种类型混合到一起:\n1 2 3 interface Tmp { mixed: true | string | 599 | {} | (() =\u0026gt; {}) | (1 | 2); } 这里有几点需要注意的：\n对于联合类型中的函数类型，需要使用括号()包裹起来 函数类型并不存在字面量类型，因此这里的 (() =\u0026gt; {}) 就是一个合法的函数类型 你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中 联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface Tmp { user: | { vip: true; expires: string; } | { vip: false; promotion: string; }; } declare var tmp: Tmp; if (tmp.user.vip) { console.log(tmp.user.expires); } \u0026nbsp;never never 类型不携带任何的类型信息，因此会在联合类型中被直接移除 void 和 never 的类型兼容性： never 是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 declare let v1: never; declare let v2: void; v1 = v2; // ❎ 类型 void 不能赋值给类型 never v2 = v1; //抛出错误的函数返回never类型 function justThrow(): never { throw new Error(); } //在类型流的分析中，一旦一个返回值类型为never的函数被调用，那么下方的代码都会被视为无效的代码（即无法执行到）： function foo(input: number) { if (input \u0026gt; 1) { justThrow(); // 等同于 return 语句后的代码，即 Dead Code const name = \u0026#34;zzydev\u0026#34;; } } never 的应用场景之一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // dataFlowAnalysisWithNever 方法穷尽了 DataFlow 的所有可能类型。 // 使用 never 避免出现未来扩展新的类没有对应类型的实现, 目的就是写出类型绝对安全的代码。 type DataFlow = string | number; function dataFlowAnalysisWithNever(dataFlow: DataFlow) { if (typeof dataFlow === \u0026#34;string\u0026#34;) { console.log(\u0026#34;字符串类型:\u0026#34;, dataFlow.length); } else if (typeof dataFlow === \u0026#34;number\u0026#34;) { console.log(\u0026#34;数值类型:\u0026#34;, dataFlow.toFixed(2)); } else { let data = dataFlow; // data现在为never类型，假如以后DateFlow的类型加上boolean,那data就变成boolean类型 } } dataFlowAnalysisWithNever(\u0026#34;zzy\u0026#34;); dataFlowAnalysisWithNever(3.1415926); \u0026nbsp;数字枚举和字符串枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //数字枚举 enum A { A = 10, B = 12, // 没有写值，默认以上一个值自增1 C, D, } console.log(A[\u0026#34;B\u0026#34;]); // 12 数字枚举 可以双重映射 由键到值，也可以由值到键 console.log(A[10]); // A // 在数字型枚举中，你可以使用延迟求值的枚举值: const returnNum = () =\u0026gt; 100 + 499; enum Items { Foo = returnNum(), Bar = 599, Baz, } //⚠️注意，延迟求值的枚举值是有条件的。 //如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后，或者放在第一位： enum Items { First, // 第一位 Foo = returnNum(), //这里不能放未赋值成员 Bar = 599, Baz, // 常量枚举成员之后 } // 常量枚举 const enum Items { Foo, Bar, Baz, } //对于常量枚举，你只能通过枚举成员访问枚举值（而不能通过值访问成员） const fooValue = Items.Foo; // 编译产物: const fooValue = 0 /* Foo */; // 0 // 字符串枚举 enum WeekEnd { Monday = \u0026#34;monday\u0026#34;, Tuesday = \u0026#34;tuesday\u0026#34;, Wensday = \u0026#34;wensday\u0026#34;, ThirsDay = \u0026#34;thirsDay\u0026#34;, Friday = \u0026#34;friday\u0026#34;, Sarturday = \u0026#34;sarturday\u0026#34;, Sunday = \u0026#34;sunday\u0026#34;, } console.log(WeekEnd.Monday); console.log(WeekEnd[\u0026#34;Monday\u0026#34;]); console.log(WeekEnd[\u0026#34;monday\u0026#34;]); // ❎ 不能反向映射 console.log(weekEnd[1]); // ❎ \u0026nbsp;枚举的编译成ES5的真面目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //这就是数字枚举双向映射的原因 var A; (function (A) { A[(A[\u0026#34;A\u0026#34;] = 10)] = \u0026#34;A\u0026#34;; A[(A[\u0026#34;B\u0026#34;] = 12)] = \u0026#34;B\u0026#34;; A[(A[\u0026#34;C\u0026#34;] = 13)] = \u0026#34;C\u0026#34;; A[(A[\u0026#34;D\u0026#34;] = 14)] = \u0026#34;D\u0026#34;; })(A || (A = {})); var WeekEnd; (function (WeekEnd) { WeekEnd[\u0026#34;Monday\u0026#34;] = \u0026#34;monday\u0026#34;; WeekEnd[\u0026#34;Tuesday\u0026#34;] = \u0026#34;tuesday\u0026#34;; WeekEnd[\u0026#34;Wensday\u0026#34;] = \u0026#34;wensday\u0026#34;; WeekEnd[\u0026#34;ThirsDay\u0026#34;] = \u0026#34;thirsDay\u0026#34;; WeekEnd[\u0026#34;Friday\u0026#34;] = \u0026#34;friday\u0026#34;; WeekEnd[\u0026#34;Sarturday\u0026#34;] = \u0026#34;sarturday\u0026#34;; WeekEnd[\u0026#34;Sunday\u0026#34;] = \u0026#34;sunday\u0026#34;; })(WeekEnd || (WeekEnd = {})); \u0026nbsp;可选参数与rest参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 在函数逻辑中注入可选参数默认值 //⚠️可选参数必须位于必选参数之后 function foo1(name: string, age?: number): number { const inputAge = age || 18; // 使用 age 或者 18 return name.length + inputAge; } // 直接为可选参数声明默认值 function foo2(name: string, age: number = 18): number { const inputAge = age; return name.length + inputAge; } // rest参数 function foo(arg1: string, ...rest: any[]) {} // 使用元组类型进行标注 function foo(arg1: string, ...rest: [number, boolean]) {} \u0026nbsp;函数重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 type MessageType = \u0026#34;image\u0026#34; | \u0026#34;audio\u0026#34; | string; //微信消息类型 type Message = { id: number; type: MessageType; sendmessage: string; }; let messages: Message[] = [ //let messages: Array\u0026lt;Message\u0026gt; = [ { id: 1, type: \u0026#34;image\u0026#34;, sendmessage: \u0026#34;我要涩涩.png\u0026#34;, }, { id: 2, type: \u0026#34;audio\u0026#34;, sendmessage: \u0026#34;深夜在浅色床单痛哭失声.mp4\u0026#34;, }, { id: 3, type: \u0026#34;audio\u0026#34;, sendmessage: \u0026#34;你干嘛~(ikun纯享版).flac\u0026#34;, }, { id: 4, type: \u0026#34;image\u0026#34;, sendmessage: \u0026#34;不可以涩涩.png\u0026#34;, }, { id: 5, type: \u0026#34;image\u0026#34;, sendmessage: \u0026#34;医业丁真，鉴定为九十割几把.png\u0026#34;, }, ]; //不用函数重载来实现 //函数结构不分明,可读性，可维护性变差 function getMessage( value: number | MessageType ): Message | undefined | Array\u0026lt;Message\u0026gt; { if (typeof value === \u0026#34;number\u0026#34;) { return messages.find((msg) =\u0026gt; value === msg.id); } else { return messages.filter((msg) =\u0026gt; value === msg.type); } } console.log(getMessage(\u0026#34;audio\u0026#34;)); // TS没有办法运行之前根据传递的值来推导方法最终返回的数据的数据类型 // 只可以根据方法定义的类型展现 //let msg=getMessage(1) //⚠️ console.log(msg.sendMessage)//错误 类型“Message | Message[]”上不存在属性“sendMessage”。 // 类型“Message”上存在属性“sendMessage” let msg = (\u0026lt;Message\u0026gt;getMessage(1)).sendmessage; console.log(\u0026#34;msg:\u0026#34;, msg); function getMessage(value: number): Message; //第一个根据数字id来查询单个消息的重载签名 function getMessage(value: MessageType, readRecordCount: number): Message[]; //第二个根据消息类型来查询消息数组的重载签名 //实现签名参数个数可以少于重载签名的参数个数，但实现签名如果准备包含重载签名的某个位置的参数 ，那实现签名就必须兼容所有重载签名该位置的参数类型【联合类型或 any 或 unknown 类型的一种】。 //不管重载签名返回值类型是何种类型，实现签名都可以返回 any 类型 或 unknown类型，当然一般我们两者都不选择，让 TS 默认为实现签名自动推导返回值类型。 //由于实现签名第二个参数有默认值，所以这里的重载签名可以没有第二个参数，也可以在实现签名的参数加上可选? function getMessage(value: any, value2: any = 1) { // function getMessage(value: any, value2?: any) { if (typeof value === \u0026#34;number\u0026#34;) { return messages.find((msg) =\u0026gt; { return msg === msg.id; }); } else { return messages.filter((msg) =\u0026gt; value === msg.type).splice(0, value2); } } getMessage(1); \u0026nbsp;类声明和类表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 类声明 class Foo { // =========通过构造函数为类成员赋值 ================ private prop: string; constructor(inputProp: string) { this.prop = inputProp; } // ============================================== // 上面代码可以简写为这一行： constructor(private prop: string) {} protected print(addon: string): void { console.log(`${this.prop} and ${addon}`); } public get propA(): string { return `${this.prop}+A`; } // ⚠️ setter 方法不允许进行返回值的类型标注 public set propA(value: string) { this.prop = `${value}+A`; } } // 类表达式 const Foo = class { prop: string; constructor(inputProp: string) { this.prop = inputProp; } print(addon: string): void { console.log(`${this.prop} and ${addon}`); } // ... }; \u0026nbsp;static与单件设计模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 第一步：把构造器设置为私有的，不允许外部来创建类的对象 // 第二步: 至少应该提供一个外部访问的方法或属性，外部可以通过这个方法或属性来得到一个对象 // 所以应该把这个方法设置为静态方法 // 第三步：外部调用第二步提供的静态方法来获取一个对象 // 懒汉式 export default class MyLocalStorage { static localstorage: MyLocalStorage//静态引用属性 static count: number = 3;//静态的基本类型属性 private constructor() { console.log(\u0026#34;这是TS的单件设计模式的静态方法的构造器\u0026#34;); } // 提供一个外部访问的方法, // 通过这个方法用来提供外部得到一个对象的方法 // 1. 带static关键字的方法就是一个静态方法 // 2. 静态方法和对象无关，外部的对象变量不能调用静态方法和静态属性， // 3. 外部可以通过类名来调用 // 静态方法不可以访问实例属性或实例方法 public static getInstance() { // 静态方法通过this来获取静态成员 if (!this.localstorage) {//如果静态对象属性指向创建对象 console.log(\u0026#34;我是一个undefined的静态属性，用来指向一个对象空间的静态属性\u0026#34;) this.localstorage = new MyLocalStorage() } return this.localstorage } public setItem(key: string, value: any) { localStorage.setItem(key, JSON.stringify(value)) } public getItem(key: string) { let value = localStorage.getItem(key) return value != null ? JSON.parse(value) : null; } } /* let oo = new MyLocalStorage.getInstance(); //❎ 错误 TS已经屏蔽了去new一个类中的方法 MyLocalStorage.prototype.newFn = function () {} //❎ 错误 TS类可以访问prototype原型对象属性，但无法在prototype原型对象属性增加新的方法或属性 MyLocalStorage.prototype.setItem = function () {} //✅ 正确 但是可以覆盖类上已经存在的方法 */ 编译成 javaScript 的代码：\n静态成员直接被挂载在函数体上，而实例成员挂载在原型上\n静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）。而原型对象上的实例成员则会沿着原型链进行传递，也就是能够被继承。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026#34;use strict\u0026#34;; exports.__esModule = true; var MyLocalStorage = /** @class */ (function () { function MyLocalStorage() { console.log(\u0026#34;这是TS的单件设计模式的静态方法的构造器\u0026#34;); } MyLocalStorage.getInstance = function () { if (!this.localstorage) { console.log( \u0026#34;我是一个undefined的静态属性，用来指向一个对象空间的静态属性\u0026#34; ); this.localstorage = new MyLocalStorage(); } return this.localstorage; }; MyLocalStorage.prototype.setItem = function (key, value) { localStorage.setItem(key, JSON.stringify(value)); }; MyLocalStorage.prototype.getItem = function (key) { var value = localStorage.getItem(key); return value != null ? JSON.parse(value) : null; }; MyLocalStorage.count = 3; return MyLocalStorage; })(); exports[\u0026#34;default\u0026#34;] = MyLocalStorage; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 饿汉式 class MyLocalStorage { static localstorage: MyLocalStorage = new MyLocalStorage(); static count: number = 3; private constructor() { console.log(\u0026#34;这是TS的单件设计模式的静态方法的构造器\u0026#34;); } public setItem(key: string, value: any) { localStorage.setItem(key, JSON.stringify(value)); } public getItem(key: string) { let value = localStorage.getItem(key); return value != null ? JSON.parse(value) : null; } } 无论你是否创建对象，创建多少个对象，是否调用该静态方法或静态属性，TS 都会为这个静态方法或静态属性分配内存空间，注意：静态成员和对象无关。\n一旦为静态方法或静态属性分配好空间，就一直保存到内存中，直到服务器重启或者控制台程序执行结束才被释放。\n\u0026nbsp;TS继承 回顾手写 JS 继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Base { print() {} } class Derived extends Base { //派生类对基类成员的访问与覆盖操作 print() { super.print(); // ... } //override 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义 //在这里 TS 将会给出错误，因为尝试覆盖的方法并未在基类中声明。 override say() {} } //⚠️ 在TypeScript中无法声明静态的抽象成员 //抽象类 abstract class LoginHandler { abstract handler(): void; } // 其实 interface 也可以描述类的结构 interface LoginHandler { hander(): void; } class WeChatLoginHandler implements LoginHandler { handler() {} } class TaoBaoLoginHandler implements LoginHandler { handler() {} } class TikTokLoginHandler implements LoginHandler { handler() {} } class Login { public static handlerMap: Record\u0026lt;LoginType, LoginHandler\u0026gt; = { [LoginType.TaoBao]: new TaoBaoLoginHandler(), [LoginType.TikTok]: new TikTokLoginHandler(), [LoginType.WeChat]: new WeChatLoginHandler(), }; public static handler(type: LoginType) { Login.handlerMap[type].handler(); } } //使用 Newable Interface 来描述一个类的结构（类似于描述函数结构的 Callable Interface）： class Foo {} interface FooStruct { new (): Foo; } declare const NewableFoo: FooStruct; const foo = new NewableFoo(); // 什么是 Callable Interface interface FuncFooStruct { (name: string): number; } \u0026nbsp;any unknown unknown 类型和 any 类型有些类似，一个 unknown 类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let unknownVar: unknown = \u0026#34;zzy\u0026#34;; unknownVar = false; unknownVar = \u0026#34;zzy\u0026#34;; unknownVar = { site: \u0026#34;zzy\u0026#34;, }; unknownVar = () =\u0026gt; {}; const val1: string = unknownVar; // ❎ const val2: number = unknownVar; // ❎ const val3: () =\u0026gt; {} = unknownVar; // ❎ const val4: {} = unknownVar; // ❎ const val5: any = unknownVar; const val6: unknown = unknownVar; 1 2 3 4 let unknownVar: unknown; unknownVar.foo(); // 报错：对象类型为 unknown //类型断言 (unknownVar as { foo: () =\u0026gt; {} }).foo(); \u0026nbsp;类型断言 类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型：\n1 2 3 4 5 6 7 8 9 10 11 12 interface IFoo { name: string; } declare const obj: { foo: IFoo; }; const { foo = {} } = obj; //这里foo的类型是{} //foo.name ❎ const { foo = {} as IFoo } = obj; //这里foo的类型是IFoo foo.name; 双重断言 你的断言类型和原类型的差异太大，需要先断言到一个通用的类，即 any/unknown。这一通用类型包含了所有可能的类型，因此断言到它和从它断言到另一个类型差异不大。\n1 2 3 4 5 6 7 const str: string = \u0026#34;linbudu\u0026#34;; // 从 X 类型 到 Y 类型的断言可能是错误的 ... (str as { handler: () =\u0026gt; {} }).handler(); (str as unknown as { handler: () =\u0026gt; {} }).handler(); // 使用尖括号断言 (\u0026lt;{ handler: () =\u0026gt; {} }\u0026gt;(\u0026lt;unknown\u0026gt;str)).handler(); 非空断言 非空断言其实是类型断言的简化，它使用 ! 语法，即obj!.func()!.prop的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 declare const foo: { func?: () =\u0026gt; { prop?: number | null; }; }; foo.func!().prop!.toFixed(); //其应用位置类似于可选链： foo.func?.().prop?.toFixed(); /* 但不同的是，非空断言的运行时仍然会保持调用链，因此在运行时可能会报错。 而可选链则会在某一个部分收到 undefined 或 null 时直接短路掉，不会再发生后面的调用。 */ //非空断言的常见场景还有 document.querySelector、Array.find 方法等： const element = document.querySelector(\u0026#34;#id\u0026#34;)!; const target = [1, 2, 3, 233].find((item) =\u0026gt; item === 233)!; 为什么说非空断言是类型断言的简写：\n1 2 3 4 5 6 7 8 9 foo.func!().prop!.toFixed(); //等价于 ( ( foo.func as () =\u0026gt; { prop?: number; } )().prop as number ).toFixed(); \u0026nbsp;交叉类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Struct1 = { primitiveProp: string; objectProp: { name: string; }; }; type Struct2 = { primitiveProp: number; objectProp: { age: number; }; }; type Composed = Struct1 \u0026amp; Struct2; type PrimitivePropType = Composed[\u0026#34;primitiveProp\u0026#34;]; // never 交集为空集 //对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并 type ObjectPropType = Composed[\u0026#34;objectProp\u0026#34;]; // { name: string; age: number; } // 合并后的 name 同样是 never 类型 type Derived = Struct1 \u0026amp; { primitiveProp: number; }; 扩展：接口的合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Struct1 { primitiveProp: string; objectProp: { name: string; }; } // 接口“Struct2”错误扩展接口“Struct1”。属性“primitiveProp”的类型不兼容。不能将类型“number”分配给类型“string”。 interface Struct2 extends Struct1 { primitiveProp: number; objectProp: { age: number; }; } 如果你直接声明多个同名接口，虽然接口会进行合并，但这些同名属性仍然需要属于同一类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface Struct1 { primitiveProp: string; objectProp: { name: string; }; } interface Struct1 { // 后续属性声明必须属于同一类型。属性“primitiveProp”的类型必须为“string”，但此处却为类型“number”。 primitiveProp: number; // 类似的报错 objectProp: { age: number; }; } \u0026nbsp;索引类型 索引签名类型主要指的是在接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 interface AllStringTypes { [key: string]: string; } type AllStringTypes = { [key: string]: string; }; /* 但由于 JavaScript 中，对于 obj[prop] 形式的访问会将数字索引访问转换为字符串索引访问。 所以obj[233] 和 obj[\u0026#39;233\u0026#39;] 的效果是一致的。在字符串索引签名类型中我们仍然可以声明数字类型的键。 类似的，symbol 类型也是如此： */ const foo: AllStringTypes = { zzydev: \u0026#34;233\u0026#34;, 233: \u0026#34;zzydev\u0026#34;, [Symbol(\u0026#34;zzy\u0026#34;)]: \u0026#34;symbol\u0026#34;, }; // propA 和 propB 的类型要符合索引签名类型的声明 interface StringOrBooleanTypes { propA: number; propB: boolean; [key: string]: number | boolean; } \u0026nbsp;索引类型查询与索引类型访问 索引类型查询 keyof：\n1 2 3 4 5 6 7 8 9 10 11 interface Foo { zzy: 1; 233: 2; } // \u0026#34;zzy\u0026#34; | 233 注意这里的233仍然是数字 type FooKeys = keyof Foo; type Any = keyof any; //相当于 type Any = string | number | symbol; 索引类型访问:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 interface NumberRecord { [key: string]: number; } type PropType = NumberRecord[string]; // number interface Foo { propA: number; propB: boolean; } type PropAType = Foo[\u0026#34;propA\u0026#34;]; // number type PropBType = Foo[\u0026#34;propB\u0026#34;]; // boolean type PropType = Foo[string]; // ❎ 在未声明索引签名类型的情况下，不能使用Foo[string]这种方式访问 /* 看起来这里就是普通的值访问，但实际上这里的\u0026#39;propA\u0026#39;和\u0026#39;propB\u0026#39;都是字符串字面量类型，而不是一个JavaScript字符串值。 索引类型查询的本质其实就是，通过键的字面量类型（\u0026#39;propA\u0026#39;）访问这个键对应的键值类型（number）。 */ //⚠️ 索引类型查询、索引类型访问通常会和映射类型一起搭配使用，前两者负责访问键，而映射类型在其基础上访问键值类型。 interface Foo { propA: number; propB: boolean; propC: string; } // string | number | boolean type PropTypeUnion = Foo[keyof Foo]; \u0026nbsp;映射类型 映射类型的主要作用即是基于键名映射到键值类型：\n1 2 3 4 5 type stringify\u0026lt;T\u0026gt; = { [K in keyof T]: string }; type Clone\u0026lt;T\u0026gt; = { //索引签名类型 : 索引类型访问 [K in keyof T]: T[K]; }; \u0026nbsp;类型查询运算符typeof 在逻辑代码中使用的 typeof 一定会是 JavaScript 中的 typeof， 类型代码（如类型标注、类型别名中等）中的一定是类型查询的 typeof 为了更好地避免这种情况，也就是隔离类型层和逻辑层，类型查询操作符后是不允许使用表达式的：\n1 2 3 4 const isInputValid = (input: string) =\u0026gt; { return input.length \u0026gt; 0; }; type isValid = typeof isInputValid(\u0026#34;zzy\u0026#34;); // ❎ \u0026nbsp;⭐ 类型守卫 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //判断逻辑封装起来提取到函数外部进行复用 function isString(input: unknown): boolean { return typeof input === \u0026#34;string\u0026#34;; } function foo(input: string | number) { if (isString(input)) { //❓ 类型“string | number”上不存在属性“replace”。 // 这里的类型控制流分析做不到跨函数上下文来进行类型的信息收集 input.replace(\u0026#34;zzy\u0026#34;, \u0026#34;233\u0026#34;); } if (typeof input === \u0026#34;number\u0026#34;) { } // ... } 为了解决这一类型控制流分析的能力不足，TypeScript 引入了is 关键字来显式地提供类型信息。\n在这里 isString 函数称为类型守卫，在它的返回值中，我们不再使用 boolean 作为类型标注，而是使用input is string 将input is string拆开：\ninput 函数的某个参数； is string，即 is 关键字 + 预期类型，即如果这个函数成功返回为 true，那么 is 关键字前这个入参的类型，就会被这个类型守卫调用方后续的类型控制流分析收集到。 1 2 3 function isString(input: unknown): input is string { return typeof input === \u0026#34;string\u0026#34;; } 开发中常用的两个类型守卫：\n1 2 3 4 5 6 7 8 9 export type Falsy = false | \u0026#34;\u0026#34; | 0 | null | undefined; export const isFalsy = (val: unknown): val is Falsy =\u0026gt; !val; // 不包括不常用的 symbol 和 bigint export type Primitive = string | number | boolean | undefined; export const isPrimitive = (val: unknown): val is Primitive =\u0026gt; [\u0026#34;string\u0026#34;, \u0026#34;number\u0026#34;, \u0026#34;boolean\u0026#34;, \u0026#34;undefined\u0026#34;].includes(typeof val); 除了使用 typeof 以外，我们还可以使用许多类似的方式来进行类型保护，只要它能够在联合类型的类型成员中起到筛选作用。\n\u0026nbsp;基于 in 与 instanceof 的类型保护 可以通过key in object的方式来判断 key 是否存在于 object 或其原型链上（返回 true 说明存在）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 interface A { a: string; aOnly: string; c: string; } interface B { b: string; bOnly: string; c: string; } function check(val: A | B) { if (\u0026#34;a\u0026#34; in val) { //Property \u0026#39;aOnly\u0026#39; does not exist on type \u0026#39;A | B\u0026#39;.Property \u0026#39;aOnly\u0026#39; does not exist on type \u0026#39;B\u0026#39; val.aOnly; } else { //Property \u0026#39;bOnly\u0026#39; does not exist on type \u0026#39;never\u0026#39; val.bOnly; } } function check2(val: A | B) { if (\u0026#34;c\u0026#34; in val) { //类型 \u0026#34;A | B\u0026#34;上不存在属性 \u0026#34;aOnly\u0026#34; val.aOnly; } else { val.bOnly; } } 可辨识属性可以是结构层面的，比如结构 A 的属性 prop 是数组，而结构 B 的属性 prop 是对象，或者结构 A 中存在属性 prop 而结构 B 中不存在，或者共同属性字面量差异等。\n使用instanceof进行类型保护：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FooBase {} class BarBase {} class Foo extends FooBase { fooOnly() {} } class Bar extends BarBase { barOnly() {} } function handle(input: Foo | Bar) { if (input instanceof FooBase) { input.fooOnly(); } else { input.barOnly(); } } \u0026nbsp;断言守卫 断言守卫和类型守卫最大的不同点在于，在判断条件不通过时，断言守卫需要抛出一个错误，类型守卫只需要剔除掉预期的类型\n👍 官方文档简明易懂：assertion-functions\n\u0026nbsp;泛型约束与默认值 在泛型中，我们可以使用 extends 关键字来约束传入的泛型参数必须符合要求。\nA = B或 A extends B意味着 B 是 A 的子类型\n例如：U extends keyof T表示U的类型被约束在联合类型keyof T的范围内\nextends 还经常用于条件类型： T extends U ? T : never,条件类型有点像 JavaScript 中的三元表达式\n在条件类型中，有一个特别需要注意的东西就是：分布式条件类型: TypeScript 对联合类型在条件类型中使用时的特殊处理：会把联合类型的每一个元素单独传入做类型计算，最后合并。\n这和联合类型遇到字符串时的处理一样：\n\u0026nbsp;对象类型中的泛型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //这个接口描述了一个通用的响应类型结构，预留出了实际响应数据的泛型坑位， //然后在你的请求函数中就可以传入特定的响应类型了： interface IRes\u0026lt;TData = unknown\u0026gt; { code: number; error?: string; data: TData; } interface IUserProfileRes { name: string; homepage: string; avatar: string; } function fetchUserProfile(): Promise\u0026lt;IRes\u0026lt;IUserProfileRes\u0026gt;\u0026gt; {} type StatusSucceed = boolean; function handleOperation(): Promise\u0026lt;IRes\u0026lt;StatusSucceed\u0026gt;\u0026gt; {} //泛型嵌套的场景也非常常用，比如对存在分页结构的数据，我们也可以将其分页的响应结构抽离出来： interface IPaginationRes\u0026lt;TItem = unknown\u0026gt; { data: TItem[]; page: number; totalCount: number; hasNextPage: boolean; } function fetchUserProfileList(): Promise\u0026lt; IRes\u0026lt;IPaginationRes\u0026lt;IUserProfileRes\u0026gt;\u0026gt; \u0026gt; {} \u0026nbsp;函数中的泛型 箭头函数的泛型书写 ✍🏻 方式：\n1 2 3 4 5 const handle = \u0026lt;T\u0026gt;(input: T): T =\u0026gt; {}; //需要注意的是在 tsx 文件中泛型的尖括号可能会造成报错，编译器无法识别这是一个组件还是一个泛型， //此时你可以让它长得更像泛型一些： const handle = \u0026lt;T extends any\u0026gt;(input: T): T =\u0026gt; {}; 不要为了用泛型而用泛型，泛型参数 T 没有被返回值消费，也没有被内部的逻辑消费，这种情况下即使随着调用填充了泛型参数，也是没有意义的。\n1 2 3 4 //这里完全可以用 any 来进行类型标注 function handle\u0026lt;T\u0026gt;(arg: T): void { console.log(arg); } \u0026nbsp;类型系统层级 1 2 3 4 5 6 type Result = String extends {} ? 1 : 2; // 1 type Result1 = {} extends object ? 1 : 2; // 1 type Result2 = object extends Object ? 1 : 2; // 1 //string extends object 并不成立 type Tmp = string extends object ? 1 : 2; //⚠️ 2 1 2 3 type Result = Object extends any ? 1 : 2; // 1 //⚠️ 将any调过来，值竟然变成了 1 | 2 type Result1 = any extends {} | object | Object ? 1 : 2; // 1 | 2 基础的类型层级链：Bottom Type(never) \u0026lt; 对应的字面量类型 \u0026lt; 基础类型 \u0026lt; 装箱类型 \u0026lt; 顶级类型(Object) \u0026lt; Top Type(any/unknown)\n补充：\n1 2 3 4 5 6 7 type Result1 = [number, string] extends number[] ? 1 : 2; // 2 // let arr: (number| string)[] = [233, \u0026#34;zzy\u0026#34;] type Result2 = [number, string] extends (number | string)[] ? 1 : 2; // 1 // [] 等价于 any[] type Result3 = [] extends number[] ? 1 : 2; // 1 type Result4 = [] extends unknown[] ? 1 : 2; // 1 \u0026nbsp;infer 1 2 3 4 5 6 7 8 9 10 11 12 type ArrayItemType\u0026lt;T\u0026gt; = T extends Array\u0026lt;infer ElementType\u0026gt; ? ElementType : never; // [string, number] 等效于 (string| number)[] type ArrayItemTypeResult = ArrayItemType\u0026lt;[string, number]\u0026gt;; // string | number type ReverseKeyValue\u0026lt;T extends Record\u0026lt;string, unknown\u0026gt;\u0026gt; = T extends Record\u0026lt; infer K, infer V \u0026gt; ? Record\u0026lt;V \u0026amp; string, K\u0026gt; : never; \u0026nbsp;分布式条件类型 👍 官方文档简明易懂 Distributive Conditional Types\n在某些情况下，我们也会需要包裹泛型参数来禁用掉分布式特性。\n常见包裹类型的书写方式：\n1 2 3 4 5 6 7 // 包裹泛型① 通过泛型参数被[]包裹 type Wrapped\u0026lt;T\u0026gt; = [T] extends [boolean] ? \u0026#34;Y\u0026#34; : \u0026#34;N\u0026#34;; // 包裹泛型② export type NoDistribute\u0026lt;T\u0026gt; = T \u0026amp; {}; type Wrapped\u0026lt;T\u0026gt; = NoDistribute\u0026lt;T\u0026gt; extends [boolean] ? \u0026#34;Y\u0026#34; : \u0026#34;N\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 type NeverFalseImpl\u0026lt;T\u0026gt; = T extends never ? true : false; type res1 = NeverFalseImpl\u0026lt;never\u0026gt;; // never type res2 = NeverFalseImpl\u0026lt;any\u0026gt;; // boolean //⚠️ any 作为判断参数时、作为泛型参数时都会产生这一效果: type Tmp1 = any extends string ? 1 : 2; // 1 | 2 type Tmp2\u0026lt;T\u0026gt; = T extends string ? 1 : 2; type Tmp2Res = Tmp2\u0026lt;any\u0026gt;; // 1 | 2 //而 never 仅在作为泛型参数时才会产生：(有点中断施法的感觉) type Tmp3 = never extends string ? 1 : 2; // 1 type Tmp4\u0026lt;T\u0026gt; = T extends string ? 1 : 2; type Tmp4Res = Tmp4\u0026lt;never\u0026gt;; // never ","permalink":"https://zzydev.top/posts/headfirstts/ts%E5%9F%BA%E7%A1%80%E6%8B%BE%E9%81%97/","summary":"本文只记录一些个人觉得比较容易遗忘或需要注意的点，抑或是一些跟本人接触过的其他静态语言不太一样的语法，并不是一份完整的学习教程。 \u0026nbsp;","title":"TS基础拾遗"},{"content":" \u0026nbsp;手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (proto == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } \u0026nbsp;手写 getType 1 2 3 4 5 6 7 function getType(obj) { let type = typeof obj; if (type !== \u0026#34;object\u0026#34;) return type; return Object.prototype.toString .call(obj) .replace(/^\\[object (\\S+)\\]$/, \u0026#34;S1\u0026#34;); } \u0026nbsp;手写浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 function shallowClone(target) { if (typeof target === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; target !== null) { const cloneTarget = Array.isArray() ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; } } \u0026nbsp;手写深拷贝 小杯\n1 2 3 4 5 6 7 8 9 10 11 function deepClone(obj) { let cloneObj = {}; for (let key in obj) { if (typeof key === \u0026#34;obj\u0026#34; \u0026amp;\u0026amp; key !== null) { cloneObj[key] = deepClone(obj[key]); } else { cloneObj[key] = obj[key]; } } return cloneObj; } 超大杯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const isComplexDataType = (obj) =\u0026gt; (typeof obj === \u0026#34;object\u0026#34; || typeof obj === \u0026#34;function\u0026#34;) \u0026amp;\u0026amp; obj !== null; function deepClone(obj, hash = new WeakMap()) { if (obj instanceof Date) return +new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (hash.has(obj)) return hash.get(obj); //获取对象所有属性及其对应的特征 let allDesc = Object.getOwnPropertyDescriptors(obj); //继承原对象的原型链 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc); hash.set(obj, cloneObj); for (let key of Reflect.ownKeys()) { cloneObj[key] = isComplexDataType(obj[key]) \u0026amp;\u0026amp; typeof obj[key] !== \u0026#34;function\u0026#34; ? deepClone(obj[key], hash) : obj[key]; } return cloneObj; } JS WeakMap 应该什么时候使用\n1 const newData = structuredClone(data); structuredClone MDN\n\u0026nbsp;手写深比较 1 2 3 4 5 6 7 8 9 10 11 12 13 const isObject = (obj) =\u0026gt; typeof obj === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj !== null; function isEqual(obj1, obj2) { if (isObject(obj1) ^ isObject(obj2)) return false; if (obj1 === obj2) return true; const obj1Key = Object.keys(obj1); const obj2Key = Object.keys(obj2); if (obj1Key.length !== obj2Key.length) return false; for (let key in obj) { const res = isEqual(obj1[key], obj2[key]); if (!res) return false; } return true; } \u0026nbsp;手写浅比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 检测是否为对象 const isObject = function isObject(obj) { return obj !== null \u0026amp;\u0026amp; /^(object|function)$/.test(typeof obj); }; // 对象浅比较的方法 const shallowEqual = function shallowEqual(objA, objB) { if (!isObject(objA) || !isObject(objB)) return false; if (objA === objB) return true; // 先比较成员的数量 let keysA = Reflect.ownKeys(objA), keysB = Reflect.ownKeys(objB); if (keysA.length !== keysB.length) return false; // 数量一致，再逐一比较内部的成员「只比较第一级：浅比较」 for (let i = 0; i \u0026lt; keysA.length; i++) { let key = keysA[i]; // 如果一个对象中有这个成员，一个对象中没有；或者，都有这个成员，但是成员值不一样；都应该被判定为不相同！！ if (!objB.hasOwnProperty(key) || !Object.is(objA[key], objB[key])) { return false; } } // 以上都处理完，发现没有不相同的成员，则认为两个对象是相等的 return true; }; \u0026nbsp;手写函数AOP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Function.prototype.before = function (beforeFn) { const self = this; return function beforeFunc() { const args = arguments; beforeFn.apply(this, args); return self.apply(this, args); }; }; Function.prototype.after = function (afterFn) { const self = this; return function afterFunc() { const args = arguments; const result = self.apply(this, args); afterFn.apply(this, args); return result; }; }; function func() { console.log(\u0026#34;2\u0026#34;); } const newFunc = func .before(() =\u0026gt; { console.log(\u0026#34;1\u0026#34;); }) .after(() =\u0026gt; { console.log(\u0026#34;3\u0026#34;); }); newFunc(); // 1 2 3 \u0026nbsp;手写柯里化 1 2 3 4 5 6 7 8 9 10 11 12 // 通用的柯里化 var currying = function (fn) { var args = []; return function () { if (arguments.length == 0) { return fn.apply(this, args); } else { Array.prototype.push.apply(args, arguments); return arguments.callee; } }; }; \u0026nbsp;手写 call 、apply 、bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Function.prototype.myCall = function (context, ...args) { // xxx.myCall() this就是这里的xxx myApply和myBind中的this同理 context.func = this; let res = context.func(...args); delete context.func; return res; }; Function.prototype.myBind = function () { const args = Array.from(arguments); const t = args.shift(); const self = this; return function () { return self.apply(t, args); }; }; Function.prototype.myApply = function (context, args) { context.func = this; let res = context.func(...args); delete context.func; return res; }; \u0026nbsp;手写 Object.create() 1 2 3 4 5 6 //这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型 Object.create = function (prototype) { var cls = function () {}; cls.prototype = prototype; return new cls(); }; \u0026nbsp;手写 new 1 2 3 4 5 6 7 8 9 10 11 12 function myNew(...args) { // 取出 args 数组第一个参数，即目标构造函数 const constructor = args.shift(); // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性 // 即实现 obj.__proto__ = constructor.prototype const obj = Object.create(constructor.prototype); // 执行构造函数，得到构造函数返回结果 // 注意这里我们使用 apply，将构造函数内的 this 指向为 obj const result = constructor.apply(obj, args); // 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象 return typeof result === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; result != null ? result : obj; } \u0026nbsp;手写防抖节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Throttle(事件节流)： 第一个人说了算 // fn是我们需要包装的事件回调, interval是时间间隔的阈值 function throttle(fn, interval) { // last为上一次触发回调的时间 let last = 0; // 将throttle处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 记录本次触发回调的时间 let now = new Date(); // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last \u0026gt;= interval) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.apply(context, args); } }; } // 用throttle来包装scroll的回调 const better_scroll = throttle(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); // Debounce(事件防抖)： 最后一个人说了算 // fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间 function debounce(fn, delay) { // 定时器 let timer = null; // 将debounce处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 每次事件被触发时，都去清除之前的旧定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(function () { fn.apply(context, args); }, delay); }; } // 用debounce来包装scroll的回调 const better_scroll = debounce(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); \u0026nbsp;手写原生AJAX请求 原生 ajax 步骤\n创建XMLHttpRequest对象 使用open方法设置和服务器的交互信息 使用send发送数据 注册事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const getJSON = function (url) { return new Promise((resolve, reject) =\u0026gt; { const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\u0026#34;Mscrosoft.XMLHttp\u0026#34;); xhr.open(\u0026#34;GET\u0026#34;, url, false); xhr.setRequestHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); xhr.onreadystatechange = function () { if (xhr.readyState !== 4) return; if (xhr.status === 200 || xhr.status === 304) { resolve(xhr.responseText); } else { reject(new Error(xhr.responseText)); } }; xhr.send(); }); }; \u0026nbsp;手写 String.prototype.trim 1 2 3 String.prototype.trim = function () { return this.replace(/^\\s+/, \u0026#34;\u0026#34;).replace(/\\s+$/, \u0026#34;\u0026#34;); }; \u0026nbsp;手写 Array.flat 1 2 3 4 5 6 7 const flat = (arr) =\u0026gt; { const isDeep = arr.some((item) =\u0026gt; item instanceof Array); if (!isDeep) return arr; const res = Array.prototype.concat.apply([], arr); return flat(res); }; \u0026nbsp;手写去重 1 2 3 4 const unique = (arr) =\u0026gt; { const set = new Set(arr); return [...arr]; }; \u0026nbsp;手写 setInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const mySetInterval = (fn, delay) =\u0026gt; { let timer = null, isClear = false; function loop() { if (isClear) { isClear = false; clearTimeout(timer); return; } fn(); timer = setTimeout(loop, delay); } timer = setTimeout(loop, delay); return () =\u0026gt; { isClear = true; }; }; \u0026nbsp; 手写 判断类数组 1 2 3 4 5 6 7 8 9 10 const isArrayLikeObject = (arr) =\u0026gt; { if (typeof arr !== \u0026#34;object\u0026#34; || arr === null) return false; const lengthMaxVal = Math.pow(2, 53) - 1; if (!Object.prototype.hasOwnProperty.call(arr, \u0026#34;length\u0026#34;)) return false; if (typeof arr.length !== \u0026#34;number\u0026#34;) return false; if (!isFinite(arr.length)) return false; if (Array !== arr.constructor) return false; if (arr.length \u0026gt; 0 \u0026amp;\u0026amp; arr.length \u0026lt; lengthMaxVal) return true; return false; }; \u0026nbsp;获取当前 url 中的参数的值 1 2 3 4 5 const query = (name) =\u0026gt; { const search = location.search; const params = new URLSearchParams(search); return params.get(name); }; \u0026nbsp;将 URL 参数解析为 JS 对象 1 2 3 4 5 6 7 8 9 function queryToObject() { const res = {}; const search = location.search; const pList = new URLSearchParams(search); pList.forEach((key, val) =\u0026gt; { res[key] = val; }); return res; } \u0026nbsp;手写JSON.Stringify JSON.stringify()将值转换为相应的 JSON 格式：\n转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。\n非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。\n布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。\nundefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined).\n对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。\n所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。\nDate 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。\nNaN 和 Infinity 格式的数值及 null 都会被当做 null。\n其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。\n\u0026mdash;\u0026mdash;\u0026mdash; MDN\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 function jsonStringify(data) { let type = typeof data; if (type !== \u0026#34;object\u0026#34;) { let result = data; //data 可能是基础数据类型的情况在这里处理 if (Number.isNaN(data) || data === Infinity) { //NaN 和 Infinity 序列化返回 \u0026#34;null\u0026#34; result = \u0026#34;null\u0026#34;; } else if ( type === \u0026#34;function\u0026#34; || type === \u0026#34;undefined\u0026#34; || type === \u0026#34;symbol\u0026#34; ) { // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理 return undefined; } else if (type === \u0026#34;string\u0026#34;) { result = \u0026#39;\u0026#34;\u0026#39; + data + \u0026#39;\u0026#34;\u0026#39;; } return String(result); } else if (type === \u0026#34;object\u0026#34;) { if (data === null) { return \u0026#34;null\u0026#34;; } else if (data.toJSON \u0026amp;\u0026amp; typeof data.toJSON === \u0026#34;function\u0026#34;) { return jsonStringify(data.toJSON()); } else if (data instanceof Array) { let result = []; //如果是数组，那么数组里面的每一项类型又有可能是多样的 data.forEach((item, index) =\u0026gt; { if ( typeof item === \u0026#34;undefined\u0026#34; || typeof item === \u0026#34;function\u0026#34; || typeof item === \u0026#34;symbol\u0026#34; ) { result[index] = \u0026#34;null\u0026#34;; } else { result[index] = jsonStringify(item); } }); result = \u0026#34;[\u0026#34; + result + \u0026#34;]\u0026#34;; return result.replace(/\u0026#39;/g, \u0026#39;\u0026#34;\u0026#39;); } else { // 处理普通对象 let result = []; Object.keys(data).forEach((item, index) =\u0026gt; { if (typeof item !== \u0026#34;symbol\u0026#34;) { //key 如果是 symbol 对象，忽略 if ( data[item] !== undefined \u0026amp;\u0026amp; typeof data[item] !== \u0026#34;function\u0026#34; \u0026amp;\u0026amp; typeof data[item] !== \u0026#34;symbol\u0026#34; ) { //键值如果是 undefined、function、symbol 为属性值，忽略 result.push( \u0026#39;\u0026#34;\u0026#39; + item + \u0026#39;\u0026#34;\u0026#39; + \u0026#34;:\u0026#34; + jsonStringify(data[item]) ); } } }); return (\u0026#34;{\u0026#34; + result + \u0026#34;}\u0026#34;).replace(/\u0026#39;/g, \u0026#39;\u0026#34;\u0026#39;); } } } \u0026nbsp;手写runGenerator \u0026nbsp;手写Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 const PENDING = \u0026#34;PENDING\u0026#34;; const FULFILLED = \u0026#34;FULFILLED\u0026#34;; const REJECTED = \u0026#34;REJECTED\u0026#34;; // 利用x的值来判断是调用promise2的resolve还是reject function resolvePromise(promise2, x, resolve, reject) { // 核心流程 if (promise2 === x) { return reject(new TypeError(\u0026#34;错误\u0026#34;)); } // 我可能写的promise 要和别人的promise兼容，考虑不是自己写的promise情况 if ((typeof x === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; x !== null) || typeof x === \u0026#34;function\u0026#34;) { // 有可能是promise // 别人的promise可能调用成功后 还能调用失败~~~ 确保了别人promise符合规范 let called = false; try { // 有可能then方法是通过defineProperty来实现的 取值时可能会发生异常 let then = x.then; if (typeof then === \u0026#34;function\u0026#34;) { // 这里我就认为你是promise了 x.then 这样写会触发getter可能会发生异常 then.call( x, (y) =\u0026gt; { if (called) return; called = true; resolvePromise(promise2, y, resolve, reject); // 直到解析他不是promise位置 }, (r) =\u0026gt; { // reason if (called) return; called = true; reject(r); } ); } else { // {} {then:{}} resolve(x); // 常量 } } catch (e) { if (called) return; called = true; reject(e); } } else { resolve(x); // 说明返回的是一个普通值 直接将他放到promise2.resolve中 } } class Promise { constructor(executor) { this.status = PENDING; // promise默认的状态 this.value = undefined; // 成功的原因 this.reason = undefined; // 失败的原因 this.onResolvedCallbacks = []; // 存放成功的回调方法 this.onRejectedCallbacks = []; // 存放失败的回调方法 const resolve = (value) =\u0026gt; { // 成功resolve函数 if (value instanceof Promise) { return value.then(resolve, reject); } if (this.status === PENDING) { this.value = value; this.status = FULFILLED; // 修改状态 // 发布 this.onResolvedCallbacks.forEach((fn) =\u0026gt; fn()); } }; const reject = (reason) =\u0026gt; { // 失败的reject函数 if (this.status === PENDING) { this.reason = reason; this.status = REJECTED; // 修改状态 this.onRejectedCallbacks.forEach((fn) =\u0026gt; fn()); } }; try { executor(resolve, reject); } catch (e) { reject(e); } } // then中的参数是可选的 then(onFulfilled, onRejected) { // onFulfilled, onRejected onFulfilled = typeof onFulfilled === \u0026#34;function\u0026#34; ? onFulfilled : (v) =\u0026gt; v; onRejected = typeof onRejected === \u0026#34;function\u0026#34; ? onRejected : (err) =\u0026gt; { throw err; }; // 用于实现链式调用 let promise2 = new Promise((resolve, reject) =\u0026gt; { // 订阅模式 if (this.status == FULFILLED) { // 成功调用成功方法 setTimeout(() =\u0026gt; { try { let x = onFulfilled(this.value); // 此x 可能是一个promise， 如果是promise需要看一下这个promise是成功还是失败 .then ,如果成功则把成功的结果 调用promise2的resolve传递进去，如果失败则同理 // 总结 x的值 决定是调用promise2的 resolve还是reject，如果是promise则取他的状态，如果是普通值则直接调用resolve resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (this.status === REJECTED) { // 失败调用失败方法 setTimeout(() =\u0026gt; { try { let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (this.status == PENDING) { // 代码是异步调用resolve或者reject的 this.onResolvedCallbacks.push(() =\u0026gt; { // 切片编程 AOP setTimeout(() =\u0026gt; { try { // todo... let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); this.onRejectedCallbacks.push(() =\u0026gt; { setTimeout(() =\u0026gt; { try { // todo... let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); } }); return promise2; } static resolve(value) { return new Promise((resolve, reject) =\u0026gt; { resolve(value); }); } static reject(value) { return new Promise((resolve, reject) =\u0026gt; { reject(value); }); } catch(errorFn) { return this.then(null, errorFn); } } // npm install promises-aplus-tests -g // 延迟对象 帮我们减少一次套用 ： 针对目前来说 应用不是很广泛 Promise.deferred = function () { let dfd = {}; dfd.promise = new Promise((resolve, reject) =\u0026gt; { dfd.resolve = resolve; dfd.reject = reject; }); return dfd; }; module.exports = Promise; \u0026nbsp;手写Promise.race 1 2 3 4 5 6 7 8 9 10 11 Promise.race = function (arr) { return new Promise(function (resolve, reject) { if (!Array.isArray(arr)) { return reject(new TypeError(\u0026#34;Promise.race accepts an array\u0026#34;)); } for (var i = 0, len = arr.length; i \u0026lt; len; i++) { Promise.resolve(arr[i]).then(resolve, reject); } }); }; \u0026nbsp;手写Promise.all 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static all = function (promises) { return new Promise((resolve, reject) =\u0026gt; { let result = []; let times = 0; const processSuccess = (index, val) =\u0026gt; { result[index] = val; if (++times === promises.length) { resolve(result); } }; for (let i = 0; i \u0026lt; promises.length; i++) { // 并发 多个请求一起执行的 let p = promises[i]; if (p \u0026amp;\u0026amp; typeof p.then === \u0026#34;function\u0026#34;) { p.then((data) =\u0026gt; { processSuccess(i, data); }, reject); // 如果其中某一个promise失败了 直接执行失败即可 } else { processSuccess(i, p); } } }); }; \u0026nbsp;实现lodash.get 实现类似 lodash.get ，有以下测试用例:\n1 2 3 4 5 6 7 8 9 10 var object = { a: [{ b: { c: 3 } }] }; get(object, \u0026#34;a[0].b.c\u0026#34;); // =\u0026gt; 3 get(object, [\u0026#34;a\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]); // =\u0026gt; 3 get(object, \u0026#34;a.b.c\u0026#34;, \u0026#34;default\u0026#34;); // =\u0026gt; \u0026#39;default\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * object: 对象 * path: 输入的路径 * defaultVal: 默认值 **/ function get(object, path, defaultVal = \u0026#34;undefined\u0026#34;) { // 先将path处理成统一格式 let newPath = []; if (Array.isArray(path)) { newPath = path; } else { // 先将字符串中的\u0026#39;[\u0026#39;、\u0026#39;]\u0026#39;去除替换为\u0026#39;.\u0026#39;，split分割成数组形式 newPath = path.replace(/\\[/g, \u0026#34;.\u0026#34;).replace(/\\]/g, \u0026#34;\u0026#34;).split(\u0026#34;.\u0026#34;); } // 递归处理，返回最后结果 return ( newPath.reduce((o, k) =\u0026gt; { // console.log(o, k); // 此处o初始值为下边传入的 object，后续值为每次取的内部值 return (o || {})[k]; }, object) || defaultVal ); } \u0026nbsp;手写JS继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //原型链继承 //缺点：Parent1和Child1创建的两个实例使用的是同一个原型对象，它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化 function Parent1() { this.name = \u0026#34;parent1\u0026#34;; this.play = [1, 2, 3]; } function Child1() { this.type = \u0026#34;child2\u0026#34;; } Child1.prototype = new Parent1(); //构造函数继承（借助 call） //缺点：父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法 function Parent2() { this.name = \u0026#34;parent1\u0026#34;; } Parent2.prototype.getName = function () { return this.name; }; function Child2() { Parent2.call(this); this.type = \u0026#34;child1\u0026#34;; } let child = new Child2(); console.log(child); // 没问题 console.log(child.getName()); // 会报错 //组合继承（前两种组合） //缺点：Parent3 执行了两次 function Parent3() { this.name = \u0026#34;parent3\u0026#34;; this.play = [1, 2, 3]; } Parent3.prototype.getName = function () { return this.name; }; function Child3() { // ② 第二次调用 Parent3() Parent3.call(this); this.type = \u0026#34;child3\u0026#34;; } // ① 第一次调用 Parent3() Child3.prototype = new Parent3(); // 手动挂上构造器，指向自己的构造函数 Child3.prototype.constructor = Child3; var s3 = new Child3(); var s4 = new Child3(); s3.play.push(4); console.log(s3.play, s4.play); // 不互相影响 console.log(s3.getName()); // 正常输出\u0026#39;parent3\u0026#39; console.log(s4.getName()); // 正常输出\u0026#39;parent3\u0026#39; //原型式继承 //缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能 let parent4 = { name: \u0026#34;parent4\u0026#34;, friends: [\u0026#34;p1\u0026#34;, \u0026#34;p2\u0026#34;, \u0026#34;p3\u0026#34;], getName: function () { return this.name; }, }; let person4 = Object.create(parent4); person4.name = \u0026#34;tom\u0026#34;; person4.friends.push(\u0026#34;jerry\u0026#34;); //通过 Object.create()这个方法可以实现普通对象的继承 //不仅仅能继承属性，同样也可以继承 getName 的方法 let person5 = Object.create(parent4); person5.friends.push(\u0026#34;lucy\u0026#34;); console.log(person4.name); //tom console.log(person4.name === person4.getName()); //true console.log(person5.name); //parent4 console.log(person4.friends); //[\u0026#34;p1\u0026#34;, \u0026#34;p2\u0026#34;, \u0026#34;p3\u0026#34;, \u0026#34;jerry\u0026#34;, \u0026#34;lucy\u0026#34;] console.log(person5.friends); //[\u0026#34;p1\u0026#34;, \u0026#34;p2\u0026#34;, \u0026#34;p3\u0026#34;, \u0026#34;jerry\u0026#34;, \u0026#34;lucy\u0026#34;] //寄生式继承 //优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。 let parent5 = { name: \u0026#34;parent5\u0026#34;, friends: [\u0026#34;p1\u0026#34;, \u0026#34;p2\u0026#34;, \u0026#34;p3\u0026#34;], getName: function () { return this.name; }, }; function clone(original) { let clone = Object.create(original); clone.getFriends = function () { return this.friends; }; return clone; } let person5 = clone(parent5); console.log(person5.getName()); console.log(person5.getFriends()); //寄生组合式继承 //extends原理 function clone(parent, child) { // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程 child.prototype = Object.create(parent.prototype); child.prototype.constructor = child; } function Parent6() { this.name = \u0026#34;parent6\u0026#34;; this.play = [1, 2, 3]; } Parent6.prototype.getName = function () { return this.name; }; function Child6() { Parent6.call(this); this.friends = \u0026#34;child5\u0026#34;; } clone(Parent6, Child6); Child6.prototype.getFriends = function () { return this.friends; }; let person6 = new Child6(); console.log(person6); console.log(person6.getName()); console.log(person6.getFriends()); ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C/","summary":"\u0026nbsp;手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (proto == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } \u0026nbsp;手写 getType 1 2 3 4","title":"有手就行"},{"content":" \u0026nbsp;Pick 💯Take a Challenge\n实现 TS 内置的 Pick\u0026lt;T, K\u0026gt;，但不可以使用它。\n从类型 T 中选择出属性 K，构造成一个新的类型。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = MyPick\u0026lt;Todo, \u0026#34;title\u0026#34; | \u0026#34;completed\u0026#34;\u0026gt;; const todo: TodoPreview = { title: \u0026#34;Clean room\u0026#34;, completed: false, }; 答案：\n1 2 3 type MyPick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; \u0026nbsp;实现 Readonly 💯Take a Challenge\n不要使用内置的Readonly\u0026lt;T\u0026gt;，自己实现一个。\n该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。\n也就是不可以再对该对象的属性赋值。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 interface Todo { title: string; description: string; } const todo: MyReadonly\u0026lt;Todo\u0026gt; = { title: \u0026#34;Hey\u0026#34;, description: \u0026#34;foobar\u0026#34;, }; todo.title = \u0026#34;Hello\u0026#34;; // Error: cannot reassign a readonly property todo.description = \u0026#34;barFoo\u0026#34;; // Error: cannot reassign a readonly property 答案：\n1 2 3 type MyReadonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P]; }; \u0026nbsp;Tuple To Object 💯Take a Challenge\n传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键/值都是从元组中遍历出来。\n例如：\n1 2 const tuple = [\u0026#34;tesla\u0026#34;, \u0026#34;model 3\u0026#34;, \u0026#34;model X\u0026#34;, \u0026#34;model Y\u0026#34;] as const; type result = TupleToObject\u0026lt;typeof tuple\u0026gt;; // expected { tesla: \u0026#39;tesla\u0026#39;, \u0026#39;model 3\u0026#39;: \u0026#39;model 3\u0026#39;, \u0026#39;model X\u0026#39;: \u0026#39;model X\u0026#39;, \u0026#39;model Y\u0026#39;: \u0026#39;model Y\u0026#39;} 答案： 索引类型\n1 2 3 4 type TupleToObject\u0026lt;T extends readonly any[]\u0026gt; = { [P in T[number]]: P; }; // T[number]索引类型访问，得到联合类型：\u0026#34;tesla\u0026#34; | \u0026#34;model 3\u0026#34; | \u0026#34;model X\u0026#34; | \u0026#34;model Y\u0026#34; \u0026nbsp;First of Array 💯Take a Challenge\n实现一个通用First\u0026lt;T\u0026gt;，它接受一个数组T并返回它的第一个元素的类型。\n例如：\n1 2 3 4 5 type arr1 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; type arr2 = [3, 2, 1]; type head1 = First\u0026lt;arr1\u0026gt;; // expected to be \u0026#39;a\u0026#39; type head2 = First\u0026lt;arr2\u0026gt;; // expected to be 3 答案： 简单模式匹配\n1 2 3 type MyFirst\u0026lt;T extends unknown[]\u0026gt; = T extends [infer R, ...unknown[]] ? R : never; \u0026nbsp;Length of Tuple 💯Take a Challenge\n创建一个通用的 Length，接受一个 readonly 的数组，返回这个数组的长度。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 type tesla = [\u0026#34;tesla\u0026#34;, \u0026#34;model 3\u0026#34;, \u0026#34;model X\u0026#34;, \u0026#34;model Y\u0026#34;]; type spaceX = [ \u0026#34;FALCON 9\u0026#34;, \u0026#34;FALCON HEAVY\u0026#34;, \u0026#34;DRAGON\u0026#34;, \u0026#34;STARSHIP\u0026#34;, \u0026#34;HUMAN SPACEFLIGHT\u0026#34; ]; type teslaLength = Length\u0026lt;tesla\u0026gt;; // expected 4 type spaceXLength = Length\u0026lt;spaceX\u0026gt;; // expected 5 答案：\n1 2 3 type MyLength\u0026lt;T extends any\u0026gt; = T extends { length: number } ? T[\u0026#34;length\u0026#34;] : never; \u0026nbsp;Exclude 💯Take a Challenge\n实现内置的 Exclude \u0026lt;T, U\u0026gt;类型，但不能直接使用它本身。\n从联合类型 T 中排除 U 的类型成员，来构造一个新的类型。\n答案： 分布式条件类型\n1 type MyExclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; \u0026nbsp;Awaited 💯Take a Challenge\n假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。\n比如：Promise\u0026lt;ExampleType\u0026gt;，请你返回 ExampleType 类型。\n这个挑战来自于 @maciejsikora 的文章：original article\n答案:\n1 2 3 4 5 type MyAwaited\u0026lt;P extends Promise\u0026lt;unknown\u0026gt;\u0026gt; = P extends Promise\u0026lt;infer ValueType\u0026gt; ? ValueType extends Promise\u0026lt;unknown\u0026gt; ? MyAwaited\u0026lt;ValueType\u0026gt; : ValueType : never; \u0026nbsp;If 💯Take a Challenge\n实现一个 IF 类型，它接收一个条件类型 C ，一个判断为真时的返回类型 T ，以及一个判断为假时的返回类型 F。 C 只能是 true 或者 false， T 和 F 可以是任意类型。\n举例:\n1 2 type A = If\u0026lt;true, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;\u0026gt;; // expected to be \u0026#39;a\u0026#39; type B = If\u0026lt;false, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;\u0026gt;; // expected to be \u0026#39;b\u0026#39; 答案:\n1 type If\u0026lt;C extends boolean, T, F\u0026gt; = C extends true ? T : F; \u0026nbsp;Concat 💯Take a Challenge\n在类型系统里实现 JavaScript 内置的 Array.concat 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。\n举例，\n1 type Result = Concat\u0026lt;[1], [2]\u0026gt;; // expected to be [1, 2] 答案:\n1 type Concat\u0026lt;T extends any[], U extends any[]\u0026gt; = [...T, ...U]; \u0026nbsp;Includes 💯Take a Challenge\n在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。\n举例来说，\n1 type isPillarMen = Includes\u0026lt;[\u0026#34;Kars\u0026#34;, \u0026#34;Esidisi\u0026#34;, \u0026#34;Wamuu\u0026#34;, \u0026#34;Santana\u0026#34;], \u0026#34;Dio\u0026#34;\u0026gt;; // expected to be `false` 答案:\n1 2 3 4 5 6 7 8 9 10 type IsEqual\u0026lt;A, B\u0026gt; = (A extends B ? true : false) \u0026amp; (B extends A ? true : false); type Includes\u0026lt;Arr extends unknown[], FindItem\u0026gt; = Arr extends [ infer First, ...infer Rest ] ? IsEqual\u0026lt;First, FindItem\u0026gt; extends true ? true : Includes\u0026lt;Rest, FindItem\u0026gt; : false; \u0026nbsp;Push 💯Take a Challenge\n在类型系统里实现通用的 Array.push 。\n举例如下，\n1 type Result = Push\u0026lt;[1, 2], \u0026#34;3\u0026#34;\u0026gt;; // [1, 2, \u0026#39;3\u0026#39;] 答案:\n1 type Push\u0026lt;Arr extends unknown[], Elem\u0026gt; = [...Arr, Elem]; \u0026nbsp;Unshift 💯Take a Challenge\n实现类型版本的 Array.unshift。\n举例，\n1 type Result = Unshift\u0026lt;[1, 2], 0\u0026gt;; // [0, 1, 2,] 答案:\n1 type Unshift\u0026lt;Arr extends unknown[], Elem\u0026gt; = [Elem, ...Arr]; \u0026nbsp;Parameters 💯Take a Challenge\n实现内置的 Parameters 类型，而不是直接使用它，可参考TypeScript 官方文档。\n答案:\n1 2 3 4 5 type MyParameters\u0026lt;Func extends Function\u0026gt; = Func extends ( ...args: infer Args ) =\u0026gt; unknown ? Args : never; ","permalink":"https://zzydev.top/posts/headfirstts/ts%E7%B1%BB%E5%9E%8B%E6%8C%91%E6%88%98easy%E7%AF%87/","summary":"\u0026nbsp;Pick 💯Take a Challenge 实现 TS 内置的 Pick\u0026lt;T, K\u0026gt;，但不可以使用它。 从类型 T 中选择出属性 K，构造成一个新的类型。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 interface Todo { title:","title":"TS类型挑战Easy篇"},{"content":" 我是没事的时候\n在无聊的时候，想的时候\n到一个地方，不相同的地方\n到这个地方来，来到吧\n可以瞧瞧，不一样的地方\n不相同的地方\n很多，很多……\n\u0026mdash;\u0026mdash;\u0026mdash; 淳·简·拉基茨德\n\u0026nbsp;Symbol不能使用new操作符，那如何得到一个Symbol类型的对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //利用一个函数的call方法来强迫产生装箱 var symbolObject = function () { return this; }.call(Symbol(\u0026#34;a\u0026#34;)); console.log(typeof symbolObject); //object console.log(symbolObject instanceof Symbol); //true console.log(symbolObject.constructor == Symbol); //true //使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力 var symbolObject = Object(Symbol(\u0026#34;a\u0026#34;)); console.log(typeof symbolObject); //object console.log(symbolObject instanceof Symbol); //true console.log(symbolObject.constructor == Symbol); //true //每一类装箱对象皆有私有的Class属性，这些属性可以用 Object.prototype.toString 获取： console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol] //在JS中，没有任何方法可以更改私有的Class属性 \u0026nbsp;new fn与new fn()有什么区别吗？ 1 2 3 4 5 6 7 8 9 10 11 function Parent() { this.num = 1; } console.log(new Parent()); //输出Parent对象：{num:1} console.log(new Parent()); //输出Parent对象：{num:1} function Parent() { this.num = 1; } console.log(new Parent().num); //1 console.log(new Parent.num()); //报错 从报错信息来看，new Parent.num执行顺序是这样的：先执行Parent.num，此时返回结果为undefined；后执行new，因new后面必须跟构造函数，所以new undefined会报错。\nnew Parent().num相当于(new Parent()).num，所以结果返回 1。\n\u0026nbsp;拆箱转换相关问题 对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的原始类型。\nSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var o = { valueOf: () =\u0026gt; { console.log(\u0026#34;valueOf\u0026#34;); return {}; }, toString: () =\u0026gt; { console.log(\u0026#34;toString\u0026#34;); return {}; }, }; o[Symbol.toPrimitive] = () =\u0026gt; { return \u0026#34;hello\u0026#34;; }; console.log(o + \u0026#34;\u0026#34;); // hello // 练习一 const arr = [4, 10]; arr[Symbol.toPrimitive] = function (hint) { return hint; }; arr.valueOf = function () { return this; }; const obj = {} + arr + obj + arr + obj; //\u0026#39;NaN[object Object]default[object Object]\u0026#39; { } +arr; //[object Object]default\u0026#39; // 练习二 const val = (([] == ![][(+val, [] + 1)]) == // \u0026#39;\u0026#39;转数字为0 [1, 1] + [][(+val, [] + 1)]) == //[1, \u0026#39;1\u0026#39;].toString() == [1, 1] + \u0026#39;\u0026#39; =\u0026gt; \u0026#39;1, 1\u0026#39; == \u0026#39;1, 1\u0026#39; true [1, \u0026#34;1\u0026#34;]; // false \u0026nbsp;[]➕[]，[]➕{}，{}➕[]，{}➕{} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 二元操作符 + 的规则 // 如果操作数是对象，则对象会转换为原始值 // 如果其中一个操作数是字符串，另一个操作数也会转换为字符串进行拼接 // 否则两个操作数都将转换为数字或者NaN，进行加法操作 10n + 10 Symbol(10) + 10 // 对象转换为原始数据类型的值 // Symbol.toPrimitive 优先级最高 // Object.prototype.valueOf // 调用 valueOf，如果转换为原始类型，就返回转换的值。如果不返回原始类型的值就调用toString。 // Object.prototype.toString // 调用toString，如果转换为原始类型，就返回转换的值。如果不返回原始类型的值就调用valueOf。 typeof [][Symbol.toPrimitive] // undefined [].valueOf() // [] [].toString() // \u0026#39;\u0026#39; 所以[]转换为原始值是‘’ typeof {}[Symbol.toPrimitive] //undefined ({}).valueOf() // {} ({}).toString() // \u0026#39;[object Object]\u0026#39; [] + [] // \u0026#34;\u0026#34; [] + {} // \u0026#34;[object Object]\u0026#34; {} + [] // 0 相当于 {}; + [] {} + {} // Chrome \u0026#39;[object Object][object Object]\u0026#39; 其他浏览器 NaN \u0026nbsp;toString相关问题 1 2 3 4 5 6 7 8 9 10 11 const user = { name: \u0026#34;zzy\u0026#34;, id: 233, valueOf() { return this.id; }, }; console.log(`${user}`); //会调用原型链上的toString 返回[object Object] Object.prototype.toString = undefined; console.log(`${user}`); // 233 1 Object.prototype.toString.call(Boolean.prototype); // [object Boolean] \u0026nbsp;px % rem vh/vw有什么区别 px 是绝对单位，\n% 是相对于父元素的比例，\nem 是相对于当前元素的 font-size，rem 是相对与根(root)元素的 font-size，\n1 2 3 4 5 6 7 \u0026lt;div style=\u0026#34;font-size:20px\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;text-indent: 2em; font-size: 40px\u0026#34;\u0026gt;首行缩进\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;text-indent: 2em\u0026#34;\u0026gt; 这个元素的font-size继承了父元素的font-size，所以缩进比上面的小一些 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-size: 2rem\u0026#34;\u0026gt;相对根元素font-size\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; vh/vw 是屏幕的百分比\nvmin 是 min(屏幕宽度,屏幕高度)、vmax 是 max(屏幕宽度,屏幕高度)\n\u0026nbsp;for in 和 for of的区别 遍历对象：for\u0026hellip;in 可以, for\u0026hellip;of 不可以\n遍历 Map、Set：for\u0026hellip;of 可以, for\u0026hellip;in 不可以\n遍历 generator：for\u0026hellip;of 可以, for\u0026hellip;in 不可以\n1 2 3 4 5 6 7 8 function* gen() { yield 1; yield 2; yield 3; } for (let i of gen()) { console.log(i); } for\u0026hellip;in 用于可枚举数据，如对象、数组、字符串\n1 2 3 4 5 6 Object.defineProperty(obj, \u0026#34;key\u0026#34;, { enumerable: true, // 可枚举 configurable: false, writable: false, value: \u0026#34;static\u0026#34;, }); for\u0026hellip;of 用于可迭代数据，如数组、字符串、Set、Map\n存在 Symbol.iterator 属性的对象，可以用 for\u0026hellip;of 迭代\nfor await of 有什么作用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function createPromise(val) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(val); }, 1000); }); } (async function () { const p1 = createPromise(100); const p2 = createPromise(200); const res1 = await p1; console.log(res1); const res2 = await p2; console.log(res2); //直接三个一起打印出来 const list = [p1, p2]; Promise.all(list).then((res) =\u0026gt; console.log(res)); // Promise.all的代替品 //直接三个一起打印出来 for await (let res of list) { console.log(res); } //每隔一秒打印一个 const arr = [100, 200]; for (let num of arr) { const res = await createPromise(num); console.log(res); } })(); \u0026nbsp;offsetHeight、scrollHeight和clientHeight的区别 scrollHeight\nscrollTop\nscrollLeft\n\u0026nbsp;HTMLCollection和NodeList的区别 Node 是 Element 的基类\nElement 是其他 HTML 元素的基类，如 HTMLDivElement HTMLCollection 是 Element 的集合\nNodeList 是 Node 的集合\nHTMLCollection 和 NodeList 都是类数组\n1 2 3 4 \u0026lt;p id=\u0026#34;p1\u0026#34;\u0026gt; \u0026lt;b\u0026gt;node\u0026lt;/b\u0026gt; vs \u0026lt;em\u0026gt;element\u0026lt;/em \u0026gt;\u0026lt;!--注释--\u0026gt; \u0026lt;/p\u0026gt; 1 2 3 4 5 6 const p1 = document.getElementById(\u0026#34;p1\u0026#34;); console.log(p1.children); // 不包含Text和Comment 是HTMLCollection类型 console.log(p1.childNode); // 包含Text和Comment 是NodeList类型 p1.tagName; // Element类型属性 p1.nodeName; // Node类型属性 \u0026nbsp;Node和浏览器的EventLoop有什么区别 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则:\n浏览器中的 EventLoop 函数会在执行栈中执行，当遇到异步代码的时候，会被挂起在 Task 队列中，一旦执行栈为空，就会从 Task 队列中拿出需要执行的代码执行，所以本质上讲 JS 中的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。\n宏任务(script、setTimeout、setInterval、setImmidiate、I/O、UI Rendering) 微任务(procress.nextTick、Promise.then、Object.observe、mutataionObserver) Event Loop 执行顺序如下所示：\n首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 1 2 3 4 5 6 7 8 9 10 11 12 13 const $p1 = $(\u0026#34;\u0026lt;p\u0026gt;一段文字\u0026lt;/p\u0026gt;\u0026#34;); const $p2 = $(\u0026#34;\u0026lt;p\u0026gt;一段文字\u0026lt;/p\u0026gt;\u0026#34;); const $p3 = $(\u0026#34;\u0026lt;p\u0026gt;一段文字\u0026lt;/p\u0026gt;\u0026#34;); $(\u0026#34;#container\u0026#34;).append($p1).append($p2).append($p3); //微任务: DOM渲染前触发 Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;length1\u0026#34;, $(\u0026#34;#container\u0026#34;).children.length); // 3 alert(\u0026#34;Promise then\u0026#34;); // 出现alert弹窗，DOM此时未渲染 }); //宏任务：DOM渲染后触发 setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout\u0026#34;); }); \u0026nbsp;回顾Promise知识点 手写 Promise\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //Promise 有三种状态：pending、resolved、rejected //pending 状态的Promise，不会触发 then 或 catch //resolved 状态的 Promise， 会触发 then 回调函数 //rejected 状态的 Promise， 会触发 catch 回调函数 const p1 = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(); }); }); console.log(\u0026#34;p1\u0026#34;, p1); // Promise {\u0026lt;pending\u0026gt;} setTimeout(() =\u0026gt; console.log(\u0026#34;p1-setTimeout\u0026#34;, p1)); // Promise { \u0026lt;resolved\u0026gt; } // ------------------------------------------------------------------------- // then 正常返回 resolved 状态的 Promise，里面有报错则返回 rejected 状态的 Promise // catch 正常返回 resolved 状态的 Promise，里面有报错则返回 rejected 状态的 Promise const p1 = Promise.reject(\u0026#34;my error\u0026#34;).catch((err) =\u0026gt; console.log(err)); console.log(\u0026#34;p1\u0026#34;, p1); // ⚠️ Promise { \u0026lt;resolved\u0026gt; } const p2 = Promise.reject(\u0026#34;my error\u0026#34;).then( (err) =\u0026gt; throw new Error(\u0026#34;catch error\u0026#34;) ); console.log(\u0026#34;p2\u0026#34;, p2); // ⚠️ Promise { \u0026lt;rejected\u0026gt; } Promise.resolve() .then(() =\u0026gt; console.log(1)) .catch(() =\u0026gt; { return new Error(\u0026#34;err\u0026#34;); }) .then(() =\u0026gt; console.log(3)) .catch((err) =\u0026gt; console.log(err)); // ⚠️ 1 3 // ------------------------------------------------------------------------- // async 函数返回的是 Promise 对象 // await 相当于 Promise 的 then // try/catch 可捕获异常，相当于 Promise 的 catch async function fn1() { // return 100; 相当于 return Promise.resolve(100) return Promise.resolve(100); } const res1 = fn1(); // res1: Promise { \u0026lt;resolved\u0026gt; } !(async function () { const p1 = Promise.resolve(100); const data = await p1; // await 相当于 Promise 的 then console.log(data); })(); !(async function () { const data = await 100; // 相当于 await Promise.resolve(100); console.log(data); })(); !(async function () { const p1 = Promise.reject(new Error(\u0026#34;my error\u0026#34;)); try { const data = await p1; console.log(data); } catch (err) { console.error(err); // try catch 相当于 Promise 的 catch } })(); // ------------------------------------------------------------------------- async function async1() { console.log(\u0026#34;async1 start\u0026#34;); // 2 await async2(); //先执行 async2,再执行 await 的操作 // await 后面的内容，都可以看成 callback 的内容，微任务 console.log(\u0026#34;async1 end\u0026#34;); // 6 } async function async2() { console.log(\u0026#34;async2 start\u0026#34;); // 3 } console.log(\u0026#34;script start\u0026#34;); // 1 setTimeout(() =\u0026gt; { // 宏任务 console.log(\u0026#34;setTimeout\u0026#34;); // 8 }); async1(); //初始化Promise时，传入的函数会立刻被执行 new Promise(function (resolve) { console.log(\u0026#34;Promise1\u0026#34;); // 4 resolve(); }).then(() =\u0026gt; { // 微任务 console.log(\u0026#34;Promise2\u0026#34;); // 7 }); console.log(\u0026#34;script end\u0026#34;); // 5 //同步代码执行完毕 (call stack被清空) //执行微任务 //尝试进行DOM渲染 //触发EventLoop 执行宏任务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!--伪代码--\u0026gt;\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // const fn1 = () =\u0026gt; { // log(\u0026#34;listener1\u0026#34;) // Promise.resolve().then(()=\u0026gt;log(\u0026#39;micro task 1\u0026#39;)); // } button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { log(\u0026#34;listener1\u0026#34;); Promise.resolve().then(() =\u0026gt; log(\u0026#34;micro task 1\u0026#34;)); }); // const fn2 = () =\u0026gt; {...} button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { log(\u0026#34;listener2\u0026#34;); Promise.resolve().then(() =\u0026gt; log(\u0026#34;micro task 2\u0026#34;)); }); //情况一： button.click() // 相当于 同时执行fn1() fn2() 执行结果: l1 l2 t1 t2 //情况二: 在html页面点击button触发两次click事件(两个宏任务) 执行结果: l1 t1 l2 t2 \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;Promise1\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout2\u0026#34;); }, 0); }); setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout1\u0026#34;); Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;Promise2\u0026#34;); }); }, 0); // p1 s1 p2 s2 \u0026nbsp;浏览器缓存:强缓存和协商缓存 强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。\n\u0026nbsp;同源策略与跨域 一.浏览器请求跨域解决方案 CORS 代理转发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // webpack-dev-server 配置代理 //当浏览器发起前缀为 /api 的请求时都会被转发到 http://localhost:3000 这个网址，然后将响应结果返回给浏览器 module.exports = { //... devServer: { proxy: { \u0026#34;/api\u0026#34;: \u0026#34;http://localhost:3000\u0026#34;, }, }, }; //在 Nginx 服务器上配置转发规则 //通过 location 指令匹配路径，然后通过 proxy_pass 指令指向代理地址 location /api { proxy_pass http://localhost:3000; } Websocket 1 2 3 4 5 6 7 8 9 //在a网站直接创建一个WebSocket连接，连接到b网站 //然后调用WebScoket实例ws的send()函数向服务端发送消息，监听实例ws的onmessage事件得到响应内容。 var ws = new WebSocket(\u0026#34;ws://b.com\u0026#34;); ws.onopen = function () { // ws.send(...); }; ws.onmessage = function (e) { // console.log(e.data); }; 二. 页面跨域解决方案 例如使用 iframe 时父子页面之间进行通信\nHTML5 的 postMessage() 可用来实现父子页面之间通信，且不论这两个页面是否同源。\n举个 🌰 子： 当父页面 https://zzydev.top 要向子页面 https://children.zzydev.top 发消息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ===================== 父页面 https://zzydev.top ====================================== //通过 window.open() 函数打开了子页面， //然后调用 child.postMessage() 函数发送了字符串数据给子页面。 var child = window.open(\u0026#34;https://children.zzydev.top\u0026#34;); child.postMessage(\u0026#34;hello kids~\u0026#34;, \u0026#34;https://children.zzydev.top\u0026#34;); // =====================子页面 https://children.zzydev.top ====================================== // 在子页面中，只需要监听“message”事件即可得到父页面的数据 window.addEventListener( \u0026#34;message\u0026#34;, function (e) { console.log(e.data); }, false ); //父页面也可以监听“message”事件来接收子页面发送的数据。 //子页面发送数据时则要通过 window.opener 对象来调用 postMessage() 函数。 window.opener.postMessage(\u0026#34;hello dad\u0026#34;, \u0026#34;https://zzydev.top\u0026#34;); ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%88%91%E7%9A%84%E6%8B%B7%E9%9D%A2%E7%BB%8F_1/","summary":"我是没事的时候 在无聊的时候，想的时候 到一个地方，不相同的地方 到这个地方来，来到吧 可以瞧瞧，不一样的地方 不相同的地方 很多，很多…… \u0026mdash;\u0026mdash;\u0026mdash; 淳·简·拉","title":"我的拷面经（一）"},{"content":" \u0026nbsp;获取函数返回类型 💯Take a Challenge\n不使用 ReturnType 实现 TypeScript 的 ReturnType\u0026lt;T\u0026gt; 泛型。\n例如：\n1 2 3 4 5 6 const fn = (v: boolean) =\u0026gt; { if (v) return 1; else return 2; }; type a = MyReturnType\u0026lt;typeof fn\u0026gt;; // 应推导出 \u0026#34;1 | 2\u0026#34; 答案:\n1 type ReturnType\u0026lt;T\u0026gt; = T extends (...args: any) =\u0026gt; infer R ? R : never; \u0026nbsp;实现 Omit 💯Take a Challenge\n不使用 Omit 实现 TypeScript 的 Omit\u0026lt;T, K\u0026gt; 泛型。\nOmit 会创建一个省略 K 中字段的 T 对象。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = MyOmit\u0026lt;Todo, \u0026#34;description\u0026#34; | \u0026#34;title\u0026#34;\u0026gt;; const todo: TodoPreview = { completed: false, }; 答案:\n1 type MyOmit\u0026lt;T, K\u0026gt; = MyPick\u0026lt;T, MyExclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; \u0026nbsp;Readonly 2 💯Take a Challenge\nImplement a generic MyReadonly2\u0026lt;T, K\u0026gt; which takes two type argument T and K.\nK specify the set of properties of T that should set to Readonly. When K is not provided, it should make all properties readonly just like the normal Readonly\u0026lt;T\u0026gt;.\nFor example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface Todo { title: string; description: string; completed: boolean; } const todo: MyReadonly2\u0026lt;Todo, \u0026#34;title\u0026#34; | \u0026#34;description\u0026#34;\u0026gt; = { title: \u0026#34;Hey\u0026#34;, description: \u0026#34;foobar\u0026#34;, completed: false, }; todo.title = \u0026#34;Hello\u0026#34;; // Error: cannot reassign a readonly property todo.description = \u0026#34;barFoo\u0026#34;; // Error: cannot reassign a readonly property todo.completed = true; // OK 答案:\n1 2 3 type MyReadonly2\u0026lt;T, K extends keyof T = keyof T\u0026gt; = Omit\u0026lt;T, K\u0026gt; \u0026amp; { readonly [P in K]: T[P]; }; \u0026nbsp;深度 Readonly 💯Take a Challenge\nImplement a generic DeepReadonly\u0026lt;T\u0026gt; which make every parameter of an object - and its sub-objects recursively - readonly.\nYou can assume that we are only dealing with Objects in this challenge. Arrays, Functions, Classes and so on are no need to take into consideration. However, you can still challenge your self by covering different cases as many as possible.\nFor example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type X = { x: { a: 1; b: \u0026#34;hi\u0026#34;; }; y: \u0026#34;hey\u0026#34;; }; type Expected = { readonly x: { readonly a: 1; readonly b: \u0026#34;hi\u0026#34;; }; readonly y: \u0026#34;hey\u0026#34;; }; type Todo = DeepReadonly\u0026lt;X\u0026gt;; // should be same as `Expected` 答案:\n1 2 3 4 5 type DeepReadonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P] extends { [key: string]: any } ? DeepReadonly\u0026lt;T[P]\u0026gt; : T[P]; }; \u0026nbsp;元组转联合类型 💯Take a Challenge\n实现泛型TupleToUnion\u0026lt;T\u0026gt;，它返回元组所有值组成的联合类型。\n例如\n1 2 3 type Arr = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]; type Test = TupleToUnion\u0026lt;Arr\u0026gt;; // expected to be \u0026#39;1\u0026#39; | \u0026#39;2\u0026#39; | \u0026#39;3\u0026#39; 答案:\n1 2 3 type TupleToUnion\u0026lt;T extends readonly any[]\u0026gt; = T extends [infer R, ...infer args] ? R | TupleToUnion\u0026lt;args\u0026gt; : never; \u0026nbsp;Chainable Options 💯Take a Challenge\nChainable options are commonly used in Javascript. But when we switch to TypeScript, can you properly type it?\nIn this challenge, you need to type an object or a class - whatever you like - to provide two function option(key, value) and get(). In option, you can extend the current config type by the given key and value. We should about to access the final result via get.\nFor example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 declare const config: Chainable; const result = config .option(\u0026#34;foo\u0026#34;, 123) .option(\u0026#34;name\u0026#34;, \u0026#34;type-challenges\u0026#34;) .option(\u0026#34;bar\u0026#34;, { value: \u0026#34;Hello World\u0026#34; }) .get(); // expect the type of result to be: interface Result { foo: number; name: string; bar: { value: string; }; } You don\u0026rsquo;t need to write any js/ts logic to handle the problem - just in type level.\nYou can assume that key only accepts string and the value can be anything - just leave it as-is. Same key won\u0026rsquo;t be passed twice. 答案:\n1 2 3 4 5 6 7 type Chainable\u0026lt;T\u0026gt; = { options\u0026lt;K extends string, V\u0026gt;( key: K, value: V ): Chainable\u0026lt;T \u0026amp; { [k in K]: V }\u0026gt;; get(): T; }; \u0026nbsp;Last 💯Take a Challenge\nTypeScript 4.0 is recommended in this challenge\nImplement a generic Last\u0026lt;T\u0026gt; that takes an Array T and returns its last element.\nFor example\n1 2 3 4 5 type arr1 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; type arr2 = [3, 2, 1]; type tail1 = Last\u0026lt;arr1\u0026gt;; // expected to be \u0026#39;c\u0026#39; type tail2 = Last\u0026lt;arr2\u0026gt;; // expected to be 1 答案:\n1 type Last\u0026lt;T extends any[]\u0026gt; = T extends [...any[], infer L] ? L : never; \u0026nbsp;Pop 💯Take a Challenge\nTypeScript 4.0 is recommended in this challenge\nImplement a generic Pop\u0026lt;T\u0026gt; that takes an Array T and returns an Array without it\u0026rsquo;s last element.\nFor example\n1 2 3 4 5 type arr1 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]; type arr2 = [3, 2, 1]; type re1 = Pop\u0026lt;arr1\u0026gt;; // expected to be [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] type re2 = Pop\u0026lt;arr2\u0026gt;; // expected to be [3, 2] Extra: Similarly, can you implement Shift, Push and Unshift as well?\n答案:\n1 2 3 4 5 type Pop\u0026lt;T extends any[]\u0026gt; = T extends [] ? [] : T extends [...infer Rest, any] ? Rest : never; \u0026nbsp;Promise.all 💯Take a Challenge Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise\u0026lt;T\u0026gt; where T is the resolved result array.\n1 2 3 4 5 6 7 8 const promise1 = Promise.resolve(3); const promise2 = 42; const promise3 = new Promise\u0026lt;string\u0026gt;((resolve, reject) =\u0026gt; { setTimeout(resolve, 100, \u0026#34;foo\u0026#34;); }); // expected to be `Promise\u0026lt;[number, 42, string]\u0026gt;` const p = Promise.all([promise1, promise2, promise3] as const); 答案:\n1 2 3 4 5 6 type PromiseAllType\u0026lt;T\u0026gt; = Promise\u0026lt;{ [P in keyof T]: T[P] extends Promise\u0026lt;infer R\u0026gt; ? R : T[P]; }\u0026gt;; declare function PromiseAll\u0026lt;T extends any[]\u0026gt;( values: readonly [...T] ): PromiseAllType\u0026lt;T\u0026gt;; \u0026nbsp;Type Lookup 💯Take a Challenge\nSometimes, you may want to lookup for a type in a union to by their attributes.\nIn this challenge, we would like to get the corresponding type by searching for the common type field in the union Cat | Dog. In other words, we will expect to get Dog for LookUp\u0026lt;Dog | Cat, 'dog'\u0026gt; and Cat for LookUp\u0026lt;Dog | Cat, 'cat'\u0026gt; in the following example.\n1 2 3 4 5 6 7 8 9 10 11 12 interface Cat { type: \u0026#34;cat\u0026#34;; breeds: \u0026#34;Abyssinian\u0026#34; | \u0026#34;Shorthair\u0026#34; | \u0026#34;Curl\u0026#34; | \u0026#34;Bengal\u0026#34;; } interface Dog { type: \u0026#34;dog\u0026#34;; breeds: \u0026#34;Hound\u0026#34; | \u0026#34;Brittany\u0026#34; | \u0026#34;Bulldog\u0026#34; | \u0026#34;Boxer\u0026#34;; color: \u0026#34;brown\u0026#34; | \u0026#34;white\u0026#34; | \u0026#34;black\u0026#34;; } type MyDogType = LookUp\u0026lt;Cat | Dog, \u0026#34;dog\u0026#34;\u0026gt;; // expected to be `Dog` 答案:\n1 2 3 4 5 type LookUp\u0026lt;U extends { type: string }, T extends string\u0026gt; = U extends { type: T; } ? U : never; \u0026nbsp;Trim Left 💯Take a Challenge Implement TrimLeft\u0026lt;T\u0026gt; which takes an exact string type and returns a new string with the whitespace beginning removed.\nFor example\n1 type trimed = TrimLeft\u0026lt;\u0026#34; Hello World \u0026#34;\u0026gt;; // expected to be \u0026#39;Hello World \u0026#39; 答案:\n1 2 3 4 5 6 type TrimLeft\u0026lt;Str extends string\u0026gt; = Str extends `${ | \u0026#34; \u0026#34; | \u0026#34;\\n\u0026#34; | \u0026#34;\\t\u0026#34;}${infer Rest}` ? TrimLeft\u0026lt;Rest\u0026gt; : Str; \u0026nbsp;Trim 💯Take a Challenge\nImplement Trim\u0026lt;T\u0026gt; which takes an exact string type and returns a new string with the whitespace from both ends removed.\nFor example\n1 type trimmed = Trim\u0026lt;\u0026#34; Hello World \u0026#34;\u0026gt;; // expected to be \u0026#39;Hello World\u0026#39; 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type TrimStrRight\u0026lt;Str extends string\u0026gt; = Str extends `${infer Rest}${ | \u0026#34; \u0026#34; | \u0026#34;\\n\u0026#34; | \u0026#34;\\t\u0026#34;}` ? TrimStrRight\u0026lt;Rest\u0026gt; : Str; type TrimStrLeft\u0026lt;Str extends string\u0026gt; = Str extends `${ | \u0026#34; \u0026#34; | \u0026#34;\\n\u0026#34; | \u0026#34;\\t\u0026#34;}${infer Rest}` ? TrimStrLeft\u0026lt;Rest\u0026gt; : Str; type Trim\u0026lt;Str extends string\u0026gt; = TrimStrRight\u0026lt;TrimStrLeft\u0026lt;Str\u0026gt;\u0026gt;; \u0026nbsp;Capitalize 💯Take a Challenge\nImplement Capitalize\u0026lt;T\u0026gt; which converts the first letter of a string to uppercase and leave the rest as-is.\nFor example\n1 type capitalized = Capitalize\u0026lt;\u0026#34;hello world\u0026#34;\u0026gt;; // expected to be \u0026#39;Hello world\u0026#39; 答案:\n1 2 3 4 type MyCapitalize\u0026lt;Str extends string\u0026gt; = Str extends `${infer First}${infer Rest}` ? `${Uppercase\u0026lt;First\u0026gt;}${Rest}` : Str; \u0026nbsp;Replace 💯Take a Challenge\nImplement Replace\u0026lt;S, From, To\u0026gt; which replace the string From with To once in the given string S\nFor example\n1 type replaced = Replace\u0026lt;\u0026#34;types are fun!\u0026#34;, \u0026#34;fun\u0026#34;, \u0026#34;awesome\u0026#34;\u0026gt;; // expected to be \u0026#39;types are awesome!\u0026#39; 答案:\n1 2 3 4 5 6 7 8 9 type Replace\u0026lt; S extends string, From extends string, To extends string \u0026gt; = S extends `${infer L}${From}${infer R}` ? From extends \u0026#34;\u0026#34; ? S : `${L}${To}${R}` : S; \u0026nbsp;ReplaceAll 💯Take a Challenge\n答案:\n1 2 3 4 5 6 7 8 9 type ReplaceAll\u0026lt; Str extends string, From extends string, To extends string \u0026gt; = Str extends `${infer Left}${From}${infer Right}` ? From extends \u0026#34;\u0026#34; ? Str : `${Left}${To}${ReplaceAll\u0026lt;Right, From, To\u0026gt;}` : Str; \u0026nbsp;Append Argument 💯Take a Challenge\nFor given function type Fn, and any type A (any in this context means we don\u0026rsquo;t restrict the type, and I don\u0026rsquo;t have in mind any type 😉) create a generic type which will take Fn as the first argument, A as the second, and will produce function type G which will be the same as Fn but with appended argument A as a last one.\nFor example,\n1 2 3 4 type Fn = (a: number, b: string) =\u0026gt; number; type Result = AppendArgument\u0026lt;Fn, boolean\u0026gt;; // expected be (a: number, b: string, x: boolean) =\u0026gt; number This question is ported from the original article by @maciejsikora 答案:\n1 2 3 type AppendArgument\u0026lt;Fn, A\u0026gt; = Fn extends (...args: infer R) =\u0026gt; infer T ? (...args: [...R, A]) =\u0026gt; T : never; \u0026nbsp;Permutation 💯Take a Challenge\nImplement permutation type that transforms union types into the array that includes permutations of unions.\n1 type perm = Permutation\u0026lt;\u0026#34;A\u0026#34; | \u0026#34;B\u0026#34; | \u0026#34;C\u0026#34;\u0026gt;; // [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] | [\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;] | [\u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;] | [\u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;A\u0026#39;] | [\u0026#39;C\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] | [\u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;] 答案:\n1 2 3 4 5 type Permutation\u0026lt;T, U = T\u0026gt; = [T] extends [never] ? [] : T extends T ? [T, ...Permutation\u0026lt;Exclude\u0026lt;U, T\u0026gt;\u0026gt;] : never; [T] extends [never]是包裹类型条件判断，这里用于处理联合类型为空的情况。\nT extends T 用于触发分布式条件类型。\n\u0026lt;Exclude\u0026lt;U, T\u0026gt;排除 T 类型，由于 T 此时触发了分布式条件类型的特性，是单独的 T 类型而不是 Union 类型。\n🌰 举个栗子，分析一下执行过程：\ntype res = Permutation\u0026lt;\u0026quot;A\u0026quot; | \u0026quot;B\u0026quot; | \u0026quot;C\u0026quot;\u0026gt; 当 分布式条件类型 T 为 A 时，递归调用 Permutation\u0026lt;\u0026quot;B\u0026quot; | \u0026quot;C\u0026quot;\u0026gt;，此时结果为 [\u0026quot;A\u0026quot;,...[\u0026quot;B\u0026quot;,Permutation\u0026lt;\u0026quot;C\u0026quot;\u0026gt;]]]与[\u0026quot;A\u0026quot;,...[\u0026quot;C\u0026quot;, Permutation\u0026lt;\u0026quot;B\u0026quot;\u0026gt;]]]。最终得到[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;]与[\u0026quot;A\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;B\u0026quot;]。\n\u0026nbsp;Length of String 💯Take a Challenge\nCompute the length of a string literal, which behaves like String#length. 答案:\n1 2 3 4 5 6 type LengthOfString\u0026lt; S extends string, CountArr extends unknown[] = [] \u0026gt; = S extends `${string}${infer Rest}` ? LengthOfString\u0026lt;Rest, [...CountArr, unknown]\u0026gt; : CountArr[\u0026#34;length\u0026#34;]; \u0026nbsp;Flatten 💯Take a Challenge\nIn this challenge, you would need to write a type that takes an array and emitted the flatten array type.\nFor example:\n1 type flatten = Flatten\u0026lt;[1, 2, [3, 4], [[[5]]]]\u0026gt;; // [1, 2, 3, 4, 5] 答案:\n1 2 3 4 5 type Flatten\u0026lt;T extends any[]\u0026gt; = T extends [infer L, ...infer R] ? L extends any[] ? [...Flatten\u0026lt;L\u0026gt;, ...Flatten\u0026lt;R\u0026gt;] : [L, ...Flatten\u0026lt;R\u0026gt;] : []; \u0026nbsp;Append to object 💯Take a Challenge\nImplement a type that adds a new field to the interface. The type takes the three arguments. The output should be an object with the new field.\nFor example\n1 2 type Test = { id: \u0026#34;1\u0026#34; }; type Result = AppendToObject\u0026lt;Test, \u0026#34;value\u0026#34;, 4\u0026gt;; // expected to be { id: \u0026#39;1\u0026#39;, value: 4 } 答案:\n1 2 3 type AppendToObject\u0026lt;T, K extends keyof any, V\u0026gt; = { [P in keyof T | K]: P extends keyof T ? T[P] : V; }; \u0026nbsp;Absolute 💯Take a Challenge\nImplement the Absolute type. A type that take string, number or bigint. The output should be a positive number string\nFor example\n1 2 type Test = -100; type Result = Absolute\u0026lt;Test\u0026gt;; // expected to be \u0026#34;100\u0026#34; 答案:\n1 2 3 type Absolute\u0026lt;T extends number | string | bigint\u0026gt; = `${T}` extends `-${infer N}` ? N : `${T}`; \u0026nbsp;String to Union 💯Take a Challenge\nImplement the String to Union type. Type take string argument. The output should be a union of input letters\nFor example：\n1 2 type Test = \u0026#34;123\u0026#34;; type Result = StringToUnion\u0026lt;Test\u0026gt;; // expected to be \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; 答案:\n1 2 3 type StringToUnion\u0026lt;S extends string\u0026gt; = S extends `${infer L}${infer R}` ? L | StringToUnion\u0026lt;R\u0026gt; : never; \u0026nbsp;Merge 💯Take a Challenge\nMerge two types into a new type. Keys of the second type overrides keys of the first type.\nFor example：\n1 2 3 4 5 6 7 8 9 10 type foo = { name: string; age: string; }; type coo = { age: number; sex: string; }; type Result = Merge\u0026lt;foo, coo\u0026gt;; // expected to be {name: string, age: number, sex: string} 答案: 后面的属性的值会覆盖前面相同属性的值\n1 2 3 4 5 6 7 type Merge\u0026lt;F, S\u0026gt; = { [P in keyof F | keyof S]: P extends keyof S ? S[P] : P extends keyof F ? F[P] : never; }; \u0026nbsp;KebabCase 💯Take a Challenge\nFooBarBaz -\u0026gt; foo-bar-baz 答案:\n1 2 3 4 5 type KebabCase\u0026lt;S extends string\u0026gt; = S extends `${infer S1}${infer S2}` ? S2 extends Uncapitalize\u0026lt;S2\u0026gt; ? `${Uncapitalize\u0026lt;S1\u0026gt;}${KebabCase\u0026lt;S2\u0026gt;}` : `${Uncapitalize\u0026lt;S1\u0026gt;}-${KebabCase\u0026lt;S2\u0026gt;}` : S; \u0026nbsp;Diff 💯Take a Challenge\nGet an Object that is the difference between O \u0026amp; O1 答案:\n1 2 3 4 5 6 7 8 type DiffKeys\u0026lt;T, U\u0026gt; = Exclude\u0026lt;keyof T | keyof U, keyof (T | U)\u0026gt;; type Diff\u0026lt;O, O1\u0026gt; = { [K in DiffKeys\u0026lt;O, O1\u0026gt;]: K extends keyof O ? O[K] : K extends keyof O1 ? O1[K] : never; }; keyof T| keyof U 表示 T 和 U 的所有属性组成的联合类型\nkeyof (T | U) 表示 T 和 U 的公共属性\n\u0026nbsp;AnyOf 💯Take a Challenge\nImplement Python liked any function in the type system. A type takes the Array and returns true if any element of the Array is true. If the Array is empty, return false.\nFor example:\n1 2 type Sample1 = AnyOf\u0026lt;[1, \u0026#34;\u0026#34;, false, [], {}]\u0026gt;; // expected to be true. type Sample2 = AnyOf\u0026lt;[0, \u0026#34;\u0026#34;, false, [], {}]\u0026gt;; // expected to be false. 答案:\n1 2 type False = 0 | \u0026#34;\u0026#34; | false | [] | { [key: string]: never }; type AnyOf\u0026lt;T extends readonly any[]\u0026gt; = T[number] extends False ? false : true; \u0026nbsp;IsNever 💯Take a Challenge\nImplement a type IsNever, which takes input type T. If the type of resolves to never, return true, otherwise false.\nFor example:\n1 2 3 4 5 type A = IsNever\u0026lt;never\u0026gt;; // expected to be true type B = IsNever\u0026lt;undefined\u0026gt;; // expected to be false type C = IsNever\u0026lt;null\u0026gt;; // expected to be false type D = IsNever\u0026lt;[]\u0026gt;; // expected to be false type E = IsNever\u0026lt;number\u0026gt;; // expected to be false 答案:\n1 2 3 4 // never type TestNever\u0026lt;T\u0026gt; = T extends never ? 1 : 2; //包裹类型 type IsNever\u0026lt;T\u0026gt; = [T] extends [never] ? true : false; \u0026nbsp;IsUnion 💯Take a Challenge\nImplement a type IsUnion, which takes an input type T and returns whether T resolves to a union type.\nFor example:\n```ts type case1 = IsUnion\u0026lt;string\u0026gt; // false type case2 = IsUnion\u0026lt;string|number\u0026gt; // true type case3 = IsUnion\u0026lt;[string|number]\u0026gt; // false ``` 答案:\n1 2 3 4 5 6 7 type IsUnion\u0026lt;T, U = T\u0026gt; = [T] extends [never] ? false : T extends T //触发分布式条件类型，让每个类型单独传入处理的 ? [U] extends [T] // 在这里,U是联合类型,T是单独的类型，所以使用[B] extends [A]来判断是不是联合类型 ? false : true : never; \u0026nbsp;ReplaceKeys 💯Take a Challenge\nImplement a type ReplaceKeys, that replace keys in union types, if some type has not this key, just skip replacing, A type takes three arguments.\nFor example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type NodeA = { type: \u0026#34;A\u0026#34;; name: string; flag: number; }; type NodeB = { type: \u0026#34;B\u0026#34;; id: number; flag: number; }; type NodeC = { type: \u0026#34;C\u0026#34;; name: string; flag: number; }; type Nodes = NodeA | NodeB | NodeC; type ReplacedNodes = ReplaceKeys\u0026lt; Nodes, \u0026#34;name\u0026#34; | \u0026#34;flag\u0026#34;, { name: number; flag: string } \u0026gt;; // {type: \u0026#39;A\u0026#39;, name: number, flag: string} | {type: \u0026#39;B\u0026#39;, id: number, flag: string} | {type: \u0026#39;C\u0026#39;, name: number, flag: string} // would replace name from string to number, replace flag from number to string. type ReplacedNotExistKeys = ReplaceKeys\u0026lt;Nodes, \u0026#34;name\u0026#34;, { aa: number }\u0026gt;; // {type: \u0026#39;A\u0026#39;, name: never, flag: number} | NodeB | {type: \u0026#39;C\u0026#39;, name: never, flag: number} // would replace name to never 答案:\n1 2 3 type ReplaceKeys\u0026lt;U, T, Y\u0026gt; = { [P in keyof U]: P extends T ? (P extends keyof Y ? Y[P] : never) : U[P]; }; \u0026nbsp;Remove Index Signature 💯Take a Challenge\nImplement RemoveIndexSignature\u0026lt;T\u0026gt; , exclude the index signature from object types.\nFor example:\ntype Foo = { [key: string]: any; foo(): void; } type A = RemoveIndexSignature\u0026lt;Foo\u0026gt; // expected { foo(): void } 答案:\n1 2 3 4 type NeverIndex\u0026lt;P\u0026gt; = string extends P ? never : number extends P ? never : P; type RemoveIndexSignature\u0026lt;T\u0026gt; = { [P in keyof T as NeverIndex\u0026lt;P\u0026gt;]: T[P]; }; 索引签名的键为string或者number，所以我们通过 string extends P 和 number extends P 的形式排除此索引签名。\n\u0026nbsp;Percentage Parser 💯Take a Challenge\nImplement PercentageParser. According to the /^(\\+|\\-)?(\\d*)?(\\%)?$/ regularity to match T and get three matches.\nThe structure should be: [plus or minus, number, unit] If it is not captured, the default is an empty string.\nFor example:\n1 2 3 4 5 6 7 8 9 10 11 type PString1 = \u0026#34;\u0026#34;; type PString2 = \u0026#34;+85%\u0026#34;; type PString3 = \u0026#34;-85%\u0026#34;; type PString4 = \u0026#34;85%\u0026#34;; type PString5 = \u0026#34;85\u0026#34;; type R1 = PercentageParser\u0026lt;PString1\u0026gt;; // expected [\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;] type R2 = PercentageParser\u0026lt;PString2\u0026gt;; // expected [\u0026#34;+\u0026#34;, \u0026#34;85\u0026#34;, \u0026#34;%\u0026#34;] type R3 = PercentageParser\u0026lt;PString3\u0026gt;; // expected [\u0026#34;-\u0026#34;, \u0026#34;85\u0026#34;, \u0026#34;%\u0026#34;] type R4 = PercentageParser\u0026lt;PString4\u0026gt;; // expected [\u0026#34;\u0026#34;, \u0026#34;85\u0026#34;, \u0026#34;%\u0026#34;] type R5 = PercentageParser\u0026lt;PString5\u0026gt;; // expected [\u0026#34;\u0026#34;, \u0026#34;85\u0026#34;, \u0026#34;\u0026#34;] 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 // your answers type PercentageParser\u0026lt; A extends string, P = \u0026#34;\u0026#34;, N extends string = \u0026#34;\u0026#34;, S = \u0026#34;\u0026#34; \u0026gt; = A extends `${infer First}${infer Rest}` ? First extends \u0026#34;-\u0026#34; | \u0026#34;+\u0026#34; ? PercentageParser\u0026lt;Rest, First, N, S\u0026gt; : First extends \u0026#34;%\u0026#34; ? PercentageParser\u0026lt;Rest, P, N, First\u0026gt; : PercentageParser\u0026lt;Rest, P, `${N}${First}`, S\u0026gt; : [P, N, S]; \u0026nbsp;Drop Char 💯Take a Challenge\nDrop a specified char from a string.\nFor example:\n1 type Butterfly = DropChar\u0026lt;\u0026#34; b u t t e r f l y ! \u0026#34;, \u0026#34; \u0026#34;\u0026gt;; // \u0026#39;butterfly!\u0026#39; 答案:\n1 2 3 4 5 6 type DropChar\u0026lt; S extends string, C extends string \u0026gt; = S extends `${infer Prefix}${C}${infer Suffix}` ? DropChar\u0026lt;`${Prefix}${Suffix}`, C\u0026gt; : S; \u0026nbsp;MinusOne 💯Take a Challenge\nGiven a number (always positive) as a type. Your type should return the number decreased by one.\nFor example:\n1 2 type Zero = MinusOne\u0026lt;1\u0026gt;; // 0 type FiftyFour = MinusOne\u0026lt;55\u0026gt;; // 54 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //存在最大递归调用深度，比较大的数字会出错，这个方法过不了题目中Expect\u0026lt;Equal\u0026lt;MinusOne\u0026lt;1101\u0026gt;, 1100\u0026gt;\u0026gt;这个测试用例。 type BuildArr\u0026lt; Length extends number, Elem = unknown, Arr extends unknown[] = [] \u0026gt; = Arr[\u0026#34;length\u0026#34;] extends Length ? Arr : BuildArr\u0026lt;Length, Elem, [...Arr, Elem]\u0026gt;; type Subtract\u0026lt; Num1 extends number, Num2 extends number \u0026gt; = BuildArray\u0026lt;Num1\u0026gt; extends [...arr1: BuildArr\u0026lt;Num2\u0026gt;, ...arr2: infer Rest] ? Rest[\u0026#34;length\u0026#34;] : never; \u0026nbsp;PickByType 💯Take a Challenge\nFrom T, pick a set of properties whose type are assignable to U.\nFor Example\n1 2 3 4 5 6 7 8 9 type OnlyBoolean = PickByType\u0026lt; { name: string; count: number; isReadonly: boolean; isEnable: boolean; }, boolean \u0026gt;; // { isReadonly: boolean; isEnable: boolean; } 答案:\n1 2 3 type PickByType\u0026lt;T, U\u0026gt; = { [P in keyof T as T[P] extends U ? P : never]: T[P]; }; \u0026nbsp;StartsWith 💯Take a Challenge Implement StartsWith\u0026lt;T, U\u0026gt; which takes two exact string types and returns whether T starts with U\nFor example\n1 2 3 type a = StartsWith\u0026lt;\u0026#34;abc\u0026#34;, \u0026#34;ac\u0026#34;\u0026gt;; // expected to be false type b = StartsWith\u0026lt;\u0026#34;abc\u0026#34;, \u0026#34;ab\u0026#34;\u0026gt;; // expected to be true type c = StartsWith\u0026lt;\u0026#34;abc\u0026#34;, \u0026#34;abcd\u0026#34;\u0026gt;; // expected to be false 答案:\n1 2 3 type StartsWith\u0026lt;S extends string, C extends string\u0026gt; = S extends `${C}${string}` ? true : false; \u0026nbsp;EndsWith 💯Take a Challenge\nImplement EndsWith\u0026lt;T, U\u0026gt; which takes two exact string types and returns whether T ends with U\nFor example:\n1 2 3 type a = EndsWith\u0026lt;\u0026#34;abc\u0026#34;, \u0026#34;bc\u0026#34;\u0026gt;; // expected to be false type b = EndsWith\u0026lt;\u0026#34;abc\u0026#34;, \u0026#34;abc\u0026#34;\u0026gt;; // expected to be true type c = EndsWith\u0026lt;\u0026#34;abc\u0026#34;, \u0026#34;d\u0026#34;\u0026gt;; // expected to be false 答案:\n1 2 3 type EndsWith\u0026lt;S extends string, C extends string\u0026gt; = S extends `${string}${C}` ? true : false; \u0026nbsp;PartialByKeys 💯Take a Challenge\nImplement a generic PartialByKeys\u0026lt;T, K\u0026gt; which takes two type argument T and K.\nK specify the set of properties of T that should set to be optional. When K is not provided, it should make all properties optional just like the normal Partial\u0026lt;T\u0026gt;.\nFor example\n1 2 3 4 5 6 7 interface User { name: string; age: number; address: string; } type UserPartialName = PartialByKeys\u0026lt;User, \u0026#34;name\u0026#34;\u0026gt;; // { name?:string; age:number; address:string } 答案:\n1 2 3 4 5 6 type CopyKeys\u0026lt;T\u0026gt; = { [P in keyof T]: T[P]; }; type PartialByKeys\u0026lt;T, K extends keyof any = keyof T\u0026gt; = CopyKeys\u0026lt; Partial\u0026lt;Pick\u0026lt;T, Extract\u0026lt;keyof T, K\u0026gt;\u0026gt;\u0026gt; \u0026amp; Omit\u0026lt;T, K\u0026gt; \u0026gt;; \u0026nbsp;RequiredByKeys 💯Take a Challenge\nImplement a generic RequiredByKeys\u0026lt;T, K\u0026gt; which takes two type argument T and K.\nK specify the set of properties of T that should set to be required. When K is not provided, it should make all properties required just like the normal Required\u0026lt;T\u0026gt;.\nFor example\n1 2 3 4 5 6 7 interface User { name?: string; age?: number; address?: string; } type UserRequiredName = RequiredByKeys\u0026lt;User, \u0026#34;name\u0026#34;\u0026gt;; // { name: string; age?: number; address?: string } 答案:\n1 2 3 4 5 6 type CopyKeys\u0026lt;T\u0026gt; = { [P in keyof T]: T[P]; }; type RequiredByKeys\u0026lt;T, K extends keyof any = keyof T\u0026gt; = CopyKeys\u0026lt; Required\u0026lt;Pick\u0026lt;T, Extract\u0026lt;keyof T, K\u0026gt;\u0026gt;\u0026gt; \u0026amp; Omit\u0026lt;T, K\u0026gt; \u0026gt;; \u0026nbsp;Mutable 💯Take a Challenge\nImplement the generic Mutable\u0026lt;T\u0026gt; which makes all properties in T mutable (not readonly).\nFor example\n1 2 3 4 5 6 7 interface Todo { readonly title: string; readonly description: string; readonly completed: boolean; } type MutableTodo = Mutable\u0026lt;Todo\u0026gt;; // { title: string; description: string; completed: boolean; } 答案:\n1 2 3 type MyMutable\u0026lt;T\u0026gt; = { -readonly [P in keyof T]: T[P]; }; \u0026nbsp;OmitByType 💯Take a Challenge\nFrom T, pick a set of properties whose type are not assignable to U.\nFor Example\n1 2 3 4 5 6 7 8 9 type OmitBoolean = OmitByType\u0026lt; { name: string; count: number; isReadonly: boolean; isEnable: boolean; }, boolean \u0026gt;; // { name: string; count: number } 答案:\n1 2 3 type OmitByType\u0026lt;T, U\u0026gt; = { [P in keyof T as U extends T[P] ? never : P]: T[P]; }; \u0026nbsp;ObjectEntries 💯Take a Challenge\nImplement the type version of Object.entries\nFor example\n1 2 3 4 5 6 interface Model { name: string; age: number; locations: string[] | null; } type modelEntries = ObjectEntries\u0026lt;Model\u0026gt;; // [\u0026#39;name\u0026#39;, string] | [\u0026#39;age\u0026#39;, number] | [\u0026#39;locations\u0026#39;, string[] | null]; 答案:\n1 2 3 type ObjectEntries\u0026lt;T\u0026gt; = { [K in keyof Required\u0026lt;T\u0026gt;]: [K, T[K] extends undefined ? T[K] : Required\u0026lt;T\u0026gt;[K]]; }[keyof T]; \u0026nbsp;Shift 💯Take a Challenge\nImplement the type version of Array.shift\nFor example\n1 type Result = Shift\u0026lt;[3, 2, 1]\u0026gt;; // [2, 1] 答案:\n1 2 3 4 5 type Shift\u0026lt;T extends unknown[]\u0026gt; = T extends [] ? [] : T extends [unknown, ...infer Rest] ? Rest : never; \u0026nbsp;Tuple to Nested Object 💯Take a Challenge\nGiven a tuple type T that only contains string type, and a type U, build an object recursively.\n1 2 3 type a = TupleToNestedObject\u0026lt;[\u0026#34;a\u0026#34;], string\u0026gt;; // {a: string} type b = TupleToNestedObject\u0026lt;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;], number\u0026gt;; // {a: {b: number}} type c = TupleToNestedObject\u0026lt;[], boolean\u0026gt;; // boolean. if the tuple is empty, just return the U type 答案:\n1 2 3 4 5 6 7 8 type TupleToNestedObject\u0026lt;T extends any[], U\u0026gt; = T extends [ infer F, ...infer Rest ] ? F extends string ? { [P in F]: TupleToNestedObject\u0026lt;Rest, U\u0026gt; } : never : U; \u0026nbsp;Reverse 💯Take a Challenge\nImplement the type version of Array.reverse\nFor example:\n1 2 type a = Reverse\u0026lt;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;]\u0026gt;; // [\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] type b = Reverse\u0026lt;[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]\u0026gt;; // [\u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] 答案:\n1 2 3 type Reverse\u0026lt;T extends any[]\u0026gt; = T extends [...infer R, infer L] ? [L, ...Reverse\u0026lt;R\u0026gt;] : []; \u0026nbsp;Flip Arguments 💯Take a Challenge\nImplement the type version of lodash\u0026rsquo;s _.flip.\nType FlipArguments\u0026lt;T\u0026gt; requires function type T and returns a new function type which has the same return type of T but reversed parameters.\nFor example:\n1 2 3 4 type Flipped = FlipArguments\u0026lt; (arg0: string, arg1: number, arg2: boolean) =\u0026gt; void \u0026gt;; // (arg0: boolean, arg1: number, arg2: string) =\u0026gt; void 答案:\n1 2 3 type FlipArguments\u0026lt;T\u0026gt; = T extends (...args: infer A) =\u0026gt; infer R ? (...args: Reverse\u0026lt;A\u0026gt;) =\u0026gt; R : never; \u0026nbsp;FlattenDepth 💯Take a Challenge\nRecursively flatten array up to depth times.\nFor example:\n1 2 type a = FlattenDepth\u0026lt;[1, 2, [3, 4], [[[5]]]], 2\u0026gt;; // [1, 2, 3, 4, [5]]. flattern 2 times type b = FlattenDepth\u0026lt;[1, 2, [3, 4], [[[5]]]]\u0026gt;; // [1, 2, 3, 4, [[5]]]. Depth defaults to be 1 If the depth is provided, it\u0026rsquo;s guaranteed to be positive integer. 答案:\n1 2 3 4 5 6 7 8 9 10 11 type FlattenDepth\u0026lt; T extends any[], D extends number = 1, U extends any[] = [] \u0026gt; = T extends [infer F, ...infer R] ? U[\u0026#34;length\u0026#34;] extends D ? T : F extends any[] ? [...FlattenDepth\u0026lt;F, D, [0, ...U]\u0026gt;, ...FlattenDepth\u0026lt;R, D\u0026gt;] : [F, ...FlattenDepth\u0026lt;R, D, U\u0026gt;] : T; \u0026nbsp;BEM style string 💯Take a Challenge\nThe Block, Element, Modifier methodology (BEM) is a popular naming convention for classes in CSS.\nFor example, the block component would be represented as btn, element that depends upon the block would be represented as btn__price, modifier that changes the style of the block would be represented as btn--big or btn__price--warning.\nImplement BEM\u0026lt;B, E, M\u0026gt; which generate string union from these three parameters. Where B is a string literal, E and M are string arrays (can be empty). 答案:\n1 2 3 4 5 6 7 8 type Preprocess\u0026lt;T extends any[], P extends string\u0026gt; = T extends [] ? \u0026#34;\u0026#34; : `${P}${T[number]}`; type BEM\u0026lt; B extends string, E extends string[], M extends string[] \u0026gt; = `${B}${Preprocess\u0026lt;E, \u0026#34;__\u0026#34;\u0026gt;}${Preprocess\u0026lt;M, \u0026#34;--\u0026#34;\u0026gt;}`; \u0026nbsp;InorderTraversal 💯Take a Challenge\nImplement the type version of binary tree inorder traversal.\nFor example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const tree1 = { val: 1, left: null, right: { val: 2, left: { val: 3, left: null, right: null, }, right: null, }, } as const; type A = InorderTraversal\u0026lt;typeof tree1\u0026gt;; // [1, 3, 2] 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 interface TreeNode { val: number; left: TreeNode | null; right: TreeNode | null; } type InorderTraversal\u0026lt; T extends TreeNode | null, U extends TreeNode = NonNullable\u0026lt;T\u0026gt; \u0026gt; = T extends TreeNode ? [...InorderTraversal\u0026lt;U[\u0026#34;left\u0026#34;]\u0026gt;, U[\u0026#34;val\u0026#34;], ...InorderTraversal\u0026lt;U[\u0026#34;right\u0026#34;]\u0026gt;] : []; \u0026nbsp;Flip 💯Take a Challenge\nImplement the type of just-flip-object. Examples:\n1 2 3 Flip\u0026lt;{ a: \u0026#34;x\u0026#34;, b: \u0026#34;y\u0026#34;, c: \u0026#34;z\u0026#34; }\u0026gt;; // {x: \u0026#39;a\u0026#39;, y: \u0026#39;b\u0026#39;, z: \u0026#39;c\u0026#39;} Flip\u0026lt;{ a: 1, b: 2, c: 3 }\u0026gt;; // {1: \u0026#39;a\u0026#39;, 2: \u0026#39;b\u0026#39;, 3: \u0026#39;c\u0026#39;} Flip\u0026lt;{ a: false, b: true }\u0026gt;; // {false: \u0026#39;a\u0026#39;, true: \u0026#39;b\u0026#39;} No need to support nested objects and values which cannot be object keys such as arrays 答案:\n1 2 3 type Flip\u0026lt;T extends Record\u0026lt;string, boolean | number | string\u0026gt;\u0026gt; = { [P in keyof T as `${T[P]}`]: P; }; \u0026nbsp;Fibonacci Sequence 💯Take a Challenge\nImplement a generic Fibonacci\u0026lt;T\u0026gt; takes an number T and returns it\u0026rsquo;s corresponding Fibonacci number.\nThe sequence starts: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u0026hellip;\nFor example\n1 2 type Result1 = Fibonacci\u0026lt;3\u0026gt;; // 2 type Result2 = Fibonacci\u0026lt;8\u0026gt;; // 21 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Fibonacci\u0026lt; Num extends number, PrevArr extends unknown[] = [1], CurrentArr extends unknown[] = [], IndexArr extends unknown[] = [] \u0026gt; = IndexArr[\u0026#34;length\u0026#34;] extends Num ? CurrentArr[\u0026#34;length\u0026#34;] : Fibonacci\u0026lt; Num, CurrentArr, [...PrevArr, ...CurrentArr], [...IndexArr, unknown] \u0026gt;; \u0026nbsp;AllCombinations 💯Take a Challenge\nImplement type AllCombinations\u0026lt;S\u0026gt; that return all combinations of strings which use characters from S at most once.\nFor example:\n1 2 type AllCombinations_ABC = AllCombinations\u0026lt;\u0026#34;ABC\u0026#34;\u0026gt;; // should be \u0026#39;\u0026#39; | \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; | \u0026#39;C\u0026#39; | \u0026#39;AB\u0026#39; | \u0026#39;AC\u0026#39; | \u0026#39;BA\u0026#39; | \u0026#39;BC\u0026#39; | \u0026#39;CA\u0026#39; | \u0026#39;CB\u0026#39; | \u0026#39;ABC\u0026#39; | \u0026#39;ACB\u0026#39; | \u0026#39;BAC\u0026#39; | \u0026#39;BCA\u0026#39; | \u0026#39;CAB\u0026#39; | \u0026#39;CBA\u0026#39; 答案:\n1 2 3 4 5 6 7 8 9 10 11 type StringToUnion\u0026lt;S extends string\u0026gt; = S extends `${infer F}${infer R}` ? F | StringToUnion\u0026lt;R\u0026gt; : never; type Combination\u0026lt;S extends string, U extends string = \u0026#34;\u0026#34;, K = S\u0026gt; = [S] extends [ never ] ? U : K extends S ? Combination\u0026lt;Exclude\u0026lt;S, K\u0026gt;, U | `${U}${K}`\u0026gt; : U; type AllCombination\u0026lt;S extends string\u0026gt; = Combination\u0026lt;StringToUnion\u0026lt;S\u0026gt;\u0026gt;; \u0026nbsp;Greater Than 💯Take a Challenge\nIn This Challenge, You should implement a type GreaterThan\u0026lt;T, U\u0026gt; like T \u0026gt; U\nNegative numbers do not need to be considered.\nFor example\n1 2 3 4 GreaterThan\u0026lt;2, 1\u0026gt; //should be true GreaterThan\u0026lt;1, 1\u0026gt; //should be false GreaterThan\u0026lt;10, 100\u0026gt; //should be false GreaterThan\u0026lt;111, 11\u0026gt; //should be true 答案:\n1 2 3 4 5 6 7 8 9 10 11 type GreaterThan\u0026lt; Num1 extends number, Num2 extends number, CountArr extends unknown[] = [] \u0026gt; = Num1 extends Num2 ? false : CountArr[\u0026#34;length\u0026#34;] extends Num2 ? true : CountArr[\u0026#34;length\u0026#34;] extends Num1 ? false : GreaterThan\u0026lt;Num1, Num2, [...CountArr, unknown]\u0026gt;; \u0026nbsp;Zip 💯Take a Challenge\nIn This Challenge, You should implement a type Zip\u0026lt;T, U\u0026gt;, T and U must be Tuple\n1 type exp = Zip\u0026lt;[1, 2], [true, false]\u0026gt;; // expected to be [[1, true], [2, false]] 答案:\n1 2 3 4 5 6 7 8 type Zip\u0026lt;One extends unknown[], Other extends unknown[]\u0026gt; = One extends [ infer OneFirst, ...infer OneRest ] ? Other extends [infer OtherFirst, ...infer OtherRest] ? [[OneFirst, OtherFirst], ...Zip\u0026lt;OneRest, OtherRest\u0026gt;] : [] : []; \u0026nbsp;IsTuple 💯Take a Challenge\nImplement a type IsTuple, which takes an input type T and returns whether T is tuple type.\nFor example:\n1 2 3 type case1 = IsTuple\u0026lt;[number]\u0026gt;; // true type case2 = IsTuple\u0026lt;readonly [number]\u0026gt;; // true type case3 = IsTuple\u0026lt;number[]\u0026gt;; // false 答案:\n1 2 3 4 5 6 7 8 9 10 11 type IsTuple\u0026lt;T\u0026gt; = [T] extends [never] ? false : T extends readonly [...params: infer Eles] ? NotEqual\u0026lt;Eles[\u0026#34;length\u0026#34;], number\u0026gt; : false; type NotEqual\u0026lt;A, B\u0026gt; = (\u0026lt;T\u0026gt;() =\u0026gt; T extends A ? 1 : 2) extends \u0026lt; T \u0026gt;() =\u0026gt; T extends B ? 1 : 2 ? false : true; \u0026nbsp;Chunk 💯Take a Challenge\nDo you know lodash? Chunk is a very useful function in it, now let\u0026rsquo;s implement it. Chunk\u0026lt;T, N\u0026gt; accepts two required type parameters, the T must be a tuple, and the N must be an integer \u0026gt;=1\n1 2 3 type exp1 = Chunk\u0026lt;[1, 2, 3], 2\u0026gt;; // expected to be [[1, 2], [3]] type exp2 = Chunk\u0026lt;[1, 2, 3], 4\u0026gt;; // expected to be [[1, 2, 3]] type exp3 = Chunk\u0026lt;[1, 2, 3], 1\u0026gt;; // expected to be [[1], [2], [3]] 答案:\n1 2 3 4 5 6 7 8 9 10 11 type Chunk\u0026lt; T extends any[], Size extends number, R extends any[] = [] \u0026gt; = R[\u0026#34;length\u0026#34;] extends Size ? [R, ...Chunk\u0026lt;T, Size\u0026gt;] : T extends [infer F, ...infer L] ? Chunk\u0026lt;L, Size, [...R, F]\u0026gt; : R[\u0026#34;length\u0026#34;] extends 0 ? [] : [R]; \u0026nbsp;Fill 💯Take a Challenge\nFill, a common JavaScript function, now let us implement it with types. Fill\u0026lt;T, N, Start?, End?\u0026gt;, as you can see,Fill accepts four types of parameters, of which T and N are required parameters, and Start and End are optional parameters. The requirements for these parameters are: T must be a tuple, N can be any type of value, Start and End must be integers greater than or equal to 0.\n1 type exp = Fill\u0026lt;[1, 2, 3], 0\u0026gt;; // expected to be [0, 0, 0] In order to simulate the real function, the test may contain some boundary conditions, I hope you can enjoy it :) 答案:\n1 2 3 type Fill\u0026lt;T extends any[], U\u0026gt; = T extends [any, ...infer Rest] ? [U, ...Fill\u0026lt;Rest, U\u0026gt;] : []; \u0026nbsp;Trim Right 💯Take a Challenge\nImplement TrimRight\u0026lt;T\u0026gt; which takes an exact string type and returns a new string with the whitespace ending removed.\nFor example:\n1 type Trimed = TrimRight\u0026lt;\u0026#34; Hello World \u0026#34;\u0026gt;; // expected to be \u0026#39; Hello World\u0026#39; 答案:\n1 2 3 4 5 6 type TrimRight\u0026lt;Str extends string\u0026gt; = Str extends `${infer Rest}${ | \u0026#34; \u0026#34; | \u0026#34;\\n\u0026#34; | \u0026#34;\\t\u0026#34;}` ? TrimRight\u0026lt;Rest\u0026gt; : Str; \u0026nbsp;Without 💯Take a Challenge\nImplement the type version of Lodash.without, Without\u0026lt;T, U\u0026gt; takes an Array T, number or array U and returns an Array without the elements of U.\n1 2 3 type Res = Without\u0026lt;[1, 2], 1\u0026gt;; // expected to be [2] type Res1 = Without\u0026lt;[1, 2, 4, 1, 5], [1, 2]\u0026gt;; // expected to be [4, 5] type Res2 = Without\u0026lt;[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]\u0026gt;; // expected to be [] 答案:\n1 2 3 4 5 6 7 8 9 10 11 type ToUnion\u0026lt;T\u0026gt; = T extends any[] ? T[number] : T; type Without\u0026lt; T extends any[], F, U = ToUnion\u0026lt;F\u0026gt;, R extends any[] = [] \u0026gt; = T extends [infer First, ...infer Rest] ? First extends U ? Without\u0026lt;Rest, F, U, [...R]\u0026gt; : Without\u0026lt;Rest, F, U, [...R, First]\u0026gt; : R; \u0026nbsp;Trunc 💯Take a Challenge Implement the type version of Math.trunc, which takes string or number and returns the integer part of a number by removing any fractional digits.\nFor example:\n1 type A = Trunc\u0026lt;12.34\u0026gt;; // 12 答案:\n1 2 3 type Trunc\u0026lt;T extends number | string\u0026gt; = `${T}` extends `${infer L}.${string}` ? L : `${T}`; \u0026nbsp;IndexOf 💯Take a Challenge\nImplement the type version of Array.indexOf, indexOf\u0026lt;T, U\u0026gt; takes an Array T, any U and returns the index of the first U in Array T.\n1 2 3 type Res = IndexOf\u0026lt;[1, 2, 3], 2\u0026gt;; // expected to be 1 type Res1 = IndexOf\u0026lt;[2, 6, 3, 8, 4, 1, 7, 3, 9], 3\u0026gt;; // expected to be 2 type Res2 = IndexOf\u0026lt;[0, 0, 0], 2\u0026gt;; // expected to be -1 答案:\n1 2 3 4 5 6 7 8 type IndexOf\u0026lt;T extends any[], U, Index extends any[] = []\u0026gt; = T extends [ infer First, ...infer Rest ] ? First extends U ? Index[\u0026#34;length\u0026#34;] : IndexOf\u0026lt;Rest, U, [...Index, 0]\u0026gt; : -1; \u0026nbsp;Join 💯Take a Challenge\nImplement the type version of Array.join, Join\u0026lt;T, U\u0026gt; takes an Array T, string or number U and returns the Array T with U stitching up.\n1 2 3 4 type Res = Join\u0026lt;[\u0026#34;a\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;e\u0026#34;], \u0026#34;-\u0026#34;\u0026gt;; // expected to be \u0026#39;a-p-p-l-e\u0026#39; type Res1 = Join\u0026lt;[\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;], \u0026#34; \u0026#34;\u0026gt;; // expected to be \u0026#39;Hello World\u0026#39; type Res2 = Join\u0026lt;[\u0026#34;2\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;2\u0026#34;], 1\u0026gt;; // expected to be \u0026#39;21212\u0026#39; type Res3 = Join\u0026lt;[\u0026#34;o\u0026#34;], \u0026#34;u\u0026#34;\u0026gt;; // expected to be \u0026#39;o\u0026#39; 答案:\n1 2 3 4 5 6 7 8 9 type Join\u0026lt; T extends any[], U extends string | number, R extends string = \u0026#34;\u0026#34; \u0026gt; = T extends [infer First, ...infer Rest] ? Rest[\u0026#34;length\u0026#34;] extends 0 ? `${R extends \u0026#34;\u0026#34; ? \u0026#34;\u0026#34; : `${R}${U}`}${First \u0026amp; string}` : Join\u0026lt;Rest, U, `${R extends \u0026#34;\u0026#34; ? \u0026#34;\u0026#34; : `${R}${U}`}${First \u0026amp; string}`\u0026gt; : R; \u0026nbsp;LastIndexOf 💯Take a Challenge\nImplement the type version of Array.lastIndexOf, LastIndexOf\u0026lt;T, U\u0026gt; takes an Array T, any U and returns the index of the last U in Array T\nFor example:\n1 2 type Res1 = LastIndexOf\u0026lt;[1, 2, 3, 2, 1], 2\u0026gt;; // 3 type Res2 = LastIndexOf\u0026lt;[0, 0, 0], 2\u0026gt;; // -1 答案:\n1 2 3 4 5 6 7 8 9 type Pop\u0026lt;T extends any[]\u0026gt; = T extends [...infer Rest, any] ? Rest : never; type LastIndexOf\u0026lt;T extends any[], U, Index extends any[] = Pop\u0026lt;T\u0026gt;\u0026gt; = T extends [ ...infer Rest, infer Last ] ? Last extends U ? Index[\u0026#34;length\u0026#34;] : LastIndexOf\u0026lt;Rest, U, Pop\u0026lt;Index\u0026gt;\u0026gt; : -1; \u0026nbsp;Unique 💯Take a Challenge\nImplement the type version of Lodash.uniq, Unique takes an Array T, returns the Array T without repeated values.\n1 2 3 4 5 type Res = Unique\u0026lt;[1, 1, 2, 2, 3, 3]\u0026gt;; // expected to be [1, 2, 3] type Res1 = Unique\u0026lt;[1, 2, 3, 4, 4, 5, 6, 7]\u0026gt;; // expected to be [1, 2, 3, 4, 5, 6, 7] type Res2 = Unique\u0026lt;[1, \u0026#34;a\u0026#34;, 2, \u0026#34;b\u0026#34;, 2, \u0026#34;a\u0026#34;]\u0026gt;; // expected to be [1, \u0026#34;a\u0026#34;, 2, \u0026#34;b\u0026#34;] type Res3 = Unique\u0026lt;[string, number, 1, \u0026#34;a\u0026#34;, 1, string, 2, \u0026#34;b\u0026#34;, 2, number]\u0026gt;; // expected to be [string, number, 1, \u0026#34;a\u0026#34;, 2, \u0026#34;b\u0026#34;] type Res4 = Unique\u0026lt;[unknown, unknown, any, any, never, never]\u0026gt;; // expected to be [unknown, any, never] 答案:\n1 2 3 4 5 6 7 8 type Unique\u0026lt;T extends any[], R extends any[] = []\u0026gt; = T extends [ infer First, ...infer Rest ] ? First extends R[number] ? Unique\u0026lt;Rest, [...R]\u0026gt; : Unique\u0026lt;Rest, [...R, First]\u0026gt; : R; \u0026nbsp;MapTypes 💯Take a Challenge\nImplement MapTypes\u0026lt;T, R\u0026gt; which will transform types in object T to different types defined by type R which has the following structure\n1 2 3 4 type StringToNumber = { mapFrom: string; // value of key which value is string mapTo: number; // will be transformed for number }; Examples:\n1 2 type StringToNumber = { mapFrom: string; mapTo: number;} MapTypes\u0026lt;{iWillBeANumberOneDay: string}, StringToNumber\u0026gt; // gives { iWillBeANumberOneDay: number; } Be aware that user can provide a union of types:\n1 2 3 type StringToNumber = { mapFrom: string; mapTo: number;} type StringToDate = { mapFrom: string; mapTo: Date;} MapTypes\u0026lt;{iWillBeNumberOrDate: string}, StringToDate | StringToNumber\u0026gt; // gives { iWillBeNumberOrDate: number | Date; } If the type doesn\u0026rsquo;t exist in our map, leave it as it was:\n1 2 type StringToNumber = { mapFrom: string; mapTo: number;} MapTypes\u0026lt;{iWillBeANumberOneDay: string, iWillStayTheSame: Function}, StringToNumber\u0026gt; // // gives { iWillBeANumberOneDay: number, iWillStayTheSame: Function } 答案:\n1 2 3 4 5 6 7 8 type GetMapType\u0026lt; T, R, Type = R extends { mapFrom: T; mapTo: infer To } ? To : never \u0026gt; = [Type] extends [never] ? T : Type; type MapTypes\u0026lt;T, R\u0026gt; = { [P in keyof T]: GetMapType\u0026lt;T[P], R\u0026gt;; }; \u0026nbsp;Construct Tuple 💯Take a Challenge\nConstruct a tuple with a given length.\nFor example\n1 type result = ConstructTuple\u0026lt;2\u0026gt;; // expect to be [unknown, unkonwn] 答案:\n1 2 3 4 5 // your answers type ConstructTuple\u0026lt; T extends number, R extends unknown[] = [] \u0026gt; = R[\u0026#34;length\u0026#34;] extends T ? R : ConstructTuple\u0026lt;T, [...R, unknown]\u0026gt;; \u0026nbsp;Number Range 💯Take a Challenge\nSometimes we want to limit the range of numbers\u0026hellip; For examples.\ntype result = NumberRange\u0026lt;2 , 9\u0026gt; // | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type ConstructTuple\u0026lt; L extends number, Result extends number[] = [] \u0026gt; = Result[\u0026#34;length\u0026#34;] extends L ? [...Result, 1] : ConstructTuple\u0026lt;L, [...Result, 1]\u0026gt;; type NumberRange\u0026lt; L extends number, H extends number, Temp extends number[] = ConstructTuple\u0026lt;L\u0026gt;, Result extends unknown[] = [L] \u0026gt; = L extends H ? Result[number] : NumberRange\u0026lt;Temp[\u0026#34;length\u0026#34;], H, [...Temp, 1], [...Result, Temp[\u0026#34;length\u0026#34;]]\u0026gt;; \u0026nbsp;Combination 💯Take a Challenge\nGiven an array of strings, do Permutation \u0026amp; Combination. It\u0026rsquo;s also useful for the prop types like video controlsList\n1 2 // expected to be `\u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34; | \u0026#34;baz\u0026#34; | \u0026#34;foo bar\u0026#34; | \u0026#34;foo bar baz\u0026#34; | \u0026#34;foo baz\u0026#34; | \u0026#34;foo baz bar\u0026#34; | \u0026#34;bar foo\u0026#34; | \u0026#34;bar foo baz\u0026#34; | \u0026#34;bar baz\u0026#34; | \u0026#34;bar baz foo\u0026#34; | \u0026#34;baz foo\u0026#34; | \u0026#34;baz foo bar\u0026#34; | \u0026#34;baz bar\u0026#34; | \u0026#34;baz bar foo\u0026#34;` type Keys = Combination\u0026lt;[\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;]\u0026gt;; 答案:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type AllCombinations\u0026lt;T extends string[], S extends string = T[number]\u0026gt; = [ S ] extends [never] ? \u0026#34;\u0026#34; : \u0026#34;\u0026#34; | { [K in S]: `${K} ${AllCombinations\u0026lt;never, Exclude\u0026lt;S, K\u0026gt;\u0026gt;}` }[S]; type TrimRight\u0026lt;T extends string, S = T\u0026gt; = T extends `${infer R}${ | \u0026#34; \u0026#34; | \u0026#34;\\n\u0026#34; | \u0026#34;\\t\u0026#34;}` ? TrimRight\u0026lt;R\u0026gt; : S; type Combination\u0026lt;T extends string[]\u0026gt; = TrimRight\u0026lt; Exclude\u0026lt;AllCombinations\u0026lt;T\u0026gt;, \u0026#34;\u0026#34;\u0026gt; \u0026gt;; \u0026nbsp;Subsequence 💯Take a Challenge\nGiven an array of unique elements, return all possible subsequences.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\nFor example:\n1 type A = Subsequence\u0026lt;[1, 2]\u0026gt;; // [] | [1] | [2] | [1, 2] 答案:\n1 2 3 4 5 6 7 8 9 type Subsequence\u0026lt;T extends number[], K extends number[] = []\u0026gt; = T extends [ infer L, ...infer R ] ? Subsequence\u0026lt; R extends number[] ? R : [], K | [...K, ...(L extends number ? [L] : [])] \u0026gt; : K; ","permalink":"https://zzydev.top/posts/headfirstts/ts%E7%B1%BB%E5%9E%8B%E6%8C%91%E6%88%98medium%E7%AF%87/","summary":"\u0026nbsp;获取函数返回类型 💯Take a Challenge 不使用 ReturnType 实现 TypeScript 的 ReturnType\u0026lt;T\u0026gt; 泛型。 例如： 1 2 3 4 5 6 const fn = (v: boolean) =\u0026gt; { if (v) return 1; else return 2; }; type a = MyReturnType\u0026lt;typeof fn\u0026gt;; // 应推导出 \u0026#34;1 | 2\u0026#34;","title":"TS类型挑战Medium篇"},{"content":" \u0026nbsp;根据运算优先级添加括号 现已知一个字符串是由正整数和加减乘除四个运算符(+ - * /)组成。\n例如存在字符串 const str = '11+2-3*4+5/2*4+10/5'，现在需要将高优先级运算，用小括号包裹起来，例如结果为 '11+2-(3*4)+(5/2*4)+(10/5)'。注意可能会出现连续的乘除运算，需要包裹到一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function addBrackets(str) { return str .split(\u0026#34;-\u0026#34;) .map((item) =\u0026gt; { if (item.includes(\u0026#34;+\u0026#34;)) { return item .split(\u0026#34;+\u0026#34;) .map((val) =\u0026gt; { if (val.includes(\u0026#34;*\u0026#34;) || val.includes(\u0026#34;/\u0026#34;)) { return `(${val})`; } return val; }) .join(\u0026#34;+\u0026#34;); } else { return item; } }) .join(\u0026#34;-\u0026#34;); } \u0026nbsp;实现一个类，其实例可以链式调用，它有一个sleep方法 1 2 3 4 5 6 7 8 const badboy = new PlayBoy(\u0026#34;zzydev\u0026#34;); // [译]playboy n.渣男 badboy.sayHi().sleep(1000).do(\u0026#34;学穿搭\u0026#34;).sleep(2000).do(\u0026#34;学瑜伽\u0026#34;); // 输出 // 妹妹你好，我是zzydev // 1s 之后 // 我在学穿搭 // 2s 之后 // 我在学瑜伽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 首先 定义一个类 PlayBoy class PlayBoy { constructor(name) { this.name = name; this.queue = []; //创建一个任务队列（利用队列的先进先出性质来模拟链式调用函数的执行顺序） setTimeout(() =\u0026gt; { // 进入异步任务队列 也是开启 自定义任务队列 queue 的入口 this.next(); // next是类PlayBoy 原型上的方法，用来从queue 任务队列中取出函数执行 }, 0); return this; } } PlayBoy.prototype.sayHi = function () { const fn = () =\u0026gt; { console.log(\u0026#34;妹妹你好，我是\u0026#34;, this.name); this.next(); }; this.queue.push(fn); return this; }; PlayBoy.prototype.sleep = function (timer) { const fn = () =\u0026gt; { setTimeout(() =\u0026gt; { this.next(); }, timer); }; this.queue.push(fn); return this; }; PlayBoy.prototype.do = function (...args) { const fn = () =\u0026gt; { console.log(\u0026#34;我在\u0026#34;, ...args); this.next(); }; this.queue.push(fn); return this; }; PlayBoy.prototype.next = function () { const fn = this.queue.shift(); // 从任务队列中取出函数 函数存在的话即调用 fn \u0026amp;\u0026amp; fn(); }; new PlayBoy(\u0026#34;zzydev\u0026#34;).sayHi().sleep(1000).do(\u0026#34;学穿搭\u0026#34;).sleep(2000).do(\u0026#34;学瑜伽\u0026#34;); \u0026nbsp;模拟 let 和 const 块级作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 模拟let (function () { var a = 1; console.log(\u0026#34;内部a:\u0026#34;, a); })(); //模拟const const值不可变 (function () { var a = { a: 1, b: 2 }; //对象 if (Object.prototype.toString.call(a) === \u0026#34;[object Object]\u0026#34;) { var b = a; a.c = 3; //或者 // a = {}; if (a !== b) { console.error(\u0026#34;变量不能再次赋值\u0026#34;); a = b; } console.log(a); } else { //基础类型值 var prev = a; a = 2; if (a !== prev) { console.error(\u0026#34;变量不能再次赋值\u0026#34;); a = prev; } console.log(a); } })(); \u0026nbsp;使用Promise封装一个异步加载图片的方法 1 2 3 4 5 6 7 8 9 10 11 function loadImg(url) { return new Promise((resolve, reject) =\u0026gt; { const img = new Image(); img.onload = function() { resolve(img); }; img.onerror = function() { reject(new Error(\u0026#39;Could not load image at\u0026#39; + url)); }; img.src = url; }); \u0026nbsp;实现事件委托 循环创建 10 个 li 标签，当点击 li 标签时，打印其对应的索引\n1 \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function loadNode(len) { var html = \u0026#34;\u0026#34;; for (let index = 0; index \u0026lt; 10; index++) { html += \u0026#34;\u0026lt;li\u0026gt;\u0026#34; + index + \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } var list = document.getElementById(\u0026#34;list\u0026#34;); list.onclick = function (event) { event = event || window.event; var target = event.target || event.srcElement; if (target.nodeName.toLowerCase() === \u0026#34;li\u0026#34;) { console.log(target.innerText); } }; list.innerHTML = html; } loadNode(); \u0026nbsp;模拟私有 1 2 3 4 5 6 7 8 9 function cls() { this.a = \u0026#34;who care\u0026#34;; return { getVal: () =\u0026gt; this.a, }; } let obj = new cls(); obj.getVal(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const myWm = new WeakMap(); class Fish { constructor(name) { myWm.set(this, { _fishbone: [ \u0026#34;草鱼\u0026#34;, \u0026#34;鲫鱼\u0026#34;, \u0026#34;青鱼\u0026#34;, \u0026#34;鲤鱼\u0026#34;, \u0026#34;鲢鱼\u0026#34;, \u0026#34;鳙鱼\u0026#34;, \u0026#34;鳊鱼\u0026#34;, \u0026#34;翘嘴\u0026#34;, \u0026#34;餐条\u0026#34;, ], }); this.name = name; } isBone() { return myWm.get(this)._fishbone.includes(this.name); } } // 测试，买了两条鱼 let fish1 = new Fish(\u0026#34;草鱼\u0026#34;); let fish2 = new Fish(\u0026#34;回鱼\u0026#34;); // 返回 true，有刺 console.log(fish1.isBone()); // 返回 false，没有肌间刺 console.log(fish2.isBone()); \u0026nbsp;如何实现上拉加载，下拉刷新？ 上拉加载 \u0026nbsp;判断一个对象是普通对象还是通过类创建的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const isPlainObject = (obj: any): boolean =\u0026gt; { if (typeof obj !== \u0026#34;object\u0026#34; || obj === null) { return false; } let proto = Object.getPrototypeOf(obj); if (proto === null) { return true; } let baseProto = proto; while (Object.getPrototypeOf(baseProto) !== null) { baseProto = Object.getPrototypeOf(baseProto); } return proto === baseProto; }; \u0026nbsp;图片加载失败处理方式 1 2 3 \u0026lt;!-- 图片加载失败，使用图片自带的 error 事件处理即可 --\u0026gt; \u0026lt;img src={imgSrc} onError={event =\u0026gt; { event.currentTarget.src = defaultSrc; }} /\u0026gt; \u0026nbsp;判断是不是NaN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function isNaNVal(val) { return Object.is(val, NaN); } function isNaNVal(val) { return val !== val; } function isNaNVal(val) { return typeof val === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; isNaN(val); } if (!(\u0026#34;isNaN\u0026#34; in Number)) { Number.isNaN = function (val) { return typeof val === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; isNaN(val); }; } // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness var arr = [NaN]; arr.indexOf(NaN); // -1 Number::equal arr.includes(NaN); // true Number::sameValueZero [ ] \u0026nbsp;解压字符串 给定一个压缩过后的字符串，请恢复其原始状态。\nuncompress(\u0026#39;3(ab)\u0026#39;) // \u0026#39;ababab\u0026#39; uncompress(\u0026#39;3(ab2(c))\u0026#39;) // \u0026#39;abccabccabcc\u0026#39; 数字 k 之后如果有一对括号，意味着括号内的子字符串在原来的状态中重复了 k 次。k 是正整数。 测试用例的输入均为有效字符串，原始字符串中不存在数字\n参考答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const isNumber = (str) =\u0026gt; !isNaN(Number(str)) \u0026amp;\u0026amp; isFinite(Number(str)); function uncompress(str) { let stack = []; for (const char of str) { if (char !== \u0026#34;)\u0026#34;) { stack.push(char); } else { let word = \u0026#34;\u0026#34;; let count = \u0026#34;\u0026#34;; while (stack.length \u0026amp;\u0026amp; stack[stack.length - 1] !== \u0026#34;(\u0026#34;) { word = stack.pop() + word; } stack.pop(); while (stack.length \u0026amp;\u0026amp; isNumber(stack[stack.length - 1])) { count = stack.pop() + count; } stack.push(word.repeat(Number(count))); } } return stack.join(\u0026#34;\u0026#34;); } \u0026nbsp;undefined to null 实现一个函数 undefinedToNull(),要求将所有的 undefined 替换成 null\n1 2 3 4 5 undefinedToNull({ a: undefined, b: \u0026#34;BFE.dev\u0026#34; }); // {a: null, b: \u0026#39;BFE.dev\u0026#39;} undefinedToNull({ a: [\u0026#34;BFE.dev\u0026#34;, undefined, \u0026#34;bigfrontend.dev\u0026#34;] }); // {a: [\u0026#39;BFE.dev\u0026#39;, null, \u0026#39;bigfrontend.dev\u0026#39;]} 参考答案：\n1 2 3 4 5 6 7 8 9 const isObject = (obj) =\u0026gt; typeof obj === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj !== null; function undefinedToNull(arg) { if (!isObject(arg)) return arg; for (let [key, val] of Object.entries(arg)) { if (val === undefined) arg[key] = null; else arg[key] = undefinedToNull(val); } return arg; } ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%88%91%E7%9A%84%E6%8B%B7%E9%9D%A2%E7%BB%8F_2/","summary":"\u0026nbsp;根据运算优先级添加括号 现已知一个字符串是由正整数和加减乘除四个运算符(+ - * /)组成。 例如存在字符串 const str = '11+2-3*4+5","title":"我的拷面经（二）"},{"content":"工厂模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 interface IProduct { name: string; fn1: () =\u0026gt; void; fn2: () =\u0026gt; void; } class Product1 implements IProduct { constructor(public name: string) {} fn1() { console.log(\u0026#34;product1\u0026#34;); } fn2() { console.log(\u0026#34;product1\u0026#34;); } } class Product2 implements IProduct { constructor(public name: string) {} fn1() { console.log(\u0026#34;product2\u0026#34;); } fn2() { console.log(\u0026#34;product1\u0026#34;); } } class Creator { // 依赖倒置原则 （依赖抽象，而不是具体） create(type: string, name: string): IProduct { if (type === \u0026#34;p1\u0026#34;) { return new Product1(name); } if (type === \u0026#34;p2\u0026#34;) { return new Product2(name); } throw new Error(); } } ","permalink":"https://zzydev.top/posts/headfirstts/ts%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"工厂模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 interface IProduct { name: string; fn1: () =\u0026gt; void; fn2: () =\u0026gt; void; } class Product1 implements IProduct { constructor(public name: string) {} fn1() { console.log(\u0026#34;product1\u0026#34;); } fn2()","title":"TS设计模式"},{"content":" 大概是一份不完整的 Vite 备忘录\nno-bundle 是什么 no-bundle 理念：利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载\n在 Vite 项目中，一个 import 语句代表一个 HTTP 请求。 Vite 的 Dev Server 来接收这些请求、进行文件转译以及返回浏览器可以运行的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。\nCSS 工程化方案 自动引入 CSS 1 2 3 4 5 6 7 8 9 /*variable.scss*/ $theme-color: red; /*index.scss*/ @import \u0026#34;../../variable\u0026#34;; .header { color: $theme-color; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vite.config.ts import { normalizePath } from \u0026#34;vite\u0026#34;; // 如果类型报错，需要安装 @types/node import path from \u0026#34;path\u0026#34;; // 全局 scss 文件的路径 // 用 normalizePath 解决 window 下的路径问题 const variablePath = normalizePath(path.resolve(\u0026#34;./src/variable.scss\u0026#34;)); export default defineConfig({ // css 相关的配置 css: { preprocessorOptions: { scss: { // additionalData 的内容会在每个 scss 文件的开头自动注入 additionalData: `@import \u0026#34;${variablePath}\u0026#34;;`, }, }, }, }); CSS Modules 自定义生成的类名 1 2 3 4 5 6 7 8 9 10 11 12 13 // vite.config.ts export default { css: { modules: { // 一般我们可以通过 generateScopedName 属性来对生成的类名进行自定义 // 其中，name 表示当前文件名，local 表示类名 generateScopedName: \u0026#34;[name]__[local]___[hash:base64:5]\u0026#34;, }, preprocessorOptions: { // 省略预处理器配置 }, }, }; PostCSS 接入 autoprefixer 插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // vite.config.ts 增加如下的配置 import autoprefixer from \u0026#34;autoprefixer\u0026#34;; export default { css: { // 进行 PostCSS 配置 postcss: { plugins: [ autoprefixer({ // 指定目标浏览器 overrideBrowserslist: [\u0026#34;Chrome \u0026gt; 40\u0026#34;, \u0026#34;ff \u0026gt; 31\u0026#34;, \u0026#34;ie 11\u0026#34;], }), ], }, }, }; 常用插件：\npostcss-pxtorem：用来将 px 转换为 rem 单位，在适配移动端的场景下很常用\npostcss-preset-env:可以编写最新的 CSS 语法，不用担心兼容性问题\n插件站点：https://www.postcss.parts/\nCSS In JS 对于 CSS In JS 方案，在构建侧我们需要考虑选择器命名问题、DCE、代码压缩、生成 SourceMap、SSR 等问题，而 styled-components 和 emotion 已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; import react from \u0026#39;@vitejs/plugin-react\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ react({ babel: { // 加入 babel 插件 // 以下插件包都需要提前安装 // 当然，通过这个配置你也可以添加其它的 Babel 插件 plugins: [ // 适配 styled-component \u0026#34;babel-plugin-styled-components\u0026#34; // 适配 emotion \u0026#34;@emotion/babel-plugin\u0026#34; ] }, // 注意: 对于 emotion，需要单独加上这个配置 // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法 jsxImportSource: \u0026#34;@emotion/react\u0026#34; }) ] }) 原子化 CSS 接入 Unocss\nVite 与自动化代码规范工具 ESLint pnpm i eslint -D\nnpx eslint --init\nESLint 会帮我们自动生成.eslintrc.js 配置文件。我们选择不直接使用 npm 安装依赖，所以需要自己手动安装:\npnpm i eslint-plugin-react@latest -D\npnpm i @typescript-eslint/eslint-plugin@latest -D\npnpm i @typescript-eslint/parser@latest -D\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // .eslintrc.js module.exports = { //有些全局变量是业务代码引入的第三方库所声明，这里就需要在globals配置中声明全局变量 /* * \u0026#34;writable\u0026#34;或者 true，表示变量可重写； * \u0026#34;readonly\u0026#34;或者false，表示变量不可重写； * \u0026#34;off\u0026#34;，表示禁用该全局变量。 */ globals: { // 不可重写 $: false, jQuery: false } //指定上述的 env 配置后便会启用浏览器和 ES2021 环境， //在浏览器环境下，预定义了全局变量window、document等，而在ES2021环境下，预定义了全局变量Promise、Map。会同时启用 env: { browser: true, es2021: true, }, extends: [ //从 ESLint 本身继承； \u0026#34;eslint:recommended\u0026#34;, //从类似 eslint-config-xxx 的 npm 包继承； \u0026#34;standard\u0026#34; //从 ESLint 插件继承 //格式一般为: `plugin:${pluginName}/${configName}` //使用extends 的配置，ESLint 插件中的繁多配置，我们就不需要一一手动开启了 \u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, ], overrides: [], //ESLint 底层默认使用 Espree来进行 AST 解析,但还是不支持 TS ，因此需要引入其他的解析器完成 TS 的解析。 //社区提供了@typescript-eslint/parser这个解决方案，将 TS 代码转换为 Espree 能够识别的格式(即 Estree 格式)，然后在 Eslint 下通过Espree进行格式检查， 以此兼容了 TS 语法。 parser: \u0026#34;@typescript-eslint/parser\u0026#34;, parserOptions: { ecmaVersion: \u0026#34;latest\u0026#34;, sourceType: \u0026#34;module\u0026#34;, // ecmaFeatures: 为一个对象，表示想使用的额外语言特性，如开启 jsx }, //通过plugins扩展特定的代码规则 plugins: [\u0026#34;react\u0026#34;, \u0026#34;@typescript-eslint\u0026#34;], rules: { // https://zh-hans.eslint.org/docs/latest/use/configure/rules indent: [\u0026#34;error\u0026#34;, 4], \u0026#34;linebreak-style\u0026#34;: [\u0026#34;error\u0026#34;, \u0026#34;unix\u0026#34;], quotes: [\u0026#34;error\u0026#34;, \u0026#34;double\u0026#34;], semi: [\u0026#34;error\u0026#34;, \u0026#34;always\u0026#34;], }, }; Prettier pnpm i prettier -D\n在项目根目录执行touch .prettierrc.js \u0026amp;\u0026amp; code .prettierrc.js\n1 2 3 4 5 6 7 8 9 10 // .prettierrc.js module.exports = { printWidth: 80, //一行的字符数，如果超过会进行换行，默认为80 tabWidth: 2, // 一个 tab 代表几个空格数，默认为 2 个 useTabs: false, //是否使用 tab 进行缩进，默认为false，表示用空格进行缩进 singleQuote: true, // 字符串是否使用单引号，默认为 false，使用双引号 semi: true, // 行尾是否使用分号，默认为true trailingComma: \u0026#34;none\u0026#34;, // 是否使用尾逗号 bracketSpacing: true, // 对象大括号直接是否有空格，默认为 true，效果：{ a: 1 } }; 接下来我们将 Prettier 集成到现有的 ESLint 工具中，首先安装两个工具包:\npnpm i eslint-config-prettier -D\npnpm i eslint-plugin-prettier -D\n其中 eslint-config-prettier 用来覆盖 ESLint 本身的规则配置，而 eslint-plugin-prettier 则是用于让 Prettier 来接管 eslint --fix 即修复代码的能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // .eslintrc.js module.exports = { ... extends: [ ... // 1. 接入 prettier 的规则 + \u0026#34;prettier\u0026#34;, + \u0026#34;plugin:prettier/recommended\u0026#34; ], // 2. 加入 prettier 的 eslint 插件 + plugins: [\u0026#34;react\u0026#34;, \u0026#34;@typescript-eslint\u0026#34;, \u0026#34;prettier\u0026#34;], rules: { // 3. 注意要加上这一句，开启 prettier 自动修复的功能 + \u0026#34;prettier/prettier\u0026#34;: \u0026#34;error\u0026#34;, } }; VSCode 中安装 ESLint 和 Prettier 这两个插件，并且在设置区中开启 Format On Save, 接下来在你保存代码的时候 Prettier 便会自动帮忙修复代码格式。\n样式规范工具: Stylelint pnpm i stylelint stylelint-prettier -D\npnpm i stylelint-config-prettier -D\npnpm i stylelint-config-recess-order -D\npnpm i stylelint-config-standard -D\npnpm i stylelint-config-standard-scss -D\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // .stylelintrc.js module.exports = { // 注册 stylelint 的 prettier 插件 plugins: [\u0026#34;stylelint-prettier\u0026#34;], // 继承一系列规则集合 extends: [ // standard 规则集合 \u0026#34;stylelint-config-standard\u0026#34;, // standard 规则集合的 scss 版本 \u0026#34;stylelint-config-standard-scss\u0026#34;, // 样式属性顺序规则 \u0026#34;stylelint-config-recess-order\u0026#34;, // 接入 Prettier 规则 \u0026#34;stylelint-config-prettier\u0026#34;, \u0026#34;stylelint-prettier/recommended\u0026#34;, ], // 配置 rules rules: { // 开启 Prettier 自动格式化功能 \u0026#34;prettier/prettier\u0026#34;: true, }, }; Husky + lint-staged 的 Git 提交工作流集成 安装依赖： pnpm i husky -D\n初始化 Husky： npx husky install 注册 Husky 的 pre-commit 钩子： npx husky add .husky/pre-commit \u0026quot;npm run lint\u0026quot; 在 package.json 注册 prepare 命令：\n1 2 3 { \u0026#34;prepare\u0026#34;: \u0026#34;husky install\u0026#34; } 接入 commitlint 进行 commit 信息的检查，安装依赖： pnpm i commitlint @commitlint/cli @commitlint/config-conventional -D\ncommitlint 配置:\n1 2 3 echo \u0026#34;module.exports = { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;] }\u0026#34; \u0026gt; .commitlintrc.cjs 增加 Husky 的 commit-msg 钩子：npx husky add .husky/commit-msg \u0026quot;npx --no-install commitlint --edit \\\u0026quot;$1\\\u0026quot;\u0026quot;\n现在是全量的进行代码规范检查的，实际上这是没必要的，我们只需要对新增的文件内容进行检查即可。这就需要使用到另外一个工具: lint-staged 了。安装依赖:\npnpm i lint-staged -D package.json 中新增一些内容:\n1 2 3 4 5 { \u0026#34;lint-staged\u0026#34;: { \u0026#34;**/*.{js,jsx,tsx,ts}\u0026#34;: [\u0026#34;eslint --fix\u0026#34;] } } 在.husky/pre-commit 脚本中，修改一下其中的内容：\n1 2 3 4 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npx --no -- lint-staged 现在就可以在 git commit 的过程中实现局部的代码风格检查了。\n","permalink":"https://zzydev.top/posts/frontendengineering/vite%E5%88%9D%E6%8E%A2/","summary":"大概是一份不完整的 Vite 备忘录 no-bundle 是什么 no-bundle 理念：利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进","title":"Vite初探"},{"content":"npm 安装机制 npm 安装流程 npm 配置的优先级 命令行设置 npm 配置 \u0026gt; env 环境变量设置 npm 配置 \u0026gt; 项目级的 .npmrc 文件 \u0026gt; 用户级的 .npmrc 文件\u0026gt; 全局级的 .npmrc 文件 \u0026gt; npm 内置的 .npmrc 文件\n不同版本生成依赖树的区别 在 npm 2.X 时期，还是使用的最简单的循环遍历方式，递归地下载所有的依赖包，只要有用到的依赖，都进行安装。 npm 2.x时期 在 npm3.X 时期，将原有的循环遍历的方式改成了更为扁平的层级结构，将依赖进行平铺 在生成依赖树的时候，首先会遍历所有的依赖并将其放入树的第一层节点，然后再继续遍历每一个依赖。当有重复的模块时，如果依赖版本相同，就丢弃不放入依赖树中。如果依赖版本不一致，那么就将其放在该依赖下。\n比如，现在项目有 A、B、C 三个依赖，A 和 B 都依赖 D(v 0.0.1)，C 依赖 D (v 0.0.2)，那么就会出现生成的依赖树会因为依赖的先后顺序不同而不同的情况。 npm3.x时期 情况一 A、B 的顺序在最前面 npm3.x时期 情况二 C 的顺序在最前面 在 npm 5.X 时期，新增了package-lock.json锁文件\n在安装依赖流程中的最后一步，会生成 package-lock.json 文件，该文件存储的是确定的依赖信息。也就是说，只要 lock 文件相同，那么每次安装依赖生成的 node_module 就会是相同的。 package-lock.json 在项目中使用 package-lock.json 还可以减少安装时间。因为在 package-lock.json 锁文件中已经存放了每个包具体的版本信息和下载链接，这就不需要再去远程仓库进行查询，优先会使用缓存内容从而减少了大量的网络请求，并且对于弱网环境和离线环境更加友好。\nnpm 的缓存机制 执行 npm config get cache 得到配置缓存文件的路径：${user.home}.npm/_cacache\n_cacache 下有content-v2 和 index-v5两个文件夹\ncontent-v2 文件是用来存在缓存包的具体内容，index-v5 是用来存储依赖包的索引，根据 index-v5 中的索引去 content-v2 中查找具体的源文件 npm 在安装依赖的过程中，会根据 lock 文件中具体的包信息，用 pacote:range-manifest:{url}:{integrity} 规则生成出唯一的 key，然后用这个 key 通过 SHA256 加密算法得到一个 hash。这个 hash 对应的就是 _cacache/index-v5 中的文件路径，前 4 位 hash 用来区分路径，剩下的几位就是具体的文件名。文件的内容就是该缓存的具体信息了。\n1 2 3 4 5 6 7 8 9 10 11 //在项目中执行npm install loadsh //在package-lock.json 文件中看到 dependencies 字段中新增了一项 key 为 lodash 的字段： \u0026#34;lodash\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;4.17.21\u0026#34;, \u0026#34;resolved\u0026#34;: \u0026#34;https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz\u0026#34;, \u0026#34;integrity\u0026#34;: \u0026#34;sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==\u0026#34; } 1 2 3 4 5 6 7 8 9 10 //使用node执行 const crypto = require(\u0026#34;crypto\u0026#34;); crypto .createHash(\u0026#34;sha256\u0026#34;) .update( \u0026#34;pacote:range-manifest:https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz:sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==\u0026#34;, \u0026#34;utf8\u0026#34; ) .digest(\u0026#34;hex\u0026#34;); //可以得到一个hash值为: \u0026#39;7abb86ab5b46e978761b5965d2199f4ae35871985573b8879dd786d71df7a825\u0026#39; 在 shell 中执行 cd ~/.npm/\\_cacache/index-v5/7a/bb \u0026amp;\u0026amp; ls\n我们会看到 86ab5b46e978761b5965d2199f4ae35871985573b8879dd786d71df7a82这个文件 执行 cat 86ab5b46e978761b5965d2199f4ae35871985573b8879dd786d71df7a82\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;key\u0026#34;:\u0026#34;pacote:range-manifest:https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz:sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==\u0026#34;, \u0026#34;integrity\u0026#34;:\u0026#34;sha512-C2EkHXwXvLsbrucJTRS3xFHv7Mf/y9klmKDxPTE8yevCoH5h8Ae69Y+/lP+ahpW91crnzgO78elOk2E6APJfIQ==\u0026#34;, \u0026#34;time\u0026#34;:1630917070855, \u0026#34;size\u0026#34;:1, \u0026#34;metadata\u0026#34;:{ \u0026#34;id\u0026#34;:\u0026#34;lodash@4.17.21\u0026#34;, \u0026#34;manifest\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;lodash\u0026#34;, \u0026#34;version\u0026#34;:\u0026#34;4.17.21\u0026#34;, \u0026#34;dependencies\u0026#34;:{}, \u0026#34;optionalDependencies\u0026#34;:{}, \u0026#34;peerDependenciesMeta\u0026#34;:{}, \u0026#34;devDependencies\u0026#34;:{}, \u0026#34;bundleDependencies\u0026#34;:false, \u0026#34;peerDependencies\u0026#34;:{}, \u0026#34;deprecated\u0026#34;:false, \u0026#34;_resolved\u0026#34;:\u0026#34;https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz\u0026#34;, \u0026#34;_integrity\u0026#34;:\u0026#34;sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==\u0026#34;, \u0026#34;_shasum\u0026#34;:\u0026#34;679591c564c3bffaae8454cf0b3df370c3d6911c\u0026#34;, \u0026#34;_shrinkwrap\u0026#34;:null, \u0026#34;_id\u0026#34;:\u0026#34;lodash@4.17.21\u0026#34; }, \u0026#34;type\u0026#34;:\u0026#34;finalized-manifest\u0026#34; } } 这一步中_shasum 又充当了源文件包索引的作用，我们可以用这个 _shasum 去 _cache/content-v2 中找一下对应的文件。\n执行file content-v2/sha1/67/95/91c564c3bffaae8454cf0b3df370c3d6911c 指令\n可以看到这是一个 gzip 文件。然后我们解压看下里面的内容，可以看到这就是我们刚刚下载的 lodash 的源码！\nnpm 的缓存机制总结：\n在安装资源的时候，npm 会根据 lock 中的 integrity、version、name 信息生成一个唯一的 key。\n然后用这个 key 经过 SHA256 算法生成一个 hash，根据这个 hash 在 index-v5 中找到对应的缓存文件，该缓存文件中记录着该包的信息。\n根据该文件中的信息我们在 content-v2 中去找对应的压缩包，这样就找到了对应的缓存资源了。\n最后再将该压缩包解压到 node_modules 中\nyarn 的安装机制 yarn的安装流程图 检测包 这一步主要是检测项目中是否存在一些 npm 相关文件，比如 package-lock.json 等。如果有，会提示用户注意：这些文件的存在可能会导致冲突。在这一步骤中，也会检查系统 OS、CPU 等信息。 解析包 这一步会解析依赖树中每一个包的版本信息。\n首先获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容，这属于首层依赖。\n接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析。 对于没有解析过的包 A，首次尝试从 yarn.lock 中获取到版本信息，并标记为已解析； 如果在 yarn.lock 中没有找到包 A，则向 Registry 发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包标记为已解析。 npm 的相关知识 自定义 npm init npm init 命令原理：调用 shell 脚本输出一个初始化的 package.json 文件\n写一个 node 脚本，它的 module.exports 即为 package.json 配置内容\n设置 npm init 的脚本 npm config set init-module ${node脚本}\nnpx 的作用 在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script。 npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题。 利用 npm link，高效率在本地调试以验证包的可用性 为目标 npm 模块（npm-package-1）创建软链接，将其链接到全局 node 模块安装路径 /usr/local/lib/node_modules/ 中； 为目标 npm 模块（npm-package-1）的可执行 bin 文件创建软链接，将其链接到全局 node 命令安装路径 /usr/local/bin/ 中。 并/串行运行多个命令的工具 npm-run-all\n用法：npm-run-all \u0026ndash;serial task1 \u0026ndash;parallel task2 task3\n给 npm script 传递参数 1 2 \u0026#34;lint:js\u0026#34;: \u0026#34;eslint *.js\u0026#34;, \u0026#34;lint:js:fix\u0026#34;: \u0026#34;npm run lint:js -- --fix\u0026#34;, 当我们需要向 npm 脚本 (如 lint:js）中的命令传递选项和参数时，您需要使用--分隔符将其分离，以避免它们被解释为 npm 选项或参数。\n","permalink":"https://zzydev.top/posts/frontendengineering/%E9%87%8D%E5%AD%A6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","summary":"npm 安装机制 npm 安装流程 npm 配置的优先级 命令行设置 npm 配置 \u0026gt; env 环境变量设置 npm 配置 \u0026gt; 项目级的 .npmrc 文件 \u0026gt; 用户级的 .npmrc 文件\u0026gt; 全局级的 .npmrc 文件 \u0026gt; npm 内置的 .npmrc 文","title":"重学包管理工具"},{"content":"// todo 等待面试实战完补上\n","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%95%85%E6%84%8F%E4%B8%8D%E5%B0%8F%E5%BF%83%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98_02/","summary":"// todo 等待面试实战完补上","title":"故意不小心的面试题_02"},{"content":"// todo 等待面试实战完补上\n","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%95%85%E6%84%8F%E4%B8%8D%E5%B0%8F%E5%BF%83%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98_01/","summary":"// todo 等待面试实战完补上","title":"故意不小心的面试题_01"},{"content":"实现一个前端脚手架 todo ","permalink":"https://zzydev.top/posts/frontendengineering/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/","summary":"实现一个前端脚手架 todo","title":"前端工程化"},{"content":"Jest 的简易原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function expect(result) { return { toBe: function (actual) { if (result !== actual) { throw new Error(`expected ${actual} but got ${result}`); } }, }; } function test(desc, fn) { try { fn(); console.log(`${desc} - passed`); } catch (e) { console.log(`${desc} - failed: ${e.message}`); } } Jest 中的简单配置 运行 npx jest --init 初始化默认配置:\n是否需要开启 typescript\n是否需要生成覆盖率报告( 测试覆盖率就是我们编写的测试代码对原来的功能代码的占比)\n选择 node 环境或者浏览器环境\n在测试完成之后，是否需要进行一些清除工作\n更多配置\njest 中借助 babel 使用 ESModule 的执行流程：\nnpm run jest\njest (babel-jest)\n@babel-core\n取.babelrc 配置\n在运行测试之前，结合 babel，先将你的代码进行一次转化\n运行转换后的测试用例代码\nJest 中的匹配器 mathcers guide\nAPI 更多的 mathcers\nJest 命令行工具的使用 cli\njest --watch 表示监听文件更改，并重新运行与已更改的文件相关的测试。注意：只有在使用 git 版本控制下才能使用此功能。 监听模式下，控制台会提供几种模式选择：\n--watch 为 o 模式\n异步代码的测试方法 测试异步代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 test(\u0026#34;fetchData返回结果为404\u0026#34;, () =\u0026gt; { /* ⚠️如果期望Promise被Reject，则需要使用 .catch 方法。 请确保添加 expect.assertions 来验证一定数量的断言被调用。 如果没有使用 expect.assertions 的话，我们在请求返回不为404时不会被catch到，运行测试通过。 但我们是希望当发生错误时被catch到，然后执行expect判断，当错误是404时，测试通过。 */ expect.assertions(1); // 表示下面expect必须至少有一个被执行 return fetchData().catch((e) =\u0026gt; expect(e.toString().indexOf(\u0026#34;404\u0026#34;) \u0026gt; -1).toBe(true) ); }); test(\u0026#34;fetchData测试返回结果为{success: true}\u0026#34;, () =\u0026gt; { // toMatchObject匹配是否包含对象一部分 return expect(fetchData()).resolves.toMatchObject({ data: { success: true }, }); }); Jest 中的钩子函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //使用describe做分组测试 //默认最外层包着一层describe describe(\u0026#34;最顶层默认分组\u0026#34;,()=\u0026gt; { describe(\u0026#34;分组1\u0026#34;,()=\u0026gt; { beforeAll(()=\u0026gt; {}) afterAll(()=\u0026gt; {}) beforeEach(()=\u0026gt; {}) afterEach(()=\u0026gt; {}) // 单次只执行这一个测试用例 test.only(\u0026#34;desc\u0026#34;, () =\u0026gt; {}) } describe(\u0026#34;分组2\u0026#34;,()=\u0026gt; { ... } ... }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 beforeAll(() =\u0026gt; console.log(\u0026#34;outer - beforeAll\u0026#34;)); afterAll(() =\u0026gt; console.log(\u0026#34;outer - afterAll\u0026#34;)); beforeEach(() =\u0026gt; console.log(\u0026#34;outer - beforeEach\u0026#34;)); afterEach(() =\u0026gt; console.log(\u0026#34;outer - afterEach\u0026#34;)); test(\u0026#34;Outer test\u0026#34;, () =\u0026gt; console.log(\u0026#34;outer - test\u0026#34;)); describe(\u0026#34;Scoped / Nested block\u0026#34;, () =\u0026gt; { beforeAll(() =\u0026gt; console.log(\u0026#34;inner - beforeAll\u0026#34;)); afterAll(() =\u0026gt; console.log(\u0026#34;inner - afterAll\u0026#34;)); beforeEach(() =\u0026gt; console.log(\u0026#34;inner - beforeEach\u0026#34;)); afterEach(() =\u0026gt; console.log(\u0026#34;inner - afterEach\u0026#34;)); test(\u0026#34;Inner test\u0026#34;, () =\u0026gt; console.log(\u0026#34;inner - test\u0026#34;)); }); Jest 中的 Mock mock 大多数场景是我们并不关心待测试模块执行的结果，只关心模块能否被正常执行。 mock functions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export function runCallBack(fn) { fn(); } export function createObject(classItem) { new classItem(\u0026#34;你干嘛\u0026#34;); } test(\u0026#34;测试runCallBack\u0026#34;, () =\u0026gt; { const func = jest.fn(); // mock函数，捕获函数调用和返回结果，以及this和调用顺序 func.mockReturnValue(\u0026#34;mockReturnValue\u0026#34;); // 设置mock函数返回值 runCallBack(func); runCallBack(func); expect(func).toHaveBeenCalledTimes(2); // 检查函数是否被调用了两次 expect(func.mock.calls.length).toBe(2); console.log(func.mock); }); test(\u0026#34;测试createObject\u0026#34;, () =\u0026gt; { const func = jest.fn((args) =\u0026gt; { return args + \u0026#34;,你XX\u0026#34;; }); /* 相当于 func.mockImplementation((args) =\u0026gt; { retrun args + \u0026#34;,你XX\u0026#34; }) */ createObject(func); console.log(func.mock); }); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 export const generateConfig = () =\u0026gt; { return { server: \u0026#34;http://localhost\u0026#34;, port: 1313, time: new Date(); }; }; test(\u0026#34;测试generateConfig\u0026#34;, () =\u0026gt; { // 第一次会生成快照，第二次会将快照与执行测试用例结果进行对比 // 如果有冲突，可以在命令行在提示的模式下解决冲突 expect(generateConfig()).toMatchSnapshot({ time: expect.any(Date),//快照与当前执行结果比对，只要快照time属性的值是个Date类型就可以 port: expect.any(Number), }); }) Jest mock 深入学习 mock functions\njest object 在 jest.config.js 中设置，就不用手动写jest.mock('./demo')，Jest 会自动去__mocks__文件夹下找demo.js文件\n1 2 3 { automock: true; } mock timers 1 2 3 4 5 6 7 8 9 10 11 function timer(callback) { setTimeout(callback(), 3000); } //需要等待3秒才执行 test(\u0026#34;timer 测试\u0026#34;, (done) =\u0026gt; { timer(() =\u0026gt; { expect(1).toBe(1); done(); }); }); 1 2 3 4 5 6 7 8 9 10 11 12 13 function timer(callback) { setTimeout(() =\u0026gt; { callback(); }, 3000); } jest.useFakeTimers(); test(\u0026#34;timer 测试\u0026#34;, () =\u0026gt; { const fn = jest.fn(); timer(fn); jest.advanceTimersByTime(3000); // 快进3秒 expect(fn).toHaveBeenCalledTimes(1); // 检查函数是否被调用了一次 }); 通过对类的 Mock 理解单元测试与集成测试 todo ","permalink":"https://zzydev.top/posts/frontendengineering/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","summary":"Jest 的简易原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function expect(result) { return { toBe: function (actual) { if (result !== actual) { throw new Error(`expected ${actual} but got ${result}`); } }, }; } function test(desc, fn) { try { fn(); console.log(`${desc} - passed`); } catch (e) { console.log(`${desc} - failed: ${e.message}`); } } Jest","title":"Jest与前端自动化测试"},{"content":"//todo\n","permalink":"https://zzydev.top/posts/headfirstts/ts%E7%B1%BB%E5%9E%8B%E6%8C%91%E6%88%98extreme%E7%AF%87/","summary":"//todo","title":"TS类型挑战Extreme篇"},{"content":"//todo\n","permalink":"https://zzydev.top/posts/headfirstts/ts%E7%B1%BB%E5%9E%8B%E6%8C%91%E6%88%98hard%E7%AF%87/","summary":"//todo","title":"TS类型挑战Hard篇"},{"content":"node 基础概念 todo ","permalink":"https://zzydev.top/posts/node_deno/node%E5%9F%BA%E7%A1%80/","summary":"node 基础概念 todo","title":"Node基础"},{"content":"什么是 Babel babel 🐠 Babel is a compiler for writing next generation JavaScript. typescript babel 是什么\nbabel 的编译流程 \u0026nbsp;parse parse 阶段的目的是把源码字符串转换成机器能够理解的抽象语法树(AST)，这个过程分为词法分析、语法分析。\nlet name = 'zzydev' 经过词法分析得到 let、 name、 =、 \u0026quot;zzydev\u0026quot;Token 串。\n词法分析的工作是将一个长长的字符串识别出一个个的单词，这一个个单词就是 Token。 读取 token 串，把它转化为 AST，这个过程就叫语法分析。\n\u0026nbsp;transform transform 阶段是对 parse 生成的 AST 的处理，会进行 AST 的遍历，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改，返回新的 AST（可以指定是否继续遍历新生成的 AST）。这样遍历完一遍 AST 之后就完成了对代码的修改。\n\u0026nbsp;generate 把转换后的 AST 打印成目标代码，并生成 sourcemap\nsourcemap 原理\nBabel 与 AST Javascript AST 遵循 estree 规范\nBabel AST spec 与 estree spec 存在偏差\n⭐ Babel AST 规范\n在线 AST 可视化工具(一)\n在线 AST 可视化工具(二)\n⭐ Babel 类型定义 及其部分源码截取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //每种 AST 都有自己的属性，但是它们也有一些公共属性，其他AST Node通过继承BaseNode来获得公共属性 interface BaseNode { type: Node[\u0026#34;type\u0026#34;]; //AST 节点的类型 leadingComments?: ReadonlyArray\u0026lt;Comment\u0026gt; | null; //开始的注释 innerComments?: ReadonlyArray\u0026lt;Comment\u0026gt; | null; //中间的注释 trailingComments?: ReadonlyArray\u0026lt;Comment\u0026gt; | null; //结尾的注释 start?: number | null; //源码字符串的开始下标 end?: number | null; //源码字符串的结束下标 loc?: SourceLocation | null; // 开始和结束的行列 range?: [number, number]; // 相当于[start, end] extra?: Record\u0026lt;string, unknown\u0026gt;; //记录一些额外的信息，用于处理一些特殊情况。比如 StringLiteral 修改 value 只是值的修改，而修改 extra.raw 则可以连同单双引号一起修改。 } export interface SourceLocation { start: { line: number; column: number; }; end: { line: number; column: number; }; } interface BaseComment { value: string; start: number; end: number; loc: SourceLocation; type: \u0026#34;CommentBlock\u0026#34; | \u0026#34;CommentLine\u0026#34;; } export interface CommentBlock extends BaseComment { type: \u0026#34;CommentBlock\u0026#34;; } export interface CommentLine extends BaseComment { type: \u0026#34;CommentLine\u0026#34;; } export type Comment = CommentBlock | CommentLine; Babel 的 API parse\n","permalink":"https://zzydev.top/posts/headfirstbabel/1_%E5%88%9D%E8%A7%81babel/","summary":"什么是 Babel babel 🐠 Babel is a compiler for writing next generation JavaScript. typescript babel 是什么 babel 的编译流程 \u0026nbsp;parse parse 阶段的目的是把源码字符串转换成机器能够理解的抽象语法树(AST)，这个过程分为词法分","title":"1_初见Babel"},{"content":"前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。\n在这样的机制下，若 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”。一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，事件线程也在等待 JavaScript，这就导致你触发的事件也将是难以被响应的。\n为什么会产生“卡顿”这样的困局？ Stack Reconciler 需要的（同步递归）调和时间很长，这就意味着 JavaScript 线程将长时间地占用主线程，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题。\n设计思想：Fiber 是如何解决问题的 Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”。纤程的出现，意在对渲染过程实现更加精细的控制。\n从架构角度 Fiber 是对 React 核心算法（即调和过程）的重写 从编码角度 Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM” 从工作流的角度 Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。 Fiber 架构的应用目的，按照 React 官方的说法，是实现“增量渲染”。所谓“增量渲染”，通俗来说就是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里面。不过严格来说，增量渲染其实也只是一种手段，实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验。\nFiber 架构核心：“可中断”“可恢复”与“优先级” React15 架构 React15 架构可以分为两层：\nReconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Reconciler 协调器 我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等 API 触发更新。\n每当有更新发生时，Reconciler会做如下工作：\n调用函数组件、或 class 组件的render方法，将返回的 JSX 转化为虚拟 DOM 将虚拟 DOM 和上次更新时的虚拟 DOM 对比 通过对比找出本次更新中变化的虚拟 DOM 通知Renderer将变化的虚拟 DOM 渲染到页面上 你可以在这里 看到React官方对Reconciler的解释\nReact15 架构的缺点 在Reconciler中，mount的组件会调用mountComponent ，update的组件会调用updateComponent 。这两个方法都会递归更新子组件。\nReact16 架构 React16 架构可以分为三层：\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 相较于 React15，React16 中新增了Scheduler（调度器）\nScheduler（调度器） 既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。\n其实部分浏览器已经实现了这个 API，这就是requestIdleCallback。但是由于以下因素，React放弃使用：\n浏览器兼容性 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的requestIdleCallback触发的频率会变得很低 基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。\nScheduler 是独立于React的库\nReconciler（协调器） 我们知道，在 React15 中Reconciler是递归处理虚拟 DOM 的。让我们看看React16 的 Reconciler。\n我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。\n1 2 3 4 5 6 function workLoopConcurrent() { // Perform work until Scheduler asks us to yield while (workInProgress !== null \u0026amp;\u0026amp; !shouldYield()) { workInProgress = performUnitOfWork(workInProgress); } } 那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？\n在 React16 中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上代表增/删/更新的标记，类似这样：\n1 2 3 4 export const Placement = /* */ 0b0000000000010; export const Update = /* */ 0b0000000000100; export const PlacementAndUpdate = /* */ 0b0000000000110; export const Deletion = /* */ 0b0000000001000; 全部的标记见这里\n整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。\n你可以在这里看到React官方对 React16 新Reconciler的解释\nRenderer（渲染器） Renderer根据Reconciler为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。\n总结 在这套新的架构模式下，更新的处理工作流变成了这样：首先，每个更新任务都会被赋予一个优先级。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”。\nFiber 架构对生命周期的影响 Fiber 对生命周期的影响\n","permalink":"https://zzydev.top/posts/headfirstreact/9_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/","summary":"前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂","title":"9.如何理解Fiber架构的迭代动机与设计思想"},{"content":"从一道面试题说起 其他 setState 原理的文章\n本文的 online Demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; export default class App extends React.Component { state = { count: 0, }; increment = () =\u0026gt; { console.log(\u0026#34;increment setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;increment setState后的count\u0026#34;, this.state.count); }; triple = () =\u0026gt; { console.log(\u0026#34;triple setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); this.setState({ count: this.state.count + 1, }); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;triple setState后的count\u0026#34;, this.state.count); }; reduce = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;点我增加\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.triple}\u0026gt;点我增加三倍\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.reduce}\u0026gt;点我减少\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 结果打印如下： 异步的动机和原理——批量更新 从图上我们可以看出，一个完整的更新流程，涉及了包括 re-render（重渲染） 在内的多个步骤。re-render 本身涉及对 DOM 的操作，它会带来较大的性能开销。假如说“一次 setState 就触发一个完整的更新流程”这个结论成立，那么每一次 setState 的调用都会触发一次 re-render，我们的视图很可能没刷新几次就卡死了。这个过程如我们下面代码中的箭头流程图所示：\n1 2 3 4 5 6 7 8 9 this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); 事实上，这正是 setState 异步的一个重要的动机——避免频繁的 re-render。\n在实际的 React 运行时中，setState 异步的实现方式有点类似于 Vue 的 $nextTick 和浏览器里的 Event-Loop：每来一个 setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。 这个过程，叫作“批量更新”，批量更新的过程正如下面代码中的箭头流程图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count + 1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count + 1的任务，count + 1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队, [count + 1的任务，count + 1的任务, count + 1的任务] }); ↓ 合并 state，[count + 1的任务] ↓ 执行 count + 1的任务 值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。因此就算我们在 React 中写了这样一个 100 次的 setState 循环：\n1 2 3 4 5 6 7 8 9 test = () =\u0026gt; { console.log(\u0026#34;循环100次 setState前的count\u0026#34;, this.state.count); for (let i = 0; i \u0026lt; 100; i++) { this.setState({ count: this.state.count + 1, }); } console.log(\u0026#34;循环100次 setState后的count\u0026#34;, this.state.count); }; 也只是会增加 state 任务入队的次数，并不会带来频繁的 re-render。当 100 次调用结束后，仅仅是 state 的任务队列内容发生了变化， state 本身并不会立刻改变：\n“同步现象”背后的故事：从源码角度看 setState 工作流\n读到这里，相信你对异步这回事多少有些眉目了。接下来我们就要重点理解刚刚代码里最诡异的一部分——setState 的同步现象：\n1 2 3 4 5 6 7 8 9 reduce = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); }; 从题目上看，setState 似乎是在 setTimeout 函数的“保护”之下，才有了同步这一“特异功能”。事实也的确如此，假如我们把 setTimeout 摘掉，setState 前后的 console 表现将会与 increment 方法中无异：\n1 2 3 4 5 6 7 8 9 reduce = () =\u0026gt; { // setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); // },0); }; 点击后的输出结果如下图所示：\n现在问题就变得清晰多了：为什么 setTimeout 可以将 setState 的执行顺序从异步变为同步？\n这里我先给出一个结论：并不是 setTimeout 改变了 setState，而是 setTimeout 帮助 setState “逃脱”了 React 对它的管控。只要是在 React 管控下的 setState，一定是异步的。\n接下来我们就从 React 源码里，去寻求佐证这个结论的线索。\n解读 setState 工作流 接下来我们就沿着这个流程，逐个在源码中对号入座。首先是 setState 入口函数：\n1 2 3 4 5 6 ReactComponent.prototype.setState = function (partialState, callback) { this.updater.enqueueSetState(this, partialState); if (callback) { this.updater.enqueueCallback(this, callback, \u0026#34;setState\u0026#34;); } }; 入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。这里我们以对象形式的入参为例，可以看到它直接调用了 this.updater.enqueueSetState 这个方法：\n1 2 3 4 5 6 7 8 9 enqueueSetState: function (publicInstance, partialState) { // 根据 this 拿到对应的组件实例 var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, \u0026#39;setState\u0026#39;); // 这个 queue 对应的就是一个组件实例的 state 数组 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); // enqueueUpdate 用来处理当前的组件实例 enqueueUpdate(internalInstance); } 总结一下，enqueueSetState 做了两件事：\n将新的 state 放进组件的状态队列里； 用 enqueueUpdate 来处理将要更新的实例对象。 继续往下走，看看 enqueueUpdate 做了什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function enqueueUpdate(component) { ensureInjected(); // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段 if (!batchingStrategy.isBatchingUpdates) { // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件 batchingStrategy.batchedUpdates(enqueueUpdate, component); return; } // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等” dirtyComponents.push(component); if (component._updateBatchNumber == null) { component._updateBatchNumber = updateBatchNumber + 1; } } enqueueUpdate 引出了一个关键的对象——batchingStrategy，该对象所具备的 isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；其中的 batchedUpdates 方法更是能够直接发起更新流程。由此我们可以大胆推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * batchingStrategy源码 **/ var ReactDefaultBatchingStrategy = { // 全局唯一的锁标识 isBatchingUpdates: false, // 发起更新动作的方法 batchedUpdates: function (callback, a, b, c, d, e) { // 缓存锁变量 var alreadyBatchingStrategy = ReactDefaultBatchingStrategy.isBatchingUpdates; // 把锁“锁上” ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingStrategy) { callback(a, b, c, d, e); } else { // 启动事务，将 callback 放进事务里执行 transaction.perform(callback, null, a, b, c, d, e); } }, }; batchingStrategy 对象并不复杂，你可以理解为它是一个“锁管理器”。\n这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。\n理解了批量更新整体的管理机制，还需要注意 batchedUpdates 中，有一个引人注目的调用：\n1 transaction.perform(callback, null, a, b, c, d, e); 这行代码为我们引出了一个更为硬核的概念——React 中的 Transaction（事务）机制。\n理解 React 中的 Transaction（事务） 机制 Transaction 在 React 源码中的分布可以说非常广泛。如果你在 Debug React 项目的过程中，发现函数调用栈中出现了 initialize、perform、close、closeAll 或者 notifyAll 这样的方法名，那么很可能你当前就处于一个 Trasaction 中。\nTransaction 在 React 源码中表现为一个核心类，React 官方曾经这样描述它：Transaction 是创建一个黑盒，该黑盒能够封装任何的方法。因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行），实例化 Transaction 时只需提供相关的方法即可。\n这段话初读有点拗口，这里我推荐你结合 React 源码中的一段针对 Transaction 的注释来理解它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 * \u0026lt;pre\u0026gt; * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------\u0026gt;|-|---|-|---|--\u0026gt;|anyMethod|---|---|-|---|-|--------\u0026gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * \u0026lt;/pre\u0026gt; 说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，同时需要使用 Transaction 类暴露的 perform 方法去执行它。如上面的注释所示，在 anyMethod 执行之前，perform 会先执行所有 wrapper 的 initialize 方法，执行完后，再执行所有 wrapper 的 close 方法。这就是 React 中的事务机制。\n“同步现象”的本质 下面结合对事务机制的理解，我们继续来看在 ReactDefaultBatchingStrategy 这个对象。ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。\n1 2 3 4 5 6 7 8 9 10 11 var RESET_BATCHED_UPDATES = { initialize: emptyFunction, close: function () { ReactDefaultBatchingStrategy.isBatchingUpdates = false; }, }; var FLUSH_BATCHED_UPDATES = { initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates), }; var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; 我们把这两个 wrapper 套进 Transaction 的执行机制里，不难得出一个这样的流程：\n到这里，相信你对 isBatchingUpdates 管控下的批量更新机制已经了然于胸。但是 setState 为何会表现同步这个问题，似乎还是没有从当前展示出来的源码里得到根本上的回答。这是因为 batchedUpdates 这个方法，不仅仅会在 setState 之后才被调用。若我们在 React 源码中全局搜索 batchedUpdates，会发现调用它的地方很多，但与更新流有关的只有这两个地方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ReactMount.js _renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) { // 实例化组件 var componentInstance = instantiateReactComponent(nextElement); // 初始渲染直接调用 batchedUpdates 进行同步渲染 ReactUpdates.batchedUpdates( batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context ); ... } 这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次 batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用 setState。因此，我们需要通过开启 batch 来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始渲染流程中所有的 setState 都是生效的。\n下面代码是 React 事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。\n1 2 3 4 5 6 7 8 9 10 11 // ReactEventListener.js dispatchEvent: function (topLevelType, nativeEvent) { ... try { // 处理事件 ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); } finally { TopLevelCallbackBookKeeping.release(bookKeeping); } } 话说到这里，一切都变得明朗了起来：isBatchingUpdates 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 悄悄修改为了 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。\n以开头示例中的 increment 方法为例，整个过程像是这样：\n1 2 3 4 5 6 7 8 9 10 11 increment = () =\u0026gt; { // 进来先锁上 isBatchingUpdates = true; console.log(\u0026#34;increment setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;increment setState后的count\u0026#34;, this.state.count); // 执行完函数再放开 isBatchingUpdates = false; }; 很明显，在 isBatchingUpdates 的约束下，setState 只能是异步的。而当 setTimeout 从中作祟时，事情就会发生一点点变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 reduce = () =\u0026gt; { // 进来先锁上 isBatchingUpdates = true; setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); // 执行完函数再放开 isBatchingUpdates = false; }; 会发现，咱们开头锁上的那个 isBatchingUpdates，对 setTimeout 内部的执行逻辑完全没有约束力。因为 isBatchingUpdates 是在同步代码中变化的，而 setTimeout 的逻辑是异步执行的。当 this.setState 调用真正发生的时候，isBatchingUpdates 早已经被重置为了 false，这就使得当前场景下的 setState 具备了立刻发起同步更新的能力。所以咱们前面说的没错——setState 并不是具备同步这种特性，只是在特定的情境下，它会从 React 的异步管控中“逃脱”掉。\n","permalink":"https://zzydev.top/posts/headfirstreact/8_setstate%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/","summary":"从一道面试题说起 其他 setState 原理的文章 本文的 online Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49","title":"8.SetState是同步的还是异步的？"},{"content":"调和（Reconciliation）过程与 Diff 算法 Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。 ——— React 官方\nReconciler（调和器）所做的工作是一系列的，包括组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用。\nDiff 策略的设计思想 React 团队结合设计层面的一些推导，为将 O (n3) 复杂度转换成 O (n) 复杂度确立了大前提，总结了以下两个规律，：\n若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构； 处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。 除了这两个“板上钉钉”的规律之外，还有一个和实践结合比较紧密的规律，它为 React 实现高效的 Diff 提供了灵感：DOM 节点之间的跨层级操作并不多，同层级操作是主流。\n把握三个“要点”，图解 Diff 逻辑 1. 改变时间复杂度量级的决定性思路：分层对比 结合“DOM 节点之间的跨层级操作并不多，同层级操作是主流”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比，如下图所示。这样一来，只需要从上到下的一次遍历，就可以完成对整棵树的对比，这是降低复杂度量级方面的一个最重要的设计。\n需要注意的是：虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转的，分层递归也是递归\n那么如果真的发生了跨层级的节点操作（比如将以 B 节点为根节点的子树从 A 节点下面移动到 C 节点下面，如下图所示）会怎样呢？很遗憾，作为“次要矛盾”，在这种情况下 React 并不能够判断出“移动”这个行为，它只能机械地认为移出子树那一层的组件消失了，对应子树需要被销毁；而移入子树的那一层新增了一个组件，需要重新为其创建一棵子树。\n销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性。\n2. 减少递归的“一刀切”策略：类型的一致性决定递归的必要性 结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，我们虽不能直接反推出“不同类型的组件 DOM 结构不同”，但在大部分的情况下，这个结论都是成立的。毕竟，实际开发中遇到两个 DOM 结构完全一致、而类型不一致的组件的概率确实太低了。\n本着抓“主要矛盾”的基本原则，React 认为，只有同类型的组件，才有进一步对比的必要性；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点，如下图所示。只有确认组件类型相同后，React 才会在保留组件对应 DOM 树（或子树）的基础上，尝试向更深层次去 Diff。\n这样一来，便能够从很大程度上减少 Diff 过程中冗余的递归操作。\n3. 重用节点的好帮手：key 属性帮 React “记住”节点 key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。 ——— React 对 key 的定义\n它试图解决的是同一层级下节点的重用问题。在展开分析之前，我们先结合到现在为止对 Diff 过程的理解，来思考这样一种情况，如下图所示：\n图中 A 组件在保持类型和其他属性均不变的情况下，在两个子节点（B 和 D）之间插入了一个新的节点（C）。按照已知的 Diff 原则，两棵树之间的 Diff 过程应该是这样的：\n首先对比位于第 1 层的节点，发现两棵树的节点类型是一致的（都是 A），于是进一步 Diff； 开始对比位于第 2 层的节点，第 1 个接受比较的是 B 这个位置，对比下来发现两棵树这个位置上的节点都是 B，没毛病，放过它； 第 2 个接受比较的是 D 这个位置，对比 D 和 C，发现前后的类型不一致，直接删掉 D 重建 C； 第 3 个接受比较的是 E 这个位置，对比 E 和 D，发现前后的类型不一致，直接删掉 E 重建 D； 最后接受“比较”的是树 2 的 E 节点这个位置，这个位置在树 1 里是空的，也就是说树 2 的 E 是一个新增节点，所以新增一个 E。 奇怪的事情发生了：C、D、E 三个节点，其实都是可以直接拿来用的。原本新增 1 个节点就能搞定的事情，现在却又是删除又是重建地搞了半天，而且这个蠢操作和跨层级移动节点还不太一样，后者本来就属于低频操作，加以合理的最佳实践约束一下基本上可以完全规避掉；但图示的这种插入节点的形式是高频操作。频繁增删节点必定拖垮性能，这时候就需要请出 key 属性来帮我们重用节点了。\nkey 属性的形式，我们肯定都不陌生。在基于数组动态生成节点时，我们一般都会给每个节点加装一个 key 属性（下面是一段代码示例）：\n1 const todoItems = todos.map((todo) =\u0026gt; \u0026lt;li key={todo.id}\u0026gt;{todo.text}\u0026lt;/li\u0026gt;); 如果你忘记写 key，React 虽然不至于因此报错，但控制台标红是难免的，它会给你抛出一个“请给列表元素补齐 key 属性”的 warning，这个常见的 warning 也从侧面反映出了 key 的重要性。事实上，当我们没有设定 key 值的时候，Diff 的过程就正如上文所描述的一样惨烈。但只要你按照规范加装一个合适的 key，这个 key 就会像一个记号一样，帮助 React “记住”某一个节点，从而在后续的更新中实现对这个节点的追踪。比如说刚刚那棵虚拟 DOM 树，若我们给位于第 2 层的每一个子节点一个 key 值，如下图所示：\n这个 key 就充当了每个节点的 ID（唯一标识），有了这个标识之后，当 C 被插入到 B 和 D 之间时，React 并不会再认为 C、D、E 这三个坑位都需要被重建——它会通过识别 ID，意识到 D 和 E 并没有发生变化（D 的 ID 仍然是 1，E 的 ID 仍然是 2），而只是被调整了顺序而已。接着，React 便能够轻松地重用它“追踪”到旧的节点，将 D 和 E 转移到新的位置，并完成对 C 的插入。这样一来，同层级下元素的操作成本便大大降低。\n作为一个节点的唯一标识，在使用 key 之前，请务必确认 key 的唯一和稳定。\n","permalink":"https://zzydev.top/posts/headfirstreact/7_react%E4%B8%AD%E7%9A%84%E6%A0%88%E8%B0%83%E5%92%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/","summary":"调和（Reconciliation）过程与 Diff 算法 Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中","title":"7.React中的栈调和过程是怎样的？"},{"content":"React 中的虚拟 DOM 大致是如何工作的? 挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；\n更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM\n模板引擎与虚拟 DOM 有哪些区别？ 模板引擎的更新方式是将已经渲染出来的 DOM 整体注销后整体重新渲染。\nVDOM 的区别就在于多出了一层虚拟 DOM 作为缓冲层。这个缓冲层带来的利好是：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“差量更新”。这个过程对应的虚拟 DOM 工作流如下图所示：\nReact 选用虚拟 DOM，真的是为了更好的性能吗？\n虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。\n虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级。\n那么虚拟 DOM 的价值到底是什么呢？ 研发体验/研发效率的问题：这一点前面已经反复强调过，DOM 操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。 跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是真实 DOM，也可以是 iOS 界面、安卓界面、小程序\u0026hellip;\u0026hellip;同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和 1 是高度呼应的。 ","permalink":"https://zzydev.top/posts/headfirstreact/6_%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdomreact%E9%80%89%E5%AE%83%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%80%A7%E8%83%BD%E5%90%97/","summary":"React 中的虚拟 DOM 大致是如何工作的? 挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）； 更新","title":"6.React是为了更好的性能选择虚拟DOM吗"},{"content":" React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：\n只在 React 函数中调用 Hooks； 不要在循环、条件或嵌套函数中调用 Hooks。 原则 2 中强调的所有“不要”，都是在指向同一个目的，那就是要确保 Hooks 在每次渲染时都保持同样的执行顺序。 PersonalInfoComponent 里去，看看实际项目中，变量到底是怎么发生变化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import React, { useState } from \u0026#34;react\u0026#34;; // isMounted 用于记录是否已挂载（是否是首次渲染） let isMounted = false; function PersonalInfoComponent() { // 定义变量的逻辑不变 let name, age, career, setName, setCareer; // 这里追加对 isMounted 的输出，这是一个 debug 性质的操作 console.log(\u0026#34;isMounted is\u0026#34;, isMounted); // 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态 if (!isMounted) { // eslint-disable-next-line [name, setName] = useState(\u0026#34;zzy\u0026#34;); // eslint-disable-next-line [age] = useState(\u0026#34;99\u0026#34;); // if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了） isMounted = true; } // 对职业信息的获取逻辑不变 [career, setCareer] = useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); // 这里追加对 career 的输出，这也是一个 debug 性质的操作 console.log(\u0026#34;career\u0026#34;, career); // UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示 return ( \u0026lt;div className=\u0026#34;personalInfo\u0026#34;\u0026gt; {name ? \u0026lt;p\u0026gt;姓名：{name}\u0026lt;/p\u0026gt; : null} {age ? \u0026lt;p\u0026gt;年龄：{age}\u0026lt;/p\u0026gt; : null} \u0026lt;p\u0026gt;职业：{career}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; { setName(\u0026#34;唔知\u0026#34;); }} \u0026gt; 修改姓名 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default PersonalInfoComponent; Hooks 的正常运作，在底层依赖于顺序链表 以 useState 为例，分析 React-Hooks 的调用链路 在这个流程中，useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 进入 mounState 逻辑 function mountState(initialState) { // 将新的 hook 对象追加进链表尾部 var hook = mountWorkInProgressHook(); // initialState 可以是一个回调，若是回调，则取回调执行后的值 if (typeof initialState === \u0026#34;function\u0026#34;) { // $FlowFixMe: Flow doesn\u0026#39;t like mixed types initialState = initialState(); } // 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch const queue = (hook.queue = { last: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), }); // 将 initialState 作为一个“记忆值”存下来 hook.memoizedState = hook.baseState = initialState; // dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么 var dispatch = (queue.dispatch = dispatchAction.bind( null, currentlyRenderingFiber$1, queue )); // 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈 return [hook.memoizedState, dispatch]; } 从这段源码中我们可以看出，mounState 的主要工作是初始化 Hooks。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式。以下是 mountWorkInProgressHook 方法的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function mountWorkInProgressHook() { // 注意，单个 hook 是以对象的形式存在的 var hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理 firstWorkInProgressHook = workInProgressHook = hook; } else { // 若链表不为空，则将 hook 追加到链表尾部 workInProgressHook = workInProgressHook.next = hook; } // 返回当前的 hook return workInProgressHook; } 到这里可以看出，hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联。\n接下来我们再看更新过程的大图：\n根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染。\n我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。\n看到这里，你是不是已经大概知道怎么回事儿了？没错，hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的。\n这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。Hooks 的本质其实是链表。\n站在底层视角，重现 PersonalInfoComponent 从代码里面，我们可以提取出来的 useState 调用有三个：\n1 2 3 [name, setName] = useState(\u0026#34;zzy\u0026#34;); [age] = useState(\u0026#34;99\u0026#34;); [career, setCareer] = useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); 当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：\n1 useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); 链表此时的状态如下图所示：\n更新（二次渲染）的时候会发生什么事情：updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它会认为：你想要的是第一个位置的 hook 。\n然后就会有下面这样的效果：\n","permalink":"https://zzydev.top/posts/headfirstreact/5_%E6%B7%B1%E5%85%A5react-hooks%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/","summary":"React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下： 只在 React 函数中调用 Hooks； 不要在循环、条件或嵌套函数中调用 Hooks。 原则 2 中强调","title":"5.深入React Hooks工作机制,Hooks本质是链表"},{"content":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。\n如果你在这个在线 Demo中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：\n明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！\n这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？\n因为虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。\n多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。\n但如果我们把 ProfilePage 改造为一个像这样的函数组件：\n1 2 3 4 5 6 7 8 9 function ProfilePage(props) { const showMessage = () =\u0026gt; { alert(\u0026#34;Followed \u0026#34; + props.user); }; const handleClick = () =\u0026gt; { setTimeout(showMessage, 3000); }; return \u0026lt;button onClick={handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt;; } 事情就会大不一样。\nprops 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。\n总结：“函数组件会捕获 render 内部的状态”，函数组件真正地把数据和渲染绑定到了一起。\n函数组件是一个更加匹配 React 设计理念、也更有利于逻辑拆分与重用的组件表达形式\n从核心 API 看 Hooks 的基本形态 useState()：为函数组件引入状态 1 2 3 4 5 6 7 8 9 10 11 12 const [state, setState] = useState(initialState); //状态和修改状态的 API 名都是可以自定义的 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;); //它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值 // 定义为数组 const [author, setAuthor] = useState([\u0026#34;zzydev\u0026#34;, \u0026#34;zzy\u0026#34;]); // 定义为数值 const [length, setLength] = useState(100); // 定义为字符串 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;); state 中永远不要保存可以通过计算得到的值。 比如：\n从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。 从 URL 中读到的值。有时我们要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候，从 URL 中读取，而不是读出来放在 state 中。 从 cookie、localStorage 中读取的值。通常每次要用的时候直接去读取，而不是读出来放到 state 中。 state 虽然便于维护状态，但也有自己的弊端。一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。\nuseEffect()：允许函数组件执行副作用操作 useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。\nuseEffect 是每次组件 render 完后判断依赖并执行\n没有依赖项，则每次 render 后都会重新执行。 1 2 3 4 useEffect(() =\u0026gt; { // 每次 render 完都会执行 console.log(\u0026#34;re-rendered\u0026#34;); }); 仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组作为依赖项。对应到 Class 组件就是 componentDidMount。 1 2 3 4 useEffect(() =\u0026gt; { // 这里是业务逻辑 console.log(\u0026#34;did mount\u0026#34;); }, []); 仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。这个机制就几乎等价于类组件中的 componentWillUnmount。 1 2 3 4 5 6 useEffect(() =\u0026gt; { // 这里是 A 的业务逻辑 // 返回一个函数记为 B return () =\u0026gt; {}; }, []); useEffect 回调中返回的函数被称为“清除函数”，当 React 识别到清除函数时，会在卸载时执行清除函数内部的逻辑。这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理。\n每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。 1 2 3 4 5 6 7 useEffect(() =\u0026gt; { // 这里是 A 的业务逻辑 // 返回一个函数记为 B return () =\u0026gt; {}; }); //React 在每一次渲染都去触发 A 逻辑，并且在下一次 A 逻辑被触发之前去触发 B 逻辑。 根据一定的依赖条件来触发的副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述），同时传入一个非空的数组。 1 2 3 4 5 6 7 8 9 10 11 12 useEffect(() =\u0026gt; { // 这是回调函数的业务逻辑 // 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发 return xxx; }, [num1, num2, num3]); /* 数组中的变量一般都是来源于组件本身的数据（props 或者 state）。 若数组不为空，那么 React 就会在新的一次渲染后去对比前后两次的渲染， 查看数组内是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了）， 并在有更新的前提下去触发 useEffect 中定义的副作用逻辑。 */ 理解 Hooks 的依赖 Hooks(useEffect、useCallback、useMemo) 提供了让你监听某个数据变化的能力。这个变化可能会触发组件的刷新，也可能是去创建一个副作用，又或者是刷新一个缓存。那么定义要监听哪些数据变化的机制，其实就是指定 Hooks 的依赖项。\n那么在定义依赖项时，我们需要注意以下三点：\n依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。 依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。 React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方。例如下面的代码： 1 2 3 4 5 6 7 function Sample() { // 这里在每次组件执行时创建了一个新数组 const todos = [{ text: \u0026#34;Learn hooks.\u0026#34; }]; useEffect(() =\u0026gt; { console.log(\u0026#34;Todos changed.\u0026#34;); }, [todos]); } 代码的原意可能是在 todos 变化的时候去产生一些副作用，但是这里的 todos 变量是在函数内创建的，实际上每次都产生了一个新数组。所以在作为依赖项的时候进行引用的比较，实际上被认为是发生了变化的。\nReact 为什么要发明 Hooks 告别难以理解的 Class: Class 的“痛点”:\n生命周期\n生命周期的带来的麻烦提现在：学习成本和不合理的逻辑规划方式 React 组件之间是不会相互继承的\n比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 组件来继承 Button。React 实际上没利用到 Class 的继承特性的。 UI 由状态驱动，很少在外部调用类实例（即组件）的方法。\n组件所有的方法都是在类内部调用或者作为生命周期函数被自动调用。 this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Example extends Component { state = { name: \u0026#39;zzydev\u0026#39;, age: \u0026#39;99\u0026#39;; }; changeAge() { // 这里会报错 this.setState({ age: \u0026#39;100\u0026#39; }); } render() { return \u0026lt;button onClick={this.changeAge}\u0026gt;{this.state.name}的年龄是{this.state.age}\u0026lt;/button\u0026gt; } } changeAge 这个方法：它是 button 按钮的事件监听函数。当我点击 button 按钮时，希望它能够帮我修改状态，但事实是，点击发生后，程序会报错。原因很简单，changeAge 里并不能拿到组件实例的 this。为了解决 this 不符合预期的问题，可以使用 this.changeAga = this.changeAga.bind(this) 或 箭头函数的方式，但这两种方式 本质上都是在用实践层面的约束来解决设计层面的问题\nHooks 如何实现更好的逻辑拆分 过去我们组织自己业务逻辑的方式：先想清楚业务的需要是什么样的，然后将对应的业务逻辑拆到不同的生命周期函数里去。逻辑与生命周期耦合在一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 componentDidMount() { // 1. 这里发起异步调用 // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM // 3. 这里设置一个订阅 // 4. 这里随便干点别的什么 // ... } componentWillUnMount() { // 在这里卸载订阅 } componentDidUpdate() { // 1. 在这里根据 DidMount 获取到的异步数据更新 DOM // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样） } 像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。\n而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。\n状态复用：Hooks 将复杂的问题变简单 过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。\nHooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。\nReact Hooks 的局限性 Hooks 暂时还不能完全地为函数组件补齐类组件的能力 比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。\nHooks 在使用层面有着严格的规则约束 Hooks 的使用规则包括以下两个: 只能在函数组件的顶级作用域使用；只能在函数组件或者其他 Hooks 中使用。 所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。Hooks 使用规则背后的”原理“\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function MyComp() { const [count, setCount] = useState(0); if (count \u0026gt; 10) { // ⚠️ 错误：不能将 Hook 用在条件判断里 useEffect(() =\u0026gt; { // ... }, [count]); } // ⚠️ 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了 if (count === 0) { return \u0026#34;No content\u0026#34;; } // ⚠️ 错误：不能将 Hook 放在可能的 return 之后 const [loading, setLoading] = useState(false); //... return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; } Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，一种是在函数组件内，另外一种则是在自定义的 Hooks 里面。 但是如果一定要在 Class 组件中使用，那应该如何做呢？其实有一个通用的机制，那就是利用高阶组件的模式，将 Hooks 封装成高阶组件，从而让类组件使用。 举个例子。我们已经定义了监听窗口大小变化的一个 Hook：useWindowSize。那么很容易就可以将其转换为高阶组件：\n1 2 3 4 5 6 7 8 9 import React from \u0026#34;react\u0026#34;; import { useWindowSize } from \u0026#34;../hooks/useWindowSize\u0026#34;; export const withWindowSize = (Comp) =\u0026gt; { return (props) =\u0026gt; { const windowSize = useWindowSize(); return \u0026lt;Comp windowSize={windowSize} {...props} /\u0026gt;; }; }; 那么我们就可以通过如下代码来使用这个高阶组件：\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34;; import { withWindowSize } from \u0026#34;./withWindowSize\u0026#34;; class MyComp { render() { const { windowSize } = this.props; // ... } } // 通过 withWindowSize 高阶组件给 MyComp 添加 windowSize 属性 export default withWindowSize(MyComp); 这样，通过 withWindowSize 这样一个高阶组件模式，你就可以把 useWindowSize 的结果作为属性，传递给需要使用窗口大小的类组件，这样就可以实现在 Class 组件中复用 Hooks 的逻辑了。\n使用 ESLint 插件帮助检查 Hooks 的使用 1 yarn add eslint-plugin-react-hooks -S 然后在你的 ESLint 配置文件中加入两个规则：rules-of-hooks 和 exhaustive-deps。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;plugins\u0026#34;: [ // ... \u0026#34;react-hooks\u0026#34; ], \u0026#34;rules\u0026#34;: { // ... // 检查 Hooks 的使用规则 \u0026#34;react-hooks/rules-of-hooks\u0026#34;: \u0026#34;error\u0026#34;, // 检查依赖项的声明 \u0026#34;react-hooks/exhaustive-deps\u0026#34;: \u0026#34;warn\u0026#34; } } ","permalink":"https://zzydev.top/posts/headfirstreact/4_react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","summary":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用","title":"4.React Hooks设计动机与工作模式"},{"content":"React 的核心特征是“数据驱动视图”，即 UI = render(data)\n基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。 父子组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 子组件 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } //父组件 class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34;, }; // 按钮的监听函数，用于更新 text 值 changeText = () =\u0026gt; { this.setState({ text: \u0026#34;改变后的父组件文本\u0026#34;, }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;button onClick={this.changeText}\u0026gt; 点击修改父组件传入子组件的文本 \u0026lt;/button\u0026gt; {/* 引入子组件，并通过 props 下发具体的状态值实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 子-父组件通信 考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。假如父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，以此来间接地实现数据从子组件到父组件的流动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Child extends React.Component { // 初始化子组件的 state state = { text: \u0026#39;子组件的文本\u0026#39; } // 子组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text) } render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本的动作放在了 Child 里 */} \u0026lt;button onClick={this.changeText}\u0026gt; 点击更新父组件的文本 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 这个方法会作为 props 传给子组件，用于更新父组件 text 值。newText 正是开放给子组件的数据通信入口 changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`父组件的文本内容是：[${this.state.text}]`}\u0026lt;/p\u0026gt; {/* 引入子组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;Child changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } 兄弟组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } class NewChild extends React.Component { state = { text: \u0026#34;来自 newChild 的文本\u0026#34;, }; // NewChild 组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text); }; render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本（同时也是 Child 组件的文本）的动作放在了 NewChild 里 */} \u0026lt;button onClick={this.changeText}\u0026gt;点击更新 Child 组件的文本\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34;, }; // 传给 NewChild 组件按钮的监听函数，用于更新父组件 text 值（这个 text 值同时也是 Child 的 props） changeText = (newText) =\u0026gt; { this.setState({ text: newText, }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; {/* 引入 Child 组件，并通过 props 中下发具体的状态值 实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; {/* 引入 NewChild 组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;NewChild changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 利用“发布-订阅”模式驱动数据流 使用发布-订阅模式的优点在于，监听事件的位置和触发事件的位置是不受限的，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。\n发布-订阅模型 API 设计思路 on()：负责注册事件的监听器，指定事件触发时的回调函数。 emit()：负责触发事件，可以通过传参使其在触发的时候携带数据 。 off()：负责监听器的删除。 发布-订阅模型编码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class myEventEmitter { constructor() { // eventMap 用来存储事件和监听函数之间的关系 this.eventMap = {}; } // type 这里就代表事件的名称 on(type, handler) { // hanlder 必须是一个函数，如果不是直接报错 if (!(handler instanceof Function)) { throw new Error(\u0026#34;hanlder必须是一个函数\u0026#34;); } // 判断 type 事件对应的队列是否存在 if (!this.eventMap[type]) { // 若不存在，新建该队列 this.eventMap[type] = []; } // 若存在，直接往队列里推入 handler this.eventMap[type].push(handler); } // 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体 emit(type, params) { // 假设该事件是有订阅的（对应的事件队列存在） if (this.eventMap[type]) { // 将事件队列里的 handler 依次执行出队 this.eventMap[type].forEach((handler, index) =\u0026gt; { // 注意别忘了读取 params handler(params); }); } } off(type, handler) { if (this.eventMap[type]) { // indexOf找不到元素会返回-1，splice从右往左截取，右移运算会将-1变成4294967295 this.eventMap[type].splice(this.eventMap[type].indexOf(handler) \u0026gt;\u0026gt;\u0026gt; 0, 1); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 注意这个 myEvent 是提前实例化并挂载到全局的，此处不再重复示范实例化过程 const globalEvent = window.myEvent; class B extends React.Component { // 这里省略掉其他业务逻辑 state = { newParams: \u0026#34;\u0026#34;, }; handler = (params) =\u0026gt; { this.setState({ newParams: params, }); }; bindHandler = () =\u0026gt; { globalEvent.on(\u0026#34;someEvent\u0026#34;, this.handler); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.bindHandler}\u0026gt;点我监听A的动作\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;A传入的内容是[{this.state.newParams}]\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } } class A extends React.Component { // 这里省略掉其他业务逻辑 state = { infoToB: \u0026#34;哈哈哈哈我来自A\u0026#34;, }; reportToB = () =\u0026gt; { // 这里的 infoToB 表示 A 自身状态中需要让 B 感知的那部分数据 globalEvent.emit(\u0026#34;someEvent\u0026#34;, this.state.infoToB); }; render() { return \u0026lt;button onClick={this.reportToB}\u0026gt;点我把state传递给B\u0026lt;/button\u0026gt;; } } export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;/div\u0026gt; ); } 使用 Context 维护全局状态 useContext\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //作用是创建一个context对象,可以选择性地传入一个defaultValue const AppContext = React.createContext(defaultValue) //从创建出的context对象中，可以读取到 Provider 和 Consumer const { Provider, Consumer } = AppContext //使用 Provider 对组件树中的根组件进行包裹， //然后传入名为“value”的属性，这个 value 就是后续在组件树中流动的“数据”， //它可以被 Consumer 消费。 \u0026lt;Provider value={title: this.state.title, content: this.state.content}\u0026gt; \u0026lt;Title /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/Provider\u0026gt; //Consumer，顾名思义就是“数据的消费者”，它可以读取 Provider 下发下来的数据 //其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。 \u0026lt;Consumer\u0026gt; {value =\u0026gt; \u0026lt;div\u0026gt;{value.title}\u0026lt;/div\u0026gt;} \u0026lt;/Consumer\u0026gt; //注意: 当 Consumer 没有对应的 Provider 时， //value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。 Redux createStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const createStore = (reducer, enhancer) =\u0026gt; { if (enhancer) { return enhancer(createStore)(reducer); } let currentState = void 0; let currentListeners = []; const getState = () =\u0026gt; currentState; const dispatch = (action) =\u0026gt; { currentState = reducer(currentState, action); currentListeners.forEach((listener) =\u0026gt; listener()); }; const subscribe = (listener) =\u0026gt; { currentListeners.push(listener); return () =\u0026gt; { const index = currentListeners.indexOf(listener); currentListeners.splice(index, 1); }; }; //手动触发一次订阅，加上默认值 dispatch({ type: \u0026#34;@z—redux/INIT\u0026#34; }); return { getState, dispatch, subscribe, }; }; export default createStore; applyMiddleware.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const applyMiddleware = (...middleware) =\u0026gt; { return (createStore) =\u0026gt; (reducer) =\u0026gt; { const store = createStore(reducer); let dispatch = store.dispatch; const midApi = { getState: store.getState, dispatch: (action, ...args) =\u0026gt; dispatch(action, ...args), }; const chain = middleware.map((middleware) =\u0026gt; middleware(midApi)); dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch, }; }; }; const compose = (...funcs) =\u0026gt; { if (funcs.length === 0) { return (arg) =\u0026gt; arg; } if (funcs.length === 1) { return funcs[0]; } return funcs.reduce( (a, b) =\u0026gt; (...args) =\u0026gt; a(b(...args)) ); }; export default applyMiddleware; combineReducer.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const combineReducers = (reducers) =\u0026gt; (state = {}, action) =\u0026gt; { let nextState = {}; let hasChange = false; for (let key in reducers) { const reducer = reducers[key]; nextState[key] = reducer(state[key], action); hasChange = hasChange || nextState[key] !== state[key]; } hasChange = hasChange || Object.keys(nextState) !== Object.keys(state); return hasChange ? nextState : state; }; export default combineReducers; React-Redux 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import { useReducer } from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; import { useCallback, useState, useEffect, useLayoutEffect, useContext, } from \u0026#34;react\u0026#34;; const Context = React.createContext(); export const Provider = ({ store, children }) =\u0026gt; { return \u0026lt;Context.Provider value={store}\u0026gt;{children}\u0026lt;/Context.Provider\u0026gt;; }; export const connect = (mapStateToProps = (state) =\u0026gt; state, mapDispatchToProps) =\u0026gt; (WrapperComponent) =\u0026gt; (props) =\u0026gt; { const store = useContext(Context); const { getState, dispatch, subscribe } = store; const stateProps = mapStateToProps(getState()); let dispatchProps = { dispatch }; if (typeof mapDispatchToProps === \u0026#34;object\u0026#34;) { dispatchProps = { ...bindActionCreators(mapDispatchToProps, dispatch), dispatch, }; } else if (typeof mapDispatchToProps === \u0026#34;function\u0026#34;) { dispatchProps = mapDispatchToProps(dispatch); } const forceUpdate = useForceUpdate(); useLayoutEffect(() =\u0026gt; { const unsubscribe = subscribe(() =\u0026gt; { forceUpdate(); }); return () =\u0026gt; { if (unsubscribe) { unsubscribe(); } }; }, []); return \u0026lt;WrapperComponent {...props} {...stateProps} {...dispatchProps} /\u0026gt;; }; function bindActionCreator(creator, dispatch) { return (...args) =\u0026gt; dispatch(creator(...args)); } export const bindActionCreators = (creators, dispatch) =\u0026gt; { let obj = {}; for (let key in creators) { obj[key] = bindActionCreator(creators[key], dispatch); } return obj; }; const useForceUpdate = () =\u0026gt; { const [state, setState] = useState(0); //const [, setState] = useReducer((prev) =\u0026gt; prev + 1, 0); const update = useCallback(() =\u0026gt; { setState((prev) =\u0026gt; prev + 1); }, []); return update; }; ","permalink":"https://zzydev.top/posts/headfirstreact/3_%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8react%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%E7%9A%84/","summary":"React 的核心特征是“数据驱动视图”，即 UI = render(data) 基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更","title":"3.数据是如何在React组件之间流动的？"},{"content":"React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”。\n注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来做的。\ncomponentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里执行真实 DOM 相关的操作，类似于发起异步请求、数据初始化这样的操作也大可以放在这个生命周期来做。\nUpdating 阶段：组件的更新 componentWillReceiProps(nextProps) 是由什么触发的？ 在这个生命周期方法里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）可以通过 this.props 拿到，由此便能够感知到 props 的变化。\ncomponentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。\n如果父组件导致组件重新渲染，即使 props 没有更改也会调用此方法（componentWillReceiveProps） 如果只想处理更改，请确保当前值与变更值的比较\n\u0026mdash;\u0026mdash; React 官方\n组件自身 setState 触发的更新 componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。\nrender 与性能： shouldComponentUpdate(nextProps, nextState) React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行re-render（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。\nUnmounting 阶段：组件的卸载 组件销毁的常见原因有以下两个。\n组件在父组件中被移除了：这种情况相对比较直观 组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被销毁。 React16 的生命周期 推荐 👉🏻 React16 生命周期图示\nMounting 阶段：组件的初始化渲染 认识 getDerivedStateFromProps(props,state) getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉componentWillMount ，而是试图替换掉 componentWillReceiveProps，因此它有且仅有一个用途:使用 props 来派生/更新 state\ngetDerivedStateFromProps 是一个静态方法，静态方法不依赖组件实例而存在，因此在这个方法内部是访问不到 this 的。\n该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。\ngetDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番。\ngetDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：\n1 2 3 { fatherText: props.text; } 该对象并不会替换掉组件原始的这个 state：\n1 this.state = { text: \u0026#34;子组件的文本\u0026#34; }; 而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示： Updating 阶段：组件的更新 React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：\n在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；\n而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。\n为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？ 做合理的减法：\ngetDerivedStateFromProps 直接被定义为 static 方法，static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。 这是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。 消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate 方法需要一个返回值，它的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state\u0026amp;props 的信息。\n重点把握它与 componentDidUpdate 间的通信过程：\n1 2 3 4 5 6 7 8 9 10 11 // 组件更新时调用 getSnapshotBeforeUpdate(prevProps, prevState) { console.log(\u0026#34;getSnapshotBeforeUpdate方法执行\u0026#34;); return \u0026#34;haha\u0026#34;; } // 组件更新后调用 componentDidUpdate(prevProps, prevState, valueFromSnapshot) { console.log(\u0026#34;componentDidUpdate方法执行\u0026#34;); console.log(\u0026#34;从 getSnapshotBeforeUpdate 获取到的值是\u0026#34;, valueFromSnapshot); } 这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。\nReact16 为何两次求变？ Fiber 会使原本同步的渲染过程变成异步的。 同步更新与异步更新对比 Demo\n同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，调度器会看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”。\n换个角度看生命周期工作流 Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：\n总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。\n为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，这个过程必须用同步渲染。\n生命周期变更的考量 在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。\n带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：\ncomponentWillMount； componentWillUpdate； componentWillReceiveProps。 这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。\n在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:\nsetState()； fetch 发起异步请求； 操作真实 DOM。 这些操作的问题（或不必要性）包括但不限于以下 3 点：\n完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做。\n比如在 componentWillMount 里发起异步请求，以为这样做就可以更快得到异步请求返回的结果，从而避免首次渲染白屏。\n但是（React 15 下）同步的生命周期函数必然先于异步请求执行。componentWillMount 结束后，render 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题。\n在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。\n比如在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。\n又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。\ngetDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了———避免开发者触碰 this，就是在避免各种危险的错误操作。\n即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。\n比如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。\n总的来说，React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制。在这个改造的过程中，React 团队针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也 确保了生命周期方法的行为更加纯粹、可控、可预测 。\n","permalink":"https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”","title":"2.React生命周期"},{"content":" JSX 的本质：JavaScript 的语法糖 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。\nBabel 具备将 JSX 语法转换为 javascript 的能力\nBabel 的在线 playground\nJSX 是如何映射为 DOM 的 createElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //React的创建元素方法 export function createElement(type, config, children) { // propName 变量用于储存后面需要用到的元素属性 let propName; // props 变量用于储存元素属性的键值对集合 const props = {}; // key、ref、self、source 均为 React 元素的属性，此处不必深究 let key = null; let ref = null; let self = null; let source = null; // config 对象中存储的是元素的属性 if (config != null) { // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值 if (hasValidRef(config)) { ref = config.ref; } // 此处将 key 值转换为字符串 if (hasValidKey(config)) { key = \u0026#34;\u0026#34; + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面 for (propName in config) { if ( // 筛选出可以提进 props 对象里的属性 hasOwnProperty.call(config, propName) \u0026amp;\u0026amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度 const childrenLength = arguments.length - 2; // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了 if (childrenLength === 1) { // 直接把这个参数的值赋给props.children props.children = children; // 处理嵌套多个子元素的情况 } else if (childrenLength \u0026gt; 1) { // 声明一个子元素数组 const childArray = Array(childrenLength); // 把子元素推进数组里 for (let i = 0; i \u0026lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } // 最后把这个数组赋值给props.children props.children = childArray; } // 处理 defaultProps if (type \u0026amp;\u0026amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props ); } createElement 入参解析 1 export function createElement(type, config, children) type：用于标识节点的类型。它可以是类似“h1”、“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。 config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。 children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。 createElement 函数拆解 createElement 的每一个步骤几乎都是在格式化数据\ncreateElement 就像是开发者和 ReactElement 调用之间的一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。整个过程如下图所示：\ncreateElement 出参解析 ReactElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const ReactElement = function (type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; if (DEV) { /*这里是一些针对 __DEV__ 环境下的处理，对于理解主要逻辑意义不大，故省略*/ } return element; }; 打印输出 JSX 部分：\n1 2 3 4 5 6 7 8 const AppJSX = ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt;I am the title\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;content\u0026#34;\u0026gt;I am the content\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); console.log(AppJSX); 你会发现它确实是一个标准的 ReactElement 对象实例，如下图：\n这个 ReactElement 对象实例，本质上是 以 JavaScript 对象形式存在的对 DOM 的描述 ，也就是 虚拟 DOM 中的一个节点 。\nReact 提供了验证合法 React Element 的全局 API React.isValidElement，我们看下他的实现：\n1 2 3 4 5 6 7 export function isValidElement(object) { return ( typeof object === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; object !== null \u0026amp;\u0026amp; object.$$typeof === REACT_ELEMENT_TYPE ); } “虚拟 DOM”需要通过 ReactDOM.render方法，变成渲染到页面上的真实 DOM\n","permalink":"https://zzydev.top/posts/headfirstreact/1_jsx%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E4%B8%BAdom%E7%9A%84/","summary":"JSX 的本质：JavaScript 的语法糖 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的","title":"1.JSX 是如何变成为 DOM 的"}]