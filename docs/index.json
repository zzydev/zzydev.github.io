[{"content":"原题链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; for (auto p = dummy;;) { auto q = p; for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; q; i ++) q = q-\u0026gt;next; if (!q) break; auto a = p-\u0026gt;next, b = a-\u0026gt;next; for (int i = 0; i \u0026lt; k - 1; i ++) { auto c = b-\u0026gt;next; b-\u0026gt;next = a; a = b, b = c; } auto c = p-\u0026gt;next; p-\u0026gt;next = a, c-\u0026gt;next = b; p = c; } return dummy-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc25_k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"原题链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next)","title":"Lc25_K个一组翻转链表"},{"content":"原题链接\n迭代以下过程：\n创建虚拟头节点dummy，让 p 指针指向 dummy 让a指针指向p→next，让b指针指向a→next 让p指向a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; ListNode* p = dummy; while (p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;next) { ListNode* a = p-\u0026gt;next; ListNode* b = a-\u0026gt;next; p-\u0026gt;next = b; a-\u0026gt;next = b-\u0026gt;next; b-\u0026gt;next = a; p = a; } return dummy-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc24_%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","summary":"原题链接 迭代以下过程： 创建虚拟头节点dummy，让 p 指针指向 dummy 让a指针指向p→next，让b指针指向a→next 让p指向a 1 2 3 4 5 6 7 8 9","title":"Lc24_两两交换链表中的节点"},{"content":"原题链接\n使用优先队列，将所有链表的头指针加入到优先队列中（小根堆） 当小根堆不为空时，每次将堆顶元素t放入新构建的链表中，再将t的下一个节点加入到小根堆中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct Cmp { bool operator() (ListNode* a, ListNode* b) { return a-\u0026gt;val \u0026gt; b-\u0026gt;val; } }; ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { //默认大根堆 priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, Cmp\u0026gt; heap; auto dummy = new ListNode(-1), tail = dummy; for (ListNode* l : lists) if (l) heap.push(l); while (heap.size()) { auto t = heap.top(); heap.pop(); tail = tail-\u0026gt;next = t; if (t-\u0026gt;next) heap.push(t-\u0026gt;next); } return dummy-\u0026gt;next; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { ListNode* dummy = new ListNode(0); auto cur = dummy; auto cmp = [\u0026amp;](ListNode* a, ListNode* b) { return a-\u0026gt;val \u0026gt; b-\u0026gt;val; }; priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, decltype(cmp)\u0026gt; minheap(cmp); for (int i = 0; i \u0026lt; lists.size(); i ++) { if (lists[i]) minheap.push(lists[i]); } while (minheap.size()) { auto p = minheap.top(); cur-\u0026gt;next = new ListNode(p-\u0026gt;val); cur = cur-\u0026gt;next; minheap.pop(); if (p-\u0026gt;next) minheap.push(p-\u0026gt;next); } return dummy-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc23_%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","summary":"原题链接 使用优先队列，将所有链表的头指针加入到优先队列中（小根堆） 当小根堆不为空时，每次将堆顶元素t放入新构建的链表中，再将t的下一个节点加","title":"Lc23_合并K个升序链表"},{"content":"原题链接\n左括号永远大于等于右括号\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: vector\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; generateParenthesis(int n) { dfs(0, 0, n, \u0026#34;\u0026#34;); return res; } void dfs(int l, int r, int n, string path) { if (r == n) res.push_back(path); if (l \u0026lt; n) dfs(l + 1, r, n, path + \u0026#39;(\u0026#39;); if (r \u0026lt; l \u0026amp;\u0026amp; r \u0026lt; n) dfs(l, r + 1, n, path + \u0026#39;)\u0026#39;); } }; ","permalink":"https://zzydev.top/posts/leetcode/lc22_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","summary":"原题链接 左括号永远大于等于右括号 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: vector\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; generateParenthesis(int n) { dfs(0, 0, n, \u0026#34;\u0026#34;); return res; } void dfs(int l, int r, int n, string path) { if (r == n) res.push_back(path); if (l \u0026lt; n) dfs(l + 1, r, n,","title":"Lc22_括号生成"},{"content":"原题链接\n模拟merge sort\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(0); ListNode* cur = dummy; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { cur-\u0026gt;next = new ListNode(l1-\u0026gt;val); cur = cur-\u0026gt;next; l1 = l1-\u0026gt;next; } else if (l1-\u0026gt;val \u0026gt;= l2-\u0026gt;val) { cur-\u0026gt;next = new ListNode(l2-\u0026gt;val); cur = cur-\u0026gt;next; l2 = l2-\u0026gt;next; } } while (l1) { cur-\u0026gt;next = new ListNode(l1-\u0026gt;val); cur = cur-\u0026gt;next; l1 = l1-\u0026gt;next; } while (l2) { cur-\u0026gt;next = new ListNode(l2-\u0026gt;val); cur = cur-\u0026gt;next; l2 = l2-\u0026gt;next; } return dummy-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc21_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","summary":"原题链接 模拟merge sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() :","title":"Lc21_合并两个有序链表"},{"content":"原题链接\n题解：\n这里给出数组中的括号不全是一样的，所以遍历数组，如果遇到括号 \u0026ldquo;(\u0026rdquo; 、 \u0026ldquo;[\u0026quot;、 \u0026ldquo;{\u0026rdquo; 就放入栈中。 如果不是\u0026rdquo;(\u0026quot;、 \u0026ldquo;[\u0026quot;、 \u0026ldquo;{\u0026rdquo; 这些扩号，就判断如果不是相对应的\u0026rdquo;)\u0026quot; \u0026ldquo;]\u0026rdquo; \u0026ldquo;}\u0026rdquo; 或者栈为空就返回false（说明没有对应的元素）。反之将栈顶元素弹出。 最后遍历完数组，如果栈为空说明数组中的括号是有效的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: bool isValid(string s) { if (s.empty()) return true; if (s.size() % 2 == 1) return false; stack\u0026lt;char\u0026gt; stk; for (size_t i = 0; i \u0026lt; s.size(); i ++) { char c = s[i]; if (c == \u0026#39;(\u0026#39; || c == \u0026#39;{\u0026#39; || c == \u0026#39;[\u0026#39;) { stk.push(c); } else if (c == \u0026#39;)\u0026#39;) { if(stk.empty() || stk.top() != \u0026#39;(\u0026#39;) return false; stk.pop(); } else if (c == \u0026#39;]\u0026#39;) { if(stk.empty() || stk.top() != \u0026#39;[\u0026#39;) return false; stk.pop(); } else if (c == \u0026#39;}\u0026#39;) { if(stk.empty() || stk.top() != \u0026#39;{\u0026#39;) return false; stk.pop(); } else { return false; } } return stk.empty(); } }; ","permalink":"https://zzydev.top/posts/leetcode/lc20_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","summary":"原题链接 题解： 这里给出数组中的括号不全是一样的，所以遍历数组，如果遇到括号 \u0026ldquo;(\u0026rdquo; 、 \u0026ldquo;[\u0026quot;、 \u0026ldquo;{\u0026rdquo; 就放入栈中。 如果不是\u0026rdqu","title":"Lc20_有效的括号"},{"content":"原题链接\n解题思路：\n先求出链表长度 求出要删除节点的位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; auto p = dummy; auto q = p; int len = 0; while (p-\u0026gt;next) { p = p-\u0026gt;next; len ++; } int k = len - n ; for (int i = 0; i \u0026lt; k; i ++) { q = q-\u0026gt;next; } q-\u0026gt;next = q-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc19_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/","summary":"原题链接 解题思路： 先求出链表长度 求出要删除节点的位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; *","title":"Lc19_删除链表的倒数第N个结点"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(),nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int i = 0; i \u0026lt; nums.size(); i ++) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); j ++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; for (int k = j + 1, u = nums.size() - 1; k \u0026lt; u; k++) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) continue; while (u - 1 \u0026gt; k \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k] + nums[u -1] \u0026gt;= target) u--; if (nums[i] + nums[j] + nums[k] + nums[u] == target) { res.push_back({nums[i],nums[j],nums[k],nums[u]}); } } } } return res; } }; lc16_最接近的三数之和\nlc01_两数之和\nlc15_三数之和\n","permalink":"https://zzydev.top/posts/leetcode/lc18_%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(),nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int i = 0; i \u0026lt; nums.size(); i ++) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); j ++) { if (j \u0026gt;","title":"Lc18_四数之和"},{"content":"从一道面试题说起 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; export default class App extends React.Component { state = { count: 0, }; increment = () =\u0026gt; { console.log(\u0026#34;increment setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;increment setState后的count\u0026#34;, this.state.count); }; triple = () =\u0026gt; { console.log(\u0026#34;triple setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); this.setState({ count: this.state.count + 1, }); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;triple setState后的count\u0026#34;, this.state.count); }; reduce = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;点我增加\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.triple}\u0026gt;点我增加三倍\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.reduce}\u0026gt;点我减少\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 异步的动机和原理——批量更新的艺术 从图上我们可以看出，一个完整的更新流程，涉及了包括 re-render（重渲染） 在内的多个步骤。re-render 本身涉及对 DOM 的操作，它会带来较大的性能开销。假如说“一次 setState 就触发一个完整的更新流程”这个结论成立，那么每一次 setState 的调用都会触发一次 re-render，我们的视图很可能没刷新几次就卡死了。这个过程如我们下面代码中的箭头流程图所示：\n1 2 3 4 5 6 7 8 9 this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); 事实上，这正是 setState 异步的一个重要的动机——避免频繁的 re-render。\n在实际的 React 运行时中，setState 异步的实现方式有点类似于 Vue 的 $nextTick 和浏览器里的 Event-Loop：**每来一个 setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。**这个过程，叫作“批量更新”，批量更新的过程正如下面代码中的箭头流程图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count + 1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count + 1的任务，count + 1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队, [count + 1的任务，count + 1的任务, count + 1的任务] }); ↓ 合并 state，[count + 1的任务] ↓ 执行 count + 1的任务 值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。因此就算我们在 React 中写了这样一个 100 次的 setState 循环：\n1 2 3 4 5 6 7 8 9 test = () =\u0026gt; { console.log(\u0026#34;循环100次 setState前的count\u0026#34;, this.state.count); for (let i = 0; i \u0026lt; 100; i++) { this.setState({ count: this.state.count + 1, }); } console.log(\u0026#34;循环100次 setState后的count\u0026#34;, this.state.count); }; 也只是会增加 state 任务入队的次数，并不会带来频繁的 re-render。当 100 次调用结束后，仅仅是 state 的任务队列内容发生了变化， state 本身并不会立刻改变：\n“同步现象”背后的故事：从源码角度看 setState 工作流 读到这里，相信你对异步这回事多少有些眉目了。接下来我们就要重点理解刚刚代码里最诡异的一部分——setState 的同步现象：\n1 2 3 4 5 6 7 8 9 reduce = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); }; 从题目上看，setState 似乎是在 setTimeout 函数的“保护”之下，才有了同步这一“特异功能”。事实也的确如此，假如我们把 setTimeout 摘掉，setState 前后的 console 表现将会与 increment 方法中无异：\n1 2 3 4 5 6 7 8 9 reduce = () =\u0026gt; { // setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); // },0); }; 点击后的输出结果如下图所示：\n现在问题就变得清晰多了：为什么 setTimeout 可以将 setState 的执行顺序从异步变为同步？\n这里我先给出一个结论：并不是 setTimeout 改变了 setState，而是 setTimeout 帮助 setState “逃脱”了 React 对它的管控。只要是在 React 管控下的 setState，一定是异步的。\n接下来我们就从 React 源码里，去寻求佐证这个结论的线索。\n解读 setState 工作流 接下来我们就沿着这个流程，逐个在源码中对号入座。首先是 setState 入口函数：\n1 2 3 4 5 6 ReactComponent.prototype.setState = function (partialState, callback) { this.updater.enqueueSetState(this, partialState); if (callback) { this.updater.enqueueCallback(this, callback, \u0026#34;setState\u0026#34;); } }; 入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。这里我们以对象形式的入参为例，可以看到它直接调用了 this.updater.enqueueSetState 这个方法：\n1 2 3 4 5 6 7 8 9 enqueueSetState: function (publicInstance, partialState) { // 根据 this 拿到对应的组件实例 var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, \u0026#39;setState\u0026#39;); // 这个 queue 对应的就是一个组件实例的 state 数组 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); // enqueueUpdate 用来处理当前的组件实例 enqueueUpdate(internalInstance); } 总结一下，enqueueSetState 做了两件事：\n将新的 state 放进组件的状态队列里； 用 enqueueUpdate 来处理将要更新的实例对象。 继续往下走，看看 enqueueUpdate 做了什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function enqueueUpdate(component) { ensureInjected(); // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段 if (!batchingStrategy.isBatchingUpdates) { // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件 batchingStrategy.batchedUpdates(enqueueUpdate, component); return; } // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等” dirtyComponents.push(component); if (component._updateBatchNumber == null) { component._updateBatchNumber = updateBatchNumber + 1; } } enqueueUpdate 引出了一个关键的对象——batchingStrategy，该对象所具备的 isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；其中的 batchedUpdates 方法更是能够直接发起更新流程。由此我们可以大胆推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * batchingStrategy源码 **/ var ReactDefaultBatchingStrategy = { // 全局唯一的锁标识 isBatchingUpdates: false, // 发起更新动作的方法 batchedUpdates: function (callback, a, b, c, d, e) { // 缓存锁变量 var alreadyBatchingStrategy = ReactDefaultBatchingStrategy.isBatchingUpdates; // 把锁“锁上” ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingStrategy) { callback(a, b, c, d, e); } else { // 启动事务，将 callback 放进事务里执行 transaction.perform(callback, null, a, b, c, d, e); } }, }; batchingStrategy 对象并不复杂，你可以理解为它是一个“锁管理器”。\n这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。\n理解了批量更新整体的管理机制，还需要注意 batchedUpdates 中，有一个引人注目的调用：\n1 transaction.perform(callback, null, a, b, c, d, e); 这行代码为我们引出了一个更为硬核的概念——React 中的 Transaction（事务）机制。\n理解 React 中的 Transaction（事务） 机制 Transaction 在 React 源码中的分布可以说非常广泛。如果你在 Debug React 项目的过程中，发现函数调用栈中出现了 initialize、perform、close、closeAll 或者 notifyAll 这样的方法名，那么很可能你当前就处于一个 Trasaction 中。\nTransaction 在 React 源码中表现为一个核心类，React 官方曾经这样描述它：Transaction 是创建一个黑盒，该黑盒能够封装任何的方法。因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行），实例化 Transaction 时只需提供相关的方法即可。\n这段话初读有点拗口，这里我推荐你结合 React 源码中的一段针对 Transaction 的注释来理解它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 * \u0026lt;pre\u0026gt; * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------\u0026gt;|-|---|-|---|--\u0026gt;|anyMethod|---|---|-|---|-|--------\u0026gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * \u0026lt;/pre\u0026gt; 说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，同时需要使用 Transaction 类暴露的 perform 方法去执行它。如上面的注释所示，在 anyMethod 执行之前，perform 会先执行所有 wrapper 的 initialize 方法，执行完后，再执行所有 wrapper 的 close 方法。这就是 React 中的事务机制。\n“同步现象”的本质 下面结合对事务机制的理解，我们继续来看在 ReactDefaultBatchingStrategy 这个对象。ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。\n1 2 3 4 5 6 7 8 9 10 11 var RESET_BATCHED_UPDATES = { initialize: emptyFunction, close: function () { ReactDefaultBatchingStrategy.isBatchingUpdates = false; }, }; var FLUSH_BATCHED_UPDATES = { initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates), }; var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; 我们把这两个 wrapper 套进 Transaction 的执行机制里，不难得出一个这样的流程：\n到这里，相信你对 isBatchingUpdates 管控下的批量更新机制已经了然于胸。但是 setState 为何会表现同步这个问题，似乎还是没有从当前展示出来的源码里得到根本上的回答。这是因为 batchedUpdates 这个方法，不仅仅会在 setState 之后才被调用。若我们在 React 源码中全局搜索 batchedUpdates，会发现调用它的地方很多，但与更新流有关的只有这两个地方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ReactMount.js _renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) { // 实例化组件 var componentInstance = instantiateReactComponent(nextElement); // 初始渲染直接调用 batchedUpdates 进行同步渲染 ReactUpdates.batchedUpdates( batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context ); ... } 这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次 batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用 setState。因此，我们需要通过开启 batch 来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始渲染流程中所有的 setState 都是生效的。\n下面代码是 React 事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。\n","permalink":"https://zzydev.top/posts/headfirstreact/setstate%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/","summary":"从一道面试题说起 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; export default class","title":"SetState到底是同步的还是异步的？"},{"content":"调和（Reconciliation）过程与 Diff 算法 Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。 \u0026mdash;- React 官方\nReconciler（调和器）所做的工作是一系列的，包括组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用。\nDiff 策略的设计思想 React 团队结合设计层面的一些推导，总结了以下两个规律， 为将 O (n3) 复杂度转换成 O (n) 复杂度确立了大前提：\n若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构； 处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。 除了这两个“板上钉钉”的规律之外，还有一个和实践结合比较紧密的规律，它为 React 实现高效的 Diff 提供了灵感：DOM 节点之间的跨层级操作并不多，同层级操作是主流。\n把握三个“要点”，图解 Diff 逻辑 1. 改变时间复杂度量级的决定性思路：分层对比 结合“DOM 节点之间的跨层级操作并不多，同层级操作是主流”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比，如下图所示。这样一来，只需要从上到下的一次遍历，就可以完成对整棵树的对比，这是降低复杂度量级方面的一个最重要的设计。\n需要注意的是：虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转的，分层递归也是递归\n[那么如果真的发生了跨层级的节点操作（比如将以 B 节点为根节点的子树从 A 节点下面移动到 C 节点下面，如下图所示）会怎样呢？很遗憾，作为“次要矛盾”，在这种情况下 React 并不能够判断出“移动”这个行为，它只能机械地认为移出子树那一层的组件消失了，对应子树需要被销毁；而移入子树的那一层新增了一个组件，需要重新为其创建一棵子树。\n销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性。\n2. 减少递归的“一刀切”策略：类型的一致性决定递归的必要性 结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，我们虽不能直接反推出“不同类型的组件 DOM 结构不同”，但在大部分的情况下，这个结论都是成立的。毕竟，实际开发中遇到两个 DOM 结构完全一致、而类型不一致的组件的概率确实太低了。\n本着抓“主要矛盾”的基本原则，React 认为，只有同类型的组件，才有进一步对比的必要性；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点，如下图所示。只有确认组件类型相同后，React 才会在保留组件对应 DOM 树（或子树）的基础上，尝试向更深层次去 Diff。\n这样一来，便能够从很大程度上减少 Diff 过程中冗余的递归操作。\n3. 重用节点的好帮手：key 属性帮 React “记住”节点 key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。 \u0026mdash;- React 对 key 的定义\n它试图解决的是同一层级下节点的重用问题。在展开分析之前，我们先结合到现在为止对 Diff 过程的理解，来思考这样一种情况，如下图所示：\n图中 A 组件在保持类型和其他属性均不变的情况下，在两个子节点（B 和 D）之间插入了一个新的节点（C）。按照已知的 Diff 原则，两棵树之间的 Diff 过程应该是这样的：\n首先对比位于第 1 层的节点，发现两棵树的节点类型是一致的（都是 A），于是进一步 Diff； 开始对比位于第 2 层的节点，第 1 个接受比较的是 B 这个位置，对比下来发现两棵树这个位置上的节点都是 B，没毛病，放过它； 第 2 个接受比较的是 D 这个位置，对比 D 和 C，发现前后的类型不一致，直接删掉 D 重建 C； 第 3 个接受比较的是 E 这个位置，对比 E 和 D，发现前后的类型不一致，直接删掉 E 重建 D； 最后接受“比较”的是树 2 的 E 节点这个位置，这个位置在树 1 里是空的，也就是说树 2 的 E 是一个新增节点，所以新增一个 E。 奇怪的事情发生了：C、D、E 三个节点，其实都是可以直接拿来用的。原本新增 1 个节点就能搞定的事情，现在却又是删除又是重建地搞了半天，而且这个蠢操作和跨层级移动节点还不太一样，后者本来就属于低频操作，加以合理的最佳实践约束一下基本上可以完全规避掉；但图示的这种插入节点的形式是高频操作。频繁增删节点必定拖垮性能，这时候就需要请出 key 属性来帮我们重用节点了。\nkey 属性的形式，我们肯定都不陌生。在基于数组动态生成节点时，我们一般都会给每个节点加装一个 key 属性（下面是一段代码示例）：\n1 const todoItems = todos.map((todo) =\u0026gt; \u0026lt;li key={todo.id}\u0026gt;{todo.text}\u0026lt;/li\u0026gt;); 如果你忘记写 key，React 虽然不至于因此报错，但控制台标红是难免的，它会给你抛出一个“请给列表元素补齐 key 属性”的 warning，这个常见的 warning 也从侧面反映出了 key 的重要性。事实上，当我们没有设定 key 值的时候，Diff 的过程就正如上文所描述的一样惨烈。但只要你按照规范加装一个合适的 key，这个 key 就会像一个记号一样，帮助 React “记住”某一个节点，从而在后续的更新中实现对这个节点的追踪。比如说刚刚那棵虚拟 DOM 树，若我们给位于第 2 层的每一个子节点一个 key 值，如下图所示：\n这个 key 就充当了每个节点的 ID（唯一标识），有了这个标识之后，当 C 被插入到 B 和 D 之间时，React 并不会再认为 C、D、E 这三个坑位都需要被重建——它会通过识别 ID，意识到 D 和 E 并没有发生变化（D 的 ID 仍然是 1，E 的 ID 仍然是 2），而只是被调整了顺序而已。接着，React 便能够轻松地重用它“追踪”到旧的节点，将 D 和 E 转移到新的位置，并完成对 C 的插入。这样一来，同层级下元素的操作成本便大大降低。\n作为一个节点的唯一标识，在使用 key 之前，请务必确认 key 的唯一和稳定。\n","permalink":"https://zzydev.top/posts/headfirstreact/react%E4%B8%AD%E7%9A%84%E6%A0%88%E8%B0%83%E5%92%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/","summary":"调和（Reconciliation）过程与 Diff 算法 Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中","title":"React中的栈调和过程是怎样的？"},{"content":"React 中的虚拟 DOM 大致是如何工作的? 挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；\n更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM\n模板引擎与虚拟DOM有哪些区别？ 区别就在于多出了一层虚拟 DOM 作为缓冲层。这个缓冲层带来的利好是：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“差量更新”。这个过程对应的虚拟 DOM 工作流如下图所示：\nReact 选用虚拟 DOM，真的是为了更好的性能吗？ 虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。\n虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级。\n那么虚拟 DOM 的价值到底是什么呢？ 研发体验/研发效率的问题：这一点前面已经反复强调过，DOM 操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。 跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是真实 DOM，也可以是iOS 界面、安卓界面、小程序\u0026hellip;\u0026hellip;同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和1是高度呼应的。 ","permalink":"https://zzydev.top/posts/headfirstreact/%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdomreact%E9%80%89%E5%AE%83%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%80%A7%E8%83%BD%E5%90%97/","summary":"React 中的虚拟 DOM 大致是如何工作的? 挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）； 更新","title":"真正理解虚拟DOM,React选它是因为性能吗"},{"content":"React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：\n只在 React 函数中调用 Hook； 不要在循环、条件或嵌套函数中调用 Hook。 原则 2 中强调的所有“不要”，都是在指向同一个目的，那就是要确保 Hooks 在每次渲染时都保持同样的执行顺序。 PersonalInfoComponent 里去，看看实际项目中，变量到底是怎么发生变化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import React, { useState } from \u0026#34;react\u0026#34;; // isMounted 用于记录是否已挂载（是否是首次渲染） let isMounted = false; function PersonalInfoComponent() { // 定义变量的逻辑不变 let name, age, career, setName, setCareer; // 这里追加对 isMounted 的输出，这是一个 debug 性质的操作 console.log(\u0026#34;isMounted is\u0026#34;, isMounted); // 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态 if (!isMounted) { // eslint-disable-next-line [name, setName] = useState(\u0026#34;zzy\u0026#34;); // eslint-disable-next-line [age] = useState(\u0026#34;99\u0026#34;); // if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了） isMounted = true; } // 对职业信息的获取逻辑不变 [career, setCareer] = useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); // 这里追加对 career 的输出，这也是一个 debug 性质的操作 console.log(\u0026#34;career\u0026#34;, career); // UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示 return ( \u0026lt;div className=\u0026#34;personalInfo\u0026#34;\u0026gt; {name ? \u0026lt;p\u0026gt;姓名：{name}\u0026lt;/p\u0026gt; : null} {age ? \u0026lt;p\u0026gt;年龄：{age}\u0026lt;/p\u0026gt; : null} \u0026lt;p\u0026gt;职业：{career}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; { setName(\u0026#34;唔知\u0026#34;); }} \u0026gt; 修改姓名 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default PersonalInfoComponent; Hooks 的正常运作，在底层依赖于顺序链表 以 useState 为例，分析 React-Hooks 的调用链路 在这个流程中，useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 进入 mounState 逻辑 function mountState(initialState) { // 将新的 hook 对象追加进链表尾部 var hook = mountWorkInProgressHook(); // initialState 可以是一个回调，若是回调，则取回调执行后的值 if (typeof initialState === \u0026#34;function\u0026#34;) { // $FlowFixMe: Flow doesn\u0026#39;t like mixed types initialState = initialState(); } // 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch const queue = (hook.queue = { last: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), }); // 将 initialState 作为一个“记忆值”存下来 hook.memoizedState = hook.baseState = initialState; // dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么 var dispatch = (queue.dispatch = dispatchAction.bind( null, currentlyRenderingFiber$1, queue )); // 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈 return [hook.memoizedState, dispatch]; } 从这段源码中我们可以看出，mounState 的主要工作是初始化 Hooks。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式。以下是 mountWorkInProgressHook 方法的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function mountWorkInProgressHook() { // 注意，单个 hook 是以对象的形式存在的 var hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理 firstWorkInProgressHook = workInProgressHook = hook; } else { // 若链表不为空，则将 hook 追加到链表尾部 workInProgressHook = workInProgressHook.next = hook; } // 返回当前的 hook return workInProgressHook; } 到这里可以看出，hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联。\n接下来我们再看更新过程的大图：\n根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染。\n我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。\n看到这里，你是不是已经大概知道怎么回事儿了？没错，hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的。\n这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。Hooks 的本质其实是链表。\n站在底层视角，重现PersonalInfoComponent 从代码里面，我们可以提取出来的 useState 调用有三个：\n1 2 3 [name, setName] = useState(\u0026#34;zzy\u0026#34;); [age] = useState(\u0026#34;99\u0026#34;); [career, setCareer] = useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); 当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：\n1 useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;) 链表此时的状态如下图所示：\n更新（二次渲染）的时候会发生什么事情：updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它会认为：你想要的是第一个位置的 hook **。\n然后就会有下面这样的效果：\n","permalink":"https://zzydev.top/posts/headfirstreact/%E6%B7%B1%E5%85%A5react-hooks%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E5%8E%9F%E5%88%99%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E5%8E%9F%E7%90%86/","summary":"React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下： 只在 React 函数中调用 Hook； 不要在循环、条件或嵌套函数中调用 Hook。 原则 2 中强调的所","title":"深入React Hooks工作机制:“原则”的背后,是“原理”"},{"content":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。\n如果你在这个在线 Demo中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：\n明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！\n这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？\n因为虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。\n多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。\n但如果我们把 ProfilePage 改造为一个像这样的函数组件：\n1 2 3 4 5 6 7 8 9 10 11 function ProfilePage(props) { const showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + props.user); }; const handleClick = () =\u0026gt; { setTimeout(showMessage, 3000); }; return ( \u0026lt;button onClick={handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt; ); } 事情就会大不一样。\nprops 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。\n总结：“函数组件会捕获 render 内部的状态”，函数组件真正地把数据和渲染绑定到了一起。\n函数组件是一个更加匹配React设计理念、也更有利于逻辑拆分与重用的组件表达形式，React-Hooks 便应运而生。\n从核心 API 看 Hooks 的基本形态 useState()：为函数组件引入状态 1 2 3 4 5 6 7 8 9 10 11 12 const [state, setState] = useState(initialState); //状态和修改状态的 API 名都是可以自定义的 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;); //它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值 // 定义为数组 const [author, setAuthor] = useState([\u0026#34;xiuyan\u0026#34;, \u0026#34;cuicui\u0026#34;, \u0026#34;yisi\u0026#34;]); // 定义为数值 const [length, setLength] = useState(100); // 定义为字符串 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;) useEffect()：允许函数组件执行副作用操作 useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。\n仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组。调用形式如下所示： 1 2 3 useEffect(()=\u0026gt;{ // 这里是业务逻辑 }, []) 仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。调用形式如下所示： 1 2 3 4 5 6 7 useEffect(()=\u0026gt;{ // 这里是 A 的业务逻辑 // 返回一个函数记为 B return ()=\u0026gt;{ } }, []) useEffect 回调中返回的函数被称为“清除函数”，当 React 识别到清除函数时，会在卸载时执行清除函数内部的逻辑。这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理。\n每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。如下所示： 1 2 3 4 5 6 7 8 useEffect(()=\u0026gt;{ // 这里是 A 的业务逻辑 // 返回一个函数记为 B return ()=\u0026gt;{ } }) 根据一定的依赖条件来触发的副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述），同时传入一个非空的数组，如下所示： 1 2 3 4 5 6 useEffect(()=\u0026gt;{ // 这是回调函数的业务逻辑 // 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发 return xxx }, [num1, num2, num3]) 数组中的变量一般都是来源于组件本身的数据（props 或者 state）。若数组不为空，那么 React 就会在新的一次渲染后去对比前后两次的渲染，查看数组内是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了），并在有更新的前提下去触发 useEffect 中定义的副作用逻辑。\nWhy React-Hooks：Hooks 是如何帮助我们升级工作模式的 告别难以理解的 Class：把握 Class 的两大“痛点” class 的“难以理解”说法的背后是this和生命周期两大痛点。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Example extends Component { state = { name: \u0026#39;zzydev\u0026#39;, age: \u0026#39;99\u0026#39;; }; changeAge() { // 这里会报错 this.setState({ age: \u0026#39;100\u0026#39; }); } render() { return \u0026lt;button onClick={this.changeAge}\u0026gt;{this.state.name}的年龄是{this.state.age}\u0026lt;/button\u0026gt; } } changeAge 这个方法：它是 button 按钮的事件监听函数。当我点击 button 按钮时，希望它能够帮我修改状态，但事实是，点击发生后，程序会报错。原因很简单，changeAge 里并不能拿到组件实例的 this。为了解决 this 不符合预期的问题，可以使用this.changeAga = this.changeAga.bind(this) 或 箭头函数的方式，但这两种方式 本质上都是在用实践层面的约束来解决设计层面的问题\n生命周期的带来的麻烦提现在：学习成本和不合理的逻辑规划方式\nHooks 如何实现更好的逻辑拆分\n过去我们组织自己业务逻辑的方式：先想清楚业务的需要是什么样的，然后将对应的业务逻辑拆到不同的生命周期函数里去。逻辑与生命周期耦合在一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 componentDidMount() { // 1. 这里发起异步调用 // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM // 3. 这里设置一个订阅 // 4. 这里随便干点别的什么 // ... } componentWillUnMount() { // 在这里卸载订阅 } componentDidUpdate() { // 1. 在这里根据 DidMount 获取到的异步数据更新 DOM // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样） } 像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。\n而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。\n状态复用：Hooks 将复杂的问题变简单\n过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。\nHooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。\nReact Hook的局限性 Hooks 暂时还不能完全地为函数组件补齐类组件的能力：比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。\nHooks 在使用层面有着严格的规则约束\n","permalink":"https://zzydev.top/posts/headfirstreact/react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","summary":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用","title":"React Hooks设计动机与工作模式"},{"content":"React 的核心特征是“数据驱动视图”，即 UI = render(data)\n基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。\n父子组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 子组件 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } //父组件 class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 按钮的监听函数，用于更新 text 值 changeText = () =\u0026gt; { this.setState({ text: \u0026#34;改变后的父组件文本\u0026#34; }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;button onClick={this.changeText}\u0026gt; 点击修改父组件传入子组件的文本 \u0026lt;/button\u0026gt; {/* 引入子组件，并通过 props 下发具体的状态值实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 子-父组件通信 考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。假如父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，以此来间接地实现数据从子组件到父组件的流动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Child extends React.Component { // 初始化子组件的 state state = { text: \u0026#39;子组件的文本\u0026#39; } // 子组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text) } render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本的动作放在了 Child 里 */} \u0026lt;button onClick={this.changeText}\u0026gt; 点击更新父组件的文本 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 这个方法会作为 props 传给子组件，用于更新父组件 text 值。newText 正是开放给子组件的数据通信入口 changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`父组件的文本内容是：[${this.state.text}]`}\u0026lt;/p\u0026gt; {/* 引入子组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;Child changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } 兄弟组件通信 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } class NewChild extends React.Component { state = { text: \u0026#34;来自 newChild 的文本\u0026#34; }; // NewChild 组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text); }; render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本（同时也是 Child 组件的文本）的动作放在了 NewChild 里 */} \u0026lt;button onClick={this.changeText}\u0026gt;点击更新 Child 组件的文本\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 传给 NewChild 组件按钮的监听函数，用于更新父组件 text 值（这个 text 值同时也是 Child 的 props） changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; {/* 引入 Child 组件，并通过 props 中下发具体的状态值 实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; {/* 引入 NewChild 组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;NewChild changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 利用“发布-订阅”模式驱动数据流 使用发布-订阅模式的优点在于，监听事件的位置和触发事件的位置是不受限的，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。\n发布-订阅模型 API 设计思路 on()：负责注册事件的监听器，指定事件触发时的回调函数。 emit()：负责触发事件，可以通过传参使其在触发的时候携带数据 。 off()：负责监听器的删除。 发布-订阅模型编码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class myEventEmitter { constructor() { // eventMap 用来存储事件和监听函数之间的关系 this.eventMap = {}; } // type 这里就代表事件的名称 on(type, handler) { // hanlder 必须是一个函数，如果不是直接报错 if (!(handler instanceof Function)) { throw new Error(\u0026#34;hanlder必须是一个函数\u0026#34;); } // 判断 type 事件对应的队列是否存在 if (!this.eventMap[type]) { // 若不存在，新建该队列 this.eventMap[type] = []; } // 若存在，直接往队列里推入 handler this.eventMap[type].push(handler); } // 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体 emit(type, params) { // 假设该事件是有订阅的（对应的事件队列存在） if (this.eventMap[type]) { // 将事件队列里的 handler 依次执行出队 this.eventMap[type].forEach((handler, index) =\u0026gt; { // 注意别忘了读取 params handler(params); }); } } off(type, handler) { if (this.eventMap[type]) { // indexOf找不到元素会返回-1，splice从右往左截取，右移运算会将-1变成4294967295 this.eventMap[type].splice(this.eventMap[type].indexOf(handler) \u0026gt;\u0026gt;\u0026gt; 0, 1); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 注意这个 myEvent 是提前实例化并挂载到全局的，此处不再重复示范实例化过程 const globalEvent = window.myEvent; class B extends React.Component { // 这里省略掉其他业务逻辑 state = { newParams: \u0026#34;\u0026#34;, }; handler = (params) =\u0026gt; { this.setState({ newParams: params, }); }; bindHandler = () =\u0026gt; { globalEvent.on(\u0026#34;someEvent\u0026#34;, this.handler); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.bindHandler}\u0026gt;点我监听A的动作\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;A传入的内容是[{this.state.newParams}]\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } } class A extends React.Component { // 这里省略掉其他业务逻辑 state = { infoToB: \u0026#34;哈哈哈哈我来自A\u0026#34;, }; reportToB = () =\u0026gt; { // 这里的 infoToB 表示 A 自身状态中需要让 B 感知的那部分数据 globalEvent.emit(\u0026#34;someEvent\u0026#34;, this.state.infoToB); }; render() { return \u0026lt;button onClick={this.reportToB}\u0026gt;点我把state传递给B\u0026lt;/button\u0026gt;; } } export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;/div\u0026gt; ); } 使用Context维护全局状态 useContext\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //作用是创建一个context对象,可以选择性地传入一个defaultValue const AppContext = React.createContext(defaultValue) //从创建出的context对象中，可以读取到 Provider 和 Consumer const { Provider, Consumer } = AppContext //使用 Provider 对组件树中的根组件进行包裹， //然后传入名为“value”的属性，这个 value 就是后续在组件树中流动的“数据”， //它可以被 Consumer 消费。 \u0026lt;Provider value={title: this.state.title, content: this.state.content}\u0026gt; \u0026lt;Title /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/Provider\u0026gt; //Consumer，顾名思义就是“数据的消费者”，它可以读取 Provider 下发下来的数据 //其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。 \u0026lt;Consumer\u0026gt; {value =\u0026gt; \u0026lt;div\u0026gt;{value.title}\u0026lt;/div\u0026gt;} \u0026lt;/Consumer\u0026gt; //注意: 当 Consumer 没有对应的 Provider 时， //value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。 Redux createStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const createStore = (reducer, enhancer) =\u0026gt; { if (enhancer) { return enhancer(createStore)(reducer); } let currentState = void 0; let currentListeners = []; const getState = () =\u0026gt; currentState; const dispatch = (action) =\u0026gt; { currentState = reducer(currentState, action); currentListeners.forEach((listener) =\u0026gt; listener()); }; const subscribe = (listener) =\u0026gt; { currentListeners.push(listener); return () =\u0026gt; { const index = currentListeners.indexOf(listener); currentListeners.splice(index, 1); }; }; //手动触发一次订阅，加上默认值 dispatch({ type: \u0026#34;@z—redux/INIT\u0026#34; }); return { getState, dispatch, subscribe, }; }; export default createStore; applyMiddleware.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const applyMiddleware = (...middleware) =\u0026gt; { return (createStore) =\u0026gt; (reducer) =\u0026gt; { const store = createStore(reducer); let dispatch = store.dispatch; const midApi = { getState: store.getState, dispatch: (action, ...args) =\u0026gt; dispatch(action, ...args), }; const chain = middleware.map((middleware) =\u0026gt; middleware(midApi)); dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch, }; }; }; const compose = (...funcs) =\u0026gt; { if (funcs.length === 0) { return (arg) =\u0026gt; arg; } if (funcs.length === 1) { return funcs[0]; } return funcs.reduce( (a, b) =\u0026gt; (...args) =\u0026gt; a(b(...args)) ); }; export default applyMiddleware; combineReducer.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const combineReducers = (reducers) =\u0026gt; (state = {}, action) =\u0026gt; { let nextState = {}; let hasChange = false; for (let key in reducers) { const reducer = reducers[key]; nextState[key] = reducer(state[key], action); hasChange = hasChange || nextState[key] !== state[key]; } hasChange = hasChange || Object.keys(nextState) !== Object.keys(state); return hasChange ? nextState : state; }; export default combineReducers; React-Redux 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import { useReducer } from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; import { useCallback, useState, useEffect, useLayoutEffect, useContext, } from \u0026#34;react\u0026#34;; const Context = React.createContext(); export const Provider = ({ store, children }) =\u0026gt; { return \u0026lt;Context.Provider value={store}\u0026gt;{children}\u0026lt;/Context.Provider\u0026gt;; }; export const connect = (mapStateToProps = (state) =\u0026gt; state, mapDispatchToProps) =\u0026gt; (WrapperComponent) =\u0026gt; (props) =\u0026gt; { const store = useContext(Context); const { getState, dispatch, subscribe } = store; const stateProps = mapStateToProps(getState()); let dispatchProps = { dispatch }; if (typeof mapDispatchToProps === \u0026#34;object\u0026#34;) { dispatchProps = { ...bindActionCreators(mapDispatchToProps, dispatch), dispatch, }; } else if (typeof mapDispatchToProps === \u0026#34;function\u0026#34;) { dispatchProps = mapDispatchToProps(dispatch); } const forceUpdate = useForceUpdate(); useLayoutEffect(() =\u0026gt; { const unsubscribe = subscribe(() =\u0026gt; { forceUpdate(); }); return () =\u0026gt; { if (unsubscribe) { unsubscribe(); } }; }, []); return \u0026lt;WrapperComponent {...props} {...stateProps} {...dispatchProps} /\u0026gt;; }; function bindActionCreator(creator, dispatch) { return (...args) =\u0026gt; dispatch(creator(...args)); } export const bindActionCreators = (creators, dispatch) =\u0026gt; { let obj = {}; for (let key in creators) { obj[key] = bindActionCreator(creators[key], dispatch); } return obj; }; const useForceUpdate = () =\u0026gt; { const [state, setState] = useState(0); //const [, setState] = useReducer((prev) =\u0026gt; prev + 1, 0); const update = useCallback(() =\u0026gt; { setState((prev) =\u0026gt; prev + 1); }, []); return update; }; ","permalink":"https://zzydev.top/posts/headfirstreact/%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8react%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%E7%9A%84/","summary":"React 的核心特征是“数据驱动视图”，即 UI = render(data) 基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更","title":"数据是如何在React组件之间流动的？"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int res = nums[0] + nums[1] + nums[2]; sort(nums.begin(),nums.end()); for (int i = 0; i \u0026lt; nums.size() - 2; i++) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; if (nums[i] + nums[j] + nums[k] == target) return target; while (j \u0026lt; k \u0026amp;\u0026amp; abs(nums[i] + nums[j] + nums[k - 1] - target) \u0026lt; abs(nums[i] + nums[j] + nums[k] - target)) { res = min(res, nums[i] + nums[j] + nums[k --]); } } } return res; } }; lc15_三数之和\nlc01_两数之和\nlc18_四数之和\n","permalink":"https://zzydev.top/posts/leetcode/lc16_%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int res = nums[0] + nums[1] + nums[2]; sort(nums.begin(),nums.end()); for (int i = 0; i \u0026lt; nums.size() - 2; i++) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1, k = nums.size() -","title":"Lc16_最接近的三数之和"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); int n = nums.size(); if (n \u0026lt; 3) return res; for (int i = 0; i \u0026lt; n - 2; i ++) { //------------------------双指针：这部分维度降为O(n)--------------------- if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; //跳过相同的nums[i] for (int j = i + 1, k = n - 1; j \u0026lt; k; j ++) { //跳过相同的nums[j] 注意 j \u0026gt; i + 1 if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; //注意 j \u0026lt; k - 1，使用nums[k - 1]试探，如果大于等于0，说明结果至少是nums[k --] while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) k --; if (nums[i] + nums[j] + nums[k] == 0) res.push_back({nums[i], nums[j], nums[k]}); } //--------------------------------------------------------------------- } return res; } }; lc16_最接近的三数之和\nlc01_两数之和\nlc18_四数之和\n","permalink":"https://zzydev.top/posts/leetcode/lc15_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); int n = nums.size(); if (n \u0026lt; 3) return res; for (int i = 0; i \u0026lt; n - 2; i ++) { //-----------","title":"Lc15_三数之和"},{"content":"语法题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (str.size() \u0026lt;= i || str[i] != c) return res; res += c; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc14_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","summary":"语法题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (str.size() \u0026lt;= i || str[i] != c) return res; res +=","title":"Lc14_最长公共前缀"},{"content":"定义字母（罗马数字）到数字（阿拉伯数字）的映射。 从前往后扫描，如果发现 s[i+1]的数字比 s[i] 的数字大，那么减去 s[i]的值即可，否则直接累计 s[i] 的值。\n时间复杂度：仅扫描一遍字符串，时间复杂度为 O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int romanToInt(string s) { unordered_map\u0026lt;char,int\u0026gt; hash { {\u0026#39;I\u0026#39;, 1}, {\u0026#39;V\u0026#39;, 5}, {\u0026#39;X\u0026#39;, 10}, {\u0026#39;L\u0026#39;, 50}, {\u0026#39;C\u0026#39;, 100}, {\u0026#39;D\u0026#39;, 500}, {\u0026#39;M\u0026#39;, 1000} }; int res = 0; for (int i = 0; i \u0026lt; s.size(); i ++) { if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) { res -= hash[s[i]]; } else { res += hash[s[i]]; } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc13_%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","summary":"定义字母（罗马数字）到数字（阿拉伯数字）的映射。 从前往后扫描，如果发现 s[i+1]的数字比 s[i] 的数字大，那么减去 s[i]的值即可，否则直接累计","title":"Lc13_罗马数字转整数"},{"content":"罗马数字的计数方法：\n相同的数字连写，所表示的数等于这些数字相加的和，如：III=3； 较小的数字在较大的数字的右边，所表示的数等于这些数字相加的和，如：VIII=8, XII=12； 较小的数字在较大的数字的左边（限于 IV、IX、XL、XC、CD 和 CM），所表示的数等于较大的数字减较小的数字得到的数，如：IV=4, IX=9； 连写的数字最多三次，如：III=3； 将所有减法操作看做一个整体，当成一种新的单位，如：CD = 400。从大到小整理所有单位得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: string intToRoman(int num) { int values[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string reps[] = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; 13; i ++) { while (num \u0026gt;= values[i]) { num -= values[i]; res += reps[i]; } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc12_%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","summary":"罗马数字的计数方法： 相同的数字连写，所表示的数等于这些数字相加的和，如：III=3； 较小的数字在较大的数字的右边，所表示的数等于这些数字相加","title":"Lc12_整数转罗马数字"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l \u0026lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] \u0026gt;= height[r]) r --; else if (height[l] \u0026lt; height[r]) l ++; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l \u0026lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] \u0026gt;= height[r]) r --; else if (height[l] \u0026lt; height[r]) l ++; } return res; } };","title":"Lc11_盛最多水的容器"},{"content":" 如果p[j] == \u0026lsquo;*\u0026rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] \u0026amp;\u0026amp; s[i] == p[j - 1]以此类推\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool isMatch(string s, string p) { // s字符串 p字符规律 int n = s.size(), m = p.size(); // 减少边界处理 s = s + \u0026#39; \u0026#39;, p = p + \u0026#39; \u0026#39;; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; f(n + 1, vector\u0026lt;bool\u0026gt; (m + 1)); f[0][0] = true; for (int i = 0; i \u0026lt; n; i ++) { for (int j = 1; j \u0026lt; m; j ++) { if (j + 1 \u0026lt;= m \u0026amp;\u0026amp; p[j + 1] == \u0026#39;*\u0026#39;) continue; if (i \u0026amp;\u0026amp; p[j] != \u0026#39;*\u0026#39;) { f[i][j] = f[i - 1][j - 1] \u0026amp;\u0026amp; (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;); } else if(p[j] == \u0026#39;*\u0026#39;){ f[i][j] = f[i][j - 2] || i \u0026amp;\u0026amp; f[i - 1][j] \u0026amp;\u0026amp; (s[i] == p[j - 1]); } } } return f[n][m]; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc10_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","summary":"如果p[j] == \u0026lsquo;*\u0026rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] \u0026amp;\u0026amp; s[i] == p[j - 1]以此类推 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15","title":"Lc10_正则表达式匹配"},{"content":"解法一 1 2 3 4 5 6 7 8 9 class Solution { public: bool isPalindrome(int x) { string t = to_string(x); auto res = t; reverse(t.begin(), t.end()); return res == t; } }; 解法二 如果负数直接返回 false， 比较正序逆序数字是否一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool isPalindrome(int x) { if (x \u0026lt; 0) return false; long long t = 0; int ans = x; while (x) { t = t * 10 + x % 10; x /= 10; } return ans == t; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc09_%E5%9B%9E%E6%96%87%E6%95%B0/","summary":"解法一 1 2 3 4 5 6 7 8 9 class Solution { public: bool isPalindrome(int x) { string t = to_string(x); auto res = t; reverse(t.begin(), t.end()); return res == t; } }; 解法二 如果负数直接返回 false， 比较正序逆序数字是否一样 1 2 3 4 5","title":"Lc09_回文数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int myAtoi(string s) { int k = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == \u0026#39; \u0026#39;) k ++; //去除前导空格 if (k == s.size()) return 0; int minus = 1; if (s[k] == \u0026#39;-\u0026#39;) k ++, minus = -1; else if (s[k] == \u0026#39;+\u0026#39;) k ++; int res = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[k] \u0026lt;= \u0026#39;9\u0026#39;) { int x = s[k] - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x) / 10) return INT_MAX; //minus = -1，那res是负数，所以 -res * 10 - x \u0026lt; INT_MIN就会溢出 if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (INT_MIN + x) / 10) return INT_MIN; if (-res * 10 - x == INT_MIN) return INT_MIN; res = res * 10 + x; k ++ ; } res *= minus; return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc08_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0aoti/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int myAtoi(string s) { int k = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == \u0026#39; \u0026#39;) k ++; //去除前导空格 if (k == s.size()) return 0; int minus = 1; if (s[k] == \u0026#39;-\u0026#39;)","title":"Lc08_字符串转换整数(aoti)"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x % 10) / 10) return 0; if (x \u0026lt; 0 \u0026amp;\u0026amp; res \u0026lt; (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x /= 10; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc07_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x % 10) / 10) return 0; if (x \u0026lt; 0 \u0026amp;\u0026amp; res \u0026lt; (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x","title":"Lc07_整数反转"},{"content":"题解 题目要求**假设环境不允许存储 64 位整数（有符号或无符号）**所以只能使用 int\n我们要保证 res * 10 + x % 10 不越界，那么有当 x \u0026gt; 0 时， res * 10 + x % 10 \u0026lt; INT_MAX 通过等价变形 res * 10 \u0026lt; INT_MAX - x % 10 。\n由于 x \u0026gt; 0 所以，(INT_MAX - x % 10) / 10不会溢出\n同理，当 x \u0026lt; 0，INT_MIN - x % 10 负数减负数也不会溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: string convert(string s, int numRows) { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; numRows; i ++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; s.size(); j += 2 * numRows - 2) { res += s[j]; } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; s.size() || k \u0026lt; s.size(); j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; s.size()) res += s[j]; if (k \u0026lt; s.size()) res += s[k]; } } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc06_z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","summary":"题解 题目要求**假设环境不允许存储 64 位整数（有符号或无符号）**所以只能使用 int 我们要保证 res * 10 + x % 10 不越界，那么有当 x \u0026gt; 0 时， res * 10 + x %","title":"Lc06_Z字形变换"},{"content":"暴力枚举：\n首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到遇到不同字符为止。\n分两种情况讨论：\n回文串长度是奇数 如：\u0026ldquo;babab\u0026rdquo; 回文串长度是偶数 如：\u0026ldquo;bbcc\u0026rdquo; 如果遇到不同字符，则我们就找到了以 i 为中心的回文串边界。\n时间复杂度：一共两层循环，$O(n^2)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestPalindrome(string s) { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.size(); i ++) { //偶数 int l = i, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) l --, r ++; if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); //奇数 l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) l --, r ++; if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc05_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","summary":"暴力枚举： 首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到遇到不同字符为止。 分两种情况讨论： 回文串长度是奇数 如：\u0026ldquo;ba","title":"Lc05_最长回文子串"},{"content":"双指针经典模板：\nclass Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;int, int\u0026gt; hash; int res = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] \u0026gt; 1) hash[s[l ++]] --; if (res \u0026lt; r - l + 1) res = r - l + 1; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc03_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","summary":"双指针经典模板： class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;int, int\u0026gt; hash; int res = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] \u0026gt; 1) hash[s[l ++]] --; if (res \u0026lt; r - l + 1) res = r - l + 1; } return res; } };","title":"Lc03_无重复字符的最长子串"},{"content":"题解： 模拟加法过程：\n举个 🌰：我们计算 abc + efg，我们应该先计算 c + g 如果结果大于等于 10 则进 1，然后继续计算 b + f 再加上之前的 进位 。\n也就是说，每一位的结果是 ：上一位进位加上当前位所有数的和\n注：一般来说，模拟加法的题目都要 reverse 处理一下，但是这道题是从个位开始，就不用 reverse\n时间复杂度：O(n + m) n 和 m 是两个链表的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int carry = 0; auto dummy = new ListNode(0); auto ret = dummy; while (l1 || l2 || carry) { if (l1) { carry += l1-\u0026gt;val; l1 = l1-\u0026gt;next; } if (l2) { carry += l2-\u0026gt;val; l2 = l2-\u0026gt;next; } dummy-\u0026gt;next = new ListNode(carry % 10); carry /= 10; dummy = dummy-\u0026gt;next; } return ret-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc02_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","summary":"题解： 模拟加法过程： 举个 🌰：我们计算 abc + efg，我们应该先计算 c + g 如果结果大于等于 10 则进 1，然后继续计算 b + f 再加上之前的 进位 。 也就是说，","title":"Lc02_两数相加"},{"content":"React15的生命周期 Mounting 阶段：组件的初始化渲染（挂载） 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成所谓的“首次渲染”。\n注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。\ncomponentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里**执行真实 DOM 相关的操作，**类似于异步请求、数据初始化这样的操作也大可以放在这个生命周期来做。\nUpdating 阶段：组件的更新 componentWillReceiProps(nextProps) 到底是由什么触发的？ 在这个生命周期方法里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）我们可以通过 this.props 拿到，由此便能够感知到 props 的变化。\ncomponentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。\n如果父组件导致组件重新渲染，即使props没有更改也会调用此方法（componentWillReceiProps） 如果只想处理更改，请确保当前值与变更值的比较 \u0026mdash;-React官方\n组件自身 setState 触发的更新 componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。\nrender 与性能：初识 shouldComponentUpdate(nextProps, nextState) React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行re-render（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。\nUnmounting 阶段：组件的卸载 组件销毁的常见原因有以下两个。\n组件在父组件中被移除了：这种情况相对比较直观 组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被干掉。 React16的生命周期 Mounting 阶段：组件的初始化渲染（挂载） 认识 getDerivedStateFromProps(props,state) getDerivedStateFromProps这个API，其设计的初衷不是试图替换掉componentWillMount ，而是试图替换掉componentWillReceiveProps，因此它有且仅有一个用途:使用 props 来派生/更新 state\ngetDerivedStateFromProps 是一个静态方法，静态方法不依赖组件实例而存在，因此你在这个方法内部是访问不到 this 的。\n该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。\ngetDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番。\ngetDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：\n1 2 3 { fatherText: props.text } 该对象并不会替换掉组件原始的这个 state：\n1 this.state = { text: \u0026#34;子组件的文本\u0026#34; }; 而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示： Updating 阶段：组件的更新 React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：\n在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；\n而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。\n为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？ 做合理的减法：\ngetDerivedStateFromProps 直接被定义为 static 方法，static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。 这是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。 消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate方法需要一个返回值，它的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state\u0026amp;props 的信息。\n重点把握它与componentDidUpdate 间的通信过程：\n1 2 3 4 5 6 7 8 9 10 11 // 组件更新时调用 getSnapshotBeforeUpdate(prevProps, prevState) { console.log(\u0026#34;getSnapshotBeforeUpdate方法执行\u0026#34;); return \u0026#34;haha\u0026#34;; } // 组件更新后调用 componentDidUpdate(prevProps, prevState, valueFromSnapshot) { console.log(\u0026#34;componentDidUpdate方法执行\u0026#34;); console.log(\u0026#34;从 getSnapshotBeforeUpdate 获取到的值是\u0026#34;, valueFromSnapshot); } 这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。\nReact16为何两次求变？ Fiber 会使原本同步的渲染过程变成异步的。 同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”。\n换个角度看生命周期工作流 Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：\n总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。\n为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。\n细说生命周期“废旧立新”背后的思考 在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。\n带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：\ncomponentWillMount； componentWillUpdate； componentWillReceiveProps。 这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。\n在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:\nsetState()； fetch 发起异步请求； 操作真实 DOM。 这些操作的问题（或不必要性）包括但不限于以下 3 点：\n完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做。\n比如在 componentWillMount 里发起异步请求。很多同学因为太年轻，以为这样做就可以让异步请求回来得“早一点”，从而避免首次渲染白屏。\n但是异步请求再怎么快也快不过（React 15 下）同步的生命周期。componentWillMount 结束后，render 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题，得不偿失。\n在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。\n比如 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。\n又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。\ngetDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了——避免开发者触碰 this，就是在避免各种危险的骚操作。\n即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。\n比如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。\n总的来说，React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制。在这个改造的过程中，React 团队针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践**。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。\n","permalink":"https://zzydev.top/posts/headfirstreact/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"React15的生命周期 Mounting 阶段：组件的初始化渲染（挂载） 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM","title":"React生命周期"},{"content":" JSX 的本质：JavaScript 的语法扩展 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。\nBabel 具备将 JSX 语法转换为 javascript 的能力\nBabel 的在线地址\nJSX 是如何映射为 DOM 的：起底 createElement 源码 createElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //React的创建元素方法 export function createElement(type, config, children) { // propName 变量用于储存后面需要用到的元素属性 let propName; // props 变量用于储存元素属性的键值对集合 const props = {}; // key、ref、self、source 均为 React 元素的属性，此处不必深究 let key = null; let ref = null; let self = null; let source = null; // config 对象中存储的是元素的属性 if (config != null) { // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值 if (hasValidRef(config)) { ref = config.ref; } // 此处将 key 值字符串化 if (hasValidKey(config)) { key = \u0026#34;\u0026#34; + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面 for (propName in config) { if ( // 筛选出可以提进 props 对象里的属性 hasOwnProperty.call(config, propName) \u0026amp;\u0026amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度 const childrenLength = arguments.length - 2; // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了 if (childrenLength === 1) { // 直接把这个参数的值赋给props.children props.children = children; // 处理嵌套多个子元素的情况 } else if (childrenLength \u0026gt; 1) { // 声明一个子元素数组 const childArray = Array(childrenLength); // 把子元素推进数组里 for (let i = 0; i \u0026lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } // 最后把这个数组赋值给props.children props.children = childArray; } // 处理 defaultProps if (type \u0026amp;\u0026amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props ); } 入参解读：创造一个元素需要知道哪些信息 1 export function createElement(type, config, children) type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。 config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。 children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。 createElement 函数拆解 createElement 的每一个步骤几乎都是在格式化数据\ncreateElement 就像是开发者和 ReactElement 调用之间的一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。整个过程如下图所示：\n出参解读 初识虚拟 dom ReactElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const ReactElement = function (type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; if (DEV) { /*这里是一些针对 __DEV__ 环境下的处理，对于理解主要逻辑意义不大，故省略*/ } return element; }; ReactElement 把传入的参数按照一定的规范，“组装”进了 element 对象里，并把它返回给了 React.createElement，最终 React.createElement 又把它交回到了开发者手中。\n想要验证这一点，可以打印输出 JSX 部分：\n1 2 3 4 5 6 7 8 const AppJSX = ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt;I am the title\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;content\u0026#34;\u0026gt;I am the content\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); console.log(AppJSX); 你会发现它确实是一个标准的 ReactElement 对象实例，如下图：\n这个 ReactElement 对象实例，本质上是 以 JavaScript 对象形式存在的对 DOM 的描述 ，也就是 虚拟 DOM 中的一个节点 。\n“虚拟 DOM”需要通过 ReactDOM.render方法变成渲染到页面上的真实 DOM\n在每一个 React 项目的入口文件中，都少不了对 ReactDOM.render 函数的调用。\n","permalink":"https://zzydev.top/posts/headfirstreact/jsx%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E4%B8%BAdom%E7%9A%84/","summary":"JSX 的本质：JavaScript 的语法扩展 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”","title":"JSX 是如何变成为 DOM 的"},{"content":"手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } 手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj; if (type !== \u0026#34;object\u0026#34;) return type; return Object.prototype .toString() .call(obj) .replace(/^\\[object (\\S+)\\]$/, \u0026#34;S1\u0026#34;); } 手写浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 function shallowClone(target) { if (typeof target === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; target !== null) { const cloneTarget = Array.isArray() ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; } } 手写深拷贝 小杯\n1 2 3 4 5 6 7 8 9 10 11 function deepClone(obj) { let cloneObj = {}; for (let key in obj) { if (typeof key === \u0026#34;obj\u0026#34; \u0026amp;\u0026amp; key !== null) { cloneObj[key] = deepClone(obj[key]); } else { cloneObj[key] = obj[key]; } } return cloneObj; } 超大杯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const isComplexDataType = (obj) =\u0026gt; (typeof obj === \u0026#34;object\u0026#34; || typeof obj === \u0026#34;function\u0026#34;) \u0026amp;\u0026amp; obj !== null; function deepClone(obj, hash = new WeakMap()) { if (obj instanceof Date) return +new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (hash.has(obj)) return hash.get(obj); //获取对象所有属性及其对应的特征 let allDesc = Object.getOwnPropertyDescriptors(obj); //继承原对象的原型链 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc); hash.set(obj, cloneObj); for (let key of Reflect.ownKeys()) { cloneObj[key] = isComplexDataType(obj[key]) \u0026amp;\u0026amp; typeof obj[key] !== \u0026#34;function\u0026#34; ? deepClone(obj[key], hash) : obj[key]; } return cloneObj; } JS WeakMap 应该什么时候使用\n手写深比较 1 2 3 4 5 6 7 8 9 10 11 12 13 const isObject = (obj) =\u0026gt; typeof obj === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj !== null; function isEqual(obj1, obj2) { if (isObject(obj1) ^ isObject(obj2)) return false; if (obj1 === obj2) return true; const obj1Key = Object.keys(obj1); const obj2Key = Object.keys(obj2); if (obj1Key.length !== obj2Key.length) return false; for (let key in obj) { const res = isEqual(obj1[key], obj2[key]); if (!res) return false; } return true; } 手写 call 、apply 、bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Function.prototype.myCall = function (context, ...args) { // xxx.myCall() this就是这里的xxx myApply和myBind中的this同理 context.func = this; context.func(...args); delete context.func; }; Function.prototype.myBind = function () { const args = Array.from(arguments); const t = args.shift(); const self = this; return function () { return self.apply(t, args); }; }; Function.prototype.myApply = function (context, args) { context.func = this; context.func(...args); delete context.func; }; 手写 Object.create() 1 2 3 4 5 6 //这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型 Object.create = function (prototype) { var cls = function () {}; cls.prototype = prototype; return new cls(); }; 手写 new 1 2 3 4 5 6 7 8 9 10 11 12 function myNew(...args) { // 取出 args 数组第一个参数，即目标构造函数 const constructor = args.shift(); // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性 // 即实现 obj.__proto__ = constructor.prototype const obj = Object.create(constructor.prototype); // 执行构造函数，得到构造函数返回结果 // 注意这里我们使用 apply，将构造函数内的 this 指向为 obj const result = constructor.apply(obj, args); // 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象 return typeof result === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; result != null ? result : obj; } 手写防抖节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Throttle(事件节流)： 第一个人说了算 // fn是我们需要包装的事件回调, interval是时间间隔的阈值 function throttle(fn, interval) { // last为上一次触发回调的时间 let last = 0; // 将throttle处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 记录本次触发回调的时间 let now = new Date(); // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last \u0026gt;= interval) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.apply(context, args); } }; } // 用throttle来包装scroll的回调 const better_scroll = throttle(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); // Debounce(事件防抖)： 最后一个人说了算 // fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间 function debounce(fn, delay) { // 定时器 let timer = null; // 将debounce处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 每次事件被触发时，都去清除之前的旧定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(function () { fn.apply(context, args); }, delay); }; } // 用debounce来包装scroll的回调 const better_scroll = debounce(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); 手写 String.prototype.trim 1 2 3 String.prototype.trim = function () { return this.replace(/^\\s+/, \u0026#34;\u0026#34;).replace(/\\s+$/, \u0026#34;\u0026#34;); }; 手写 Array.flat 1 2 3 4 5 6 7 const flat = (arr) =\u0026gt; { const isDeep = arr.some((item) =\u0026gt; item instanceof Array); if (!isDeep) return arr; const res = Array.prototype.concat.apply([], arr); return flat(res); }; 手写去重 1 2 3 4 const unique = (arr) =\u0026gt; { const set = new Set(arr); return [...arr]; }; 手写 setInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const mySetInterval = (fn, delay) =\u0026gt; { let timer = null, isClear = false; function loop() { if (isClear) { isClear = false; clearTimeout(timer); return; } fn(); timer = setTimeout(loop, delay); } timer = setTimeout(loop, delay); return () =\u0026gt; { isClear = true; }; }; 手写 判断类数组 1 2 3 4 5 6 7 8 9 10 const isArrayLikeObject = (arr) =\u0026gt; { if (typeof arr !== \u0026#34;object\u0026#34; || arr === null) return false; const lengthMaxVal = Math.pow(2, 53) - 1; if (!Object.prototype.hasOwnProperty.call(arr, \u0026#34;length\u0026#34;)) return false; if (typeof arr.length !== \u0026#34;number\u0026#34;) return false; if (!isFinite(arr.length)) return false; if (Array !== arr.constructor) return false; if (arr.length \u0026gt; 0 \u0026amp;\u0026amp; arr.length \u0026lt; lengthMaxVal) return true; return false; }; 手写 模拟私有 1 2 3 4 5 6 7 8 9 function cls() { this.a = \u0026#34;who care\u0026#34;; return { getVal: () =\u0026gt; this.a, }; } let obj = new cls(); obj.getVal(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const myWm = new WeakMap(); class Fish { constructor(name) { myWm.set(this, { _fishbone: [ \u0026#34;草鱼\u0026#34;, \u0026#34;鲫鱼\u0026#34;, \u0026#34;青鱼\u0026#34;, \u0026#34;鲤鱼\u0026#34;, \u0026#34;鲢鱼\u0026#34;, \u0026#34;鳙鱼\u0026#34;, \u0026#34;鳊鱼\u0026#34;, \u0026#34;翘嘴\u0026#34;, \u0026#34;餐条\u0026#34;, ], }); this.name = name; } isBone() { return myWm.get(this)._fishbone.includes(this.name); } } // 测试，买了两条鱼 let fish1 = new Fish(\u0026#34;草鱼\u0026#34;); let fish2 = new Fish(\u0026#34;回鱼\u0026#34;); // 返回 true，有刺 console.log(fish1.isBone()); // 返回 false，没有肌间刺 console.log(fish2.isBone()); 获取当前 url 中的参数的值 1 2 3 4 5 const query = (name) =\u0026gt; { const search = location.search; const params = new URLSearchParams(search); return params.get(name); }; 将 URL 参数解析为 JS 对象 1 2 3 4 5 6 7 8 9 function queryToObject() { const res = {}; const search = location.search; const pList = new URLSearchParams(search); pList.forEach((key, val) =\u0026gt; { res[key] = val; }); return res; } ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C/","summary":"手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } 手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj;","title":"有手就行"},{"content":"使用 C++中的哈希表——unordered_map\u0026lt;int, int\u0026gt;\n循环一遍 nums 数组，在每步循环中我们判断 target - nums[i] 是否在哈希表中 ：\n如果是就找到和为 target 的一对数字，直接返回答案即可； 如果否就将 nums[i] 插入哈希表中；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt; hash; for (int i = 0; i \u0026lt; nums.size();i ++) { if (hash.count(target - nums[i])) { return {hash[target - nums[i]], i}; } else { hash[nums[i]] = i; } } return {}; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"使用 C++中的哈希表——unordered_map\u0026lt;int, int\u0026gt; 循环一遍 nums 数组，在每步循环中我们判断 target - nums[i] 是否在哈希表中 ： 如果是就找到和","title":"Lc01_两数之和"}]