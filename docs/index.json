[{"content":"","permalink":"https://zzydev.top/posts/leetcode/lc16_%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"","title":"Lc16_最接近的三数之和"},{"content":"","permalink":"https://zzydev.top/posts/leetcode/lc15_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"","title":"Lc15_三数之和"},{"content":"语法题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (str.size() \u0026lt;= i || str[i] != c) return res; res += c; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc14_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","summary":"语法题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (str.size() \u0026lt;= i || str[i] != c) return res; res +=","title":"Lc14_最长公共前缀"},{"content":"定义字母（罗马数字）到数字（阿拉伯数字）的映射。 从前往后扫描，如果发现 s[i+1]的数字比 s[i] 的数字大，那么减去 s[i]的值即可，否则直接累计 s[i] 的值。\n时间复杂度：仅扫描一遍字符串，时间复杂度为 O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int romanToInt(string s) { unordered_map\u0026lt;char,int\u0026gt; hash { {\u0026#39;I\u0026#39;, 1}, {\u0026#39;V\u0026#39;, 5}, {\u0026#39;X\u0026#39;, 10}, {\u0026#39;L\u0026#39;, 50}, {\u0026#39;C\u0026#39;, 100}, {\u0026#39;D\u0026#39;, 500}, {\u0026#39;M\u0026#39;, 1000} }; int res = 0; for (int i = 0; i \u0026lt; s.size(); i ++) { if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) { res -= hash[s[i]]; } else { res += hash[s[i]]; } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc13_%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","summary":"定义字母（罗马数字）到数字（阿拉伯数字）的映射。 从前往后扫描，如果发现 s[i+1]的数字比 s[i] 的数字大，那么减去 s[i]的值即可，否则直接累计","title":"Lc13_罗马数字转整数"},{"content":"罗马数字的计数方法：\n相同的数字连写，所表示的数等于这些数字相加的和，如：III=3； 较小的数字在较大的数字的右边，所表示的数等于这些数字相加的和，如：VIII=8, XII=12； 较小的数字在较大的数字的左边（限于 IV、IX、XL、XC、CD 和 CM），所表示的数等于较大的数字减较小的数字得到的数，如：IV=4, IX=9； 连写的数字最多三次，如：III=3； 将所有减法操作看做一个整体，当成一种新的单位，如：CD = 400。从大到小整理所有单位得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: string intToRoman(int num) { int values[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string reps[] = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; 13; i ++) { while (num \u0026gt;= values[i]) { num -= values[i]; res += reps[i]; } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc12_%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","summary":"罗马数字的计数方法： 相同的数字连写，所表示的数等于这些数字相加的和，如：III=3； 较小的数字在较大的数字的右边，所表示的数等于这些数字相加","title":"Lc12_整数转罗马数字"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l \u0026lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] \u0026gt;= height[r]) r --; else if (height[l] \u0026lt; height[r]) l ++; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int len = height.size(); int res = 0; for (int l = 0, r = len - 1; l \u0026lt; r;) { res = max(res, min(height[l], height[r]) * (r - l)); if (height[l] \u0026gt;= height[r]) r --; else if (height[l] \u0026lt; height[r]) l ++; } return res; } };","title":"Lc11_盛最多水的容器"},{"content":" 如果p[j] == \u0026lsquo;*\u0026rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] \u0026amp;\u0026amp; s[i] == p[j - 1]以此类推\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: bool isMatch(string s, string p) { // s字符串 p字符规律 int n = s.size(), m = p.size(); // 减少边界处理 s = s + \u0026#39; \u0026#39;, p = p + \u0026#39; \u0026#39;; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; f(n + 1, vector\u0026lt;bool\u0026gt; (m + 1)); f[0][0] = true; for (int i = 0; i \u0026lt; n; i ++) { for (int j = 1; j \u0026lt; m; j ++) { if (j + 1 \u0026lt;= m \u0026amp;\u0026amp; p[j + 1] == \u0026#39;*\u0026#39;) continue; if (i \u0026amp;\u0026amp; p[j] != \u0026#39;*\u0026#39;) { f[i][j] = f[i - 1][j - 1] \u0026amp;\u0026amp; (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;); } else if(p[j] == \u0026#39;*\u0026#39;){ f[i][j] = f[i][j - 2] || i \u0026amp;\u0026amp; f[i - 1][j] \u0026amp;\u0026amp; (s[i] == p[j - 1]); } } } return f[n][m]; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc10_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","summary":"如果p[j] == \u0026lsquo;*\u0026rsquo; ，如果 表示 0 个字符，那么 f[i][j] == f[i][j - 2]，如果表示 1 个字符，那么有 f[i - 1][j - 2] \u0026amp;\u0026amp; s[i] == p[j - 1]以此类推 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15","title":"Lc10_正则表达式匹配"},{"content":"解法一 1 2 3 4 5 6 7 8 9 class Solution { public: bool isPalindrome(int x) { string t = to_string(x); auto res = t; reverse(t.begin(), t.end()); return res == t; } }; 解法二 如果负数直接返回 false， 比较正序逆序数字是否一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: bool isPalindrome(int x) { if (x \u0026lt; 0) return false; long long t = 0; int ans = x; while (x) { t = t * 10 + x % 10; x /= 10; } return ans == t; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc09_%E5%9B%9E%E6%96%87%E6%95%B0/","summary":"解法一 1 2 3 4 5 6 7 8 9 class Solution { public: bool isPalindrome(int x) { string t = to_string(x); auto res = t; reverse(t.begin(), t.end()); return res == t; } }; 解法二 如果负数直接返回 false， 比较正序逆序数字是否一样 1 2 3 4 5","title":"Lc09_回文数"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int myAtoi(string s) { int k = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == \u0026#39; \u0026#39;) k ++; //去除前导空格 if (k == s.size()) return 0; int minus = 1; if (s[k] == \u0026#39;-\u0026#39;) k ++, minus = -1; else if (s[k] == \u0026#39;+\u0026#39;) k ++; int res = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[k] \u0026lt;= \u0026#39;9\u0026#39;) { int x = s[k] - \u0026#39;0\u0026#39;; if (minus \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x) / 10) return INT_MAX; //minus = -1，那res是负数，所以 -res * 10 - x \u0026lt; INT_MIN就会溢出 if (minus \u0026lt; 0 \u0026amp;\u0026amp; -res \u0026lt; (INT_MIN + x) / 10) return INT_MIN; if (-res * 10 - x == INT_MIN) return INT_MIN; res = res * 10 + x; k ++ ; } res *= minus; return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc08_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0aoti/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int myAtoi(string s) { int k = 0; while (k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == \u0026#39; \u0026#39;) k ++; //去除前导空格 if (k == s.size()) return 0; int minus = 1; if (s[k] == \u0026#39;-\u0026#39;)","title":"Lc08_字符串转换整数(aoti)"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x % 10) / 10) return 0; if (x \u0026lt; 0 \u0026amp;\u0026amp; res \u0026lt; (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x /= 10; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc07_%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int reverse(int x) { int res = 0; while (x) { if (x \u0026gt; 0 \u0026amp;\u0026amp; res \u0026gt; (INT_MAX - x % 10) / 10) return 0; if (x \u0026lt; 0 \u0026amp;\u0026amp; res \u0026lt; (INT_MIN - x % 10) / 10) return 0; res = res * 10 + x % 10; x","title":"Lc07_整数反转"},{"content":"题解 题目要求**假设环境不允许存储 64 位整数（有符号或无符号）**所以只能使用 int\n我们要保证 res * 10 + x % 10 不越界，那么有当 x \u0026gt; 0 时， res * 10 + x % 10 \u0026lt; INT_MAX 通过等价变形 res * 10 \u0026lt; INT_MAX - x % 10 。\n由于 x \u0026gt; 0 所以，(INT_MAX - x % 10) / 10不会溢出\n同理，当 x \u0026lt; 0，INT_MIN - x % 10 负数减负数也不会溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: string convert(string s, int numRows) { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; numRows; i ++) { if (i == 0 || i == numRows - 1) { for (int j = i; j \u0026lt; s.size(); j += 2 * numRows - 2) { res += s[j]; } } else { for (int j = i, k = 2 * numRows - 2 - i; j \u0026lt; s.size() || k \u0026lt; s.size(); j += 2 * numRows - 2, k += 2 * numRows - 2) { if (j \u0026lt; s.size()) res += s[j]; if (k \u0026lt; s.size()) res += s[k]; } } } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc06_z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","summary":"题解 题目要求**假设环境不允许存储 64 位整数（有符号或无符号）**所以只能使用 int 我们要保证 res * 10 + x % 10 不越界，那么有当 x \u0026gt; 0 时， res * 10 + x %","title":"Lc06_Z字形变换"},{"content":"暴力枚举：\n首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到遇到不同字符为止。\n分两种情况讨论：\n回文串长度是奇数 如：\u0026ldquo;babab\u0026rdquo; 回文串长度是偶数 如：\u0026ldquo;bbcc\u0026rdquo; 如果遇到不同字符，则我们就找到了以 i 为中心的回文串边界。\n时间复杂度：一共两层循环，$O(n^2)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestPalindrome(string s) { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.size(); i ++) { //偶数 int l = i, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) l --, r ++; if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); //奇数 l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) l --, r ++; if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc05_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","summary":"暴力枚举： 首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到遇到不同字符为止。 分两种情况讨论： 回文串长度是奇数 如：\u0026ldquo;ba","title":"Lc05_最长回文子串"},{"content":"双指针经典模板：\nclass Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;int, int\u0026gt; hash; int res = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] \u0026gt; 1) hash[s[l ++]] --; if (res \u0026lt; r - l + 1) res = r - l + 1; } return res; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc03_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","summary":"双指针经典模板： class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;int, int\u0026gt; hash; int res = 0; for (int l = 0, r = 0; r \u0026lt; s.size(); r ++) { hash[s[r]] ++; while (hash[s[r]] \u0026gt; 1) hash[s[l ++]] --; if (res \u0026lt; r - l + 1) res = r - l + 1; } return res; } };","title":"Lc03_无重复字符的最长子串"},{"content":"题解： 模拟加法过程：\n举个 🌰：我们计算 abc + efg，我们应该先计算 c + g 如果结果大于等于 10 则进 1，然后继续计算 b + f 再加上之前的 进位 。\n也就是说，每一位的结果是 ：上一位进位加上当前位所有数的和\n注：一般来说，模拟加法的题目都要 reverse 处理一下，但是这道题是从个位开始，就不用 reverse\n时间复杂度：O(n + m) n 和 m 是两个链表的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int carry = 0; auto dummy = new ListNode(0); auto ret = dummy; while (l1 || l2 || carry) { if (l1) { carry += l1-\u0026gt;val; l1 = l1-\u0026gt;next; } if (l2) { carry += l2-\u0026gt;val; l2 = l2-\u0026gt;next; } dummy-\u0026gt;next = new ListNode(carry % 10); carry /= 10; dummy = dummy-\u0026gt;next; } return ret-\u0026gt;next; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc02_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","summary":"题解： 模拟加法过程： 举个 🌰：我们计算 abc + efg，我们应该先计算 c + g 如果结果大于等于 10 则进 1，然后继续计算 b + f 再加上之前的 进位 。 也就是说，","title":"Lc02_两数相加"},{"content":" Mounting 阶段：组件的初始化渲染（挂载） render: 把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。\n","permalink":"https://zzydev.top/posts/headfirstreact/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"Mounting 阶段：组件的初始化渲染（挂载） render: 把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。","title":"React生命周期"},{"content":" JSX 的本质：JavaScript 的语法扩展 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。\nBabel 具备将 JSX 语法转换为 javascript 的能力\nBabel 的在线地址\nJSX 是如何映射为 DOM 的：起底 createElement 源码 createElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //React的创建元素方法 export function createElement(type, config, children) { // propName 变量用于储存后面需要用到的元素属性 let propName; // props 变量用于储存元素属性的键值对集合 const props = {}; // key、ref、self、source 均为 React 元素的属性，此处不必深究 let key = null; let ref = null; let self = null; let source = null; // config 对象中存储的是元素的属性 if (config != null) { // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值 if (hasValidRef(config)) { ref = config.ref; } // 此处将 key 值字符串化 if (hasValidKey(config)) { key = \u0026#34;\u0026#34; + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面 for (propName in config) { if ( // 筛选出可以提进 props 对象里的属性 hasOwnProperty.call(config, propName) \u0026amp;\u0026amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度 const childrenLength = arguments.length - 2; // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了 if (childrenLength === 1) { // 直接把这个参数的值赋给props.children props.children = children; // 处理嵌套多个子元素的情况 } else if (childrenLength \u0026gt; 1) { // 声明一个子元素数组 const childArray = Array(childrenLength); // 把子元素推进数组里 for (let i = 0; i \u0026lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } // 最后把这个数组赋值给props.children props.children = childArray; } // 处理 defaultProps if (type \u0026amp;\u0026amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props ); } 入参解读：创造一个元素需要知道哪些信息 1 export function createElement(type, config, children) type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。 config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。 children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。 createElement 函数拆解 createElement 的每一个步骤几乎都是在格式化数据\ncreateElement 就像是开发者和 ReactElement 调用之间的一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。整个过程如下图所示：\n出参解读 初识虚拟 dom ReactElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const ReactElement = function (type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; if (DEV) { /*这里是一些针对 __DEV__ 环境下的处理，对于理解主要逻辑意义不大，故省略*/ } return element; }; ReactElement 把传入的参数按照一定的规范，“组装”进了 element 对象里，并把它返回给了 React.createElement，最终 React.createElement 又把它交回到了开发者手中。\n想要验证这一点，可以打印输出 JSX 部分：\n1 2 3 4 5 6 7 8 const AppJSX = ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt;I am the title\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;content\u0026#34;\u0026gt;I am the content\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); console.log(AppJSX); 你会发现它确实是一个标准的 ReactElement 对象实例，如下图：\n这个 ReactElement 对象实例，本质上是 以 JavaScript 对象形式存在的对 DOM 的描述 ，也就是 虚拟 DOM 中的一个节点 。\n“虚拟 DOM”需要通过 ReactDOM.render方法变成渲染到页面上的真实 DOM\n在每一个 React 项目的入口文件中，都少不了对 ReactDOM.render 函数的调用。\n","permalink":"https://zzydev.top/posts/headfirstreact/jsx%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E4%B8%BAdom%E7%9A%84/","summary":"JSX 的本质：JavaScript 的语法扩展 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”","title":"JSX 是如何变成为 DOM 的"},{"content":"手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } 手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj; if (type !== \u0026#34;object\u0026#34;) return type; return Object.prototype .toString() .call(obj) .replace(/^\\[object (\\S+)\\]$/, \u0026#34;S1\u0026#34;); } 手写浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 function shallowClone(target) { if (typeof target === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; target !== null) { const cloneTarget = Array.isArray() ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; } } 手写深拷贝 小杯\n1 2 3 4 5 6 7 8 9 10 11 function deepClone(obj) { let cloneObj = {}; for (let key in obj) { if (typeof key === \u0026#34;obj\u0026#34; \u0026amp;\u0026amp; key !== null) { cloneObj[key] = deepClone(obj[key]); } else { cloneObj[key] = obj[key]; } } return cloneObj; } 超大杯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const isComplexDataType = (obj) =\u0026gt; (typeof obj === \u0026#34;object\u0026#34; || typeof obj === \u0026#34;function\u0026#34;) \u0026amp;\u0026amp; obj !== null; function deepClone(obj, hash = new WeakMap()) { if (obj instanceof Date) return +new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (hash.has(obj)) return hash.get(obj); //获取对象所有属性及其对应的特征 let allDesc = Object.getOwnPropertyDescriptors(obj); //继承原对象的原型链 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc); hash.set(obj, cloneObj); for (let key of Reflect.ownKeys()) { cloneObj[key] = isComplexDataType(obj[key]) \u0026amp;\u0026amp; typeof obj[key] !== \u0026#34;function\u0026#34; ? deepClone(obj[key], hash) : obj[key]; } return cloneObj; } JS WeakMap 应该什么时候使用\n手写深比较 1 2 3 4 5 6 7 8 9 10 11 12 13 const isObject = (obj) =\u0026gt; typeof obj === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj !== null; function isEqual(obj1, obj2) { if (isObject(obj1) ^ isObject(obj2)) return false; if (obj1 === obj2) return true; const obj1Key = Object.keys(obj1); const obj2Key = Object.keys(obj2); if (obj1Key.length !== obj2Key.length) return false; for (let key in obj) { const res = isEqual(obj1[key], obj2[key]); if (!res) return false; } return true; } 手写 call 、apply 、bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Function.prototype.myCall = function (context, ...args) { // xxx.myCall() this就是这里的xxx myApply和myBind中的this同理 context.func = this; context.func(...args); delete context.func; }; Function.prototype.myBind = function () { const args = Array.from(arguments); const t = args.shift(); const self = this; return function () { return self.apply(t, args); }; }; Function.prototype.myApply = function (context, args) { context.func = this; context.func(...args); delete context.func; }; 手写 Object.create() 1 2 3 4 5 6 //这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型 Object.create = function (prototype) { var cls = function () {}; cls.prototype = prototype; return new cls(); }; 手写 new 1 2 3 4 5 6 7 8 9 10 11 12 function myNew(...args) { // 取出 args 数组第一个参数，即目标构造函数 const constructor = args.shift(); // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性 // 即实现 obj.__proto__ = constructor.prototype const obj = Object.create(constructor.prototype); // 执行构造函数，得到构造函数返回结果 // 注意这里我们使用 apply，将构造函数内的 this 指向为 obj const result = constructor.apply(obj, args); // 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象 return typeof result === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; result != null ? result : obj; } 手写防抖节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Throttle(事件节流)： 第一个人说了算 // fn是我们需要包装的事件回调, interval是时间间隔的阈值 function throttle(fn, interval) { // last为上一次触发回调的时间 let last = 0; // 将throttle处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 记录本次触发回调的时间 let now = new Date(); // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last \u0026gt;= interval) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.apply(context, args); } }; } // 用throttle来包装scroll的回调 const better_scroll = throttle(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); // Debounce(事件防抖)： 最后一个人说了算 // fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间 function debounce(fn, delay) { // 定时器 let timer = null; // 将debounce处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 每次事件被触发时，都去清除之前的旧定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(function () { fn.apply(context, args); }, delay); }; } // 用debounce来包装scroll的回调 const better_scroll = debounce(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); 手写 String.prototype.trim 1 2 3 String.prototype.trim = function () { return this.replace(/^\\s+/, \u0026#34;\u0026#34;).replace(/\\s+$/, \u0026#34;\u0026#34;); }; 手写 Array.flat 1 2 3 4 5 6 7 const flat = (arr) =\u0026gt; { const isDeep = arr.some((item) =\u0026gt; item instanceof Array); if (!isDeep) return arr; const res = Array.prototype.concat.apply([], arr); return flat(res); }; 手写去重 1 2 3 4 const unique = (arr) =\u0026gt; { const set = new Set(arr); return [...arr]; }; 手写 setInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const mySetInterval = (fn, delay) =\u0026gt; { let timer = null, isClear = false; function loop() { if (isClear) { isClear = false; clearTimeout(timer); return; } fn(); timer = setTimeout(loop, delay); } timer = setTimeout(loop, delay); return () =\u0026gt; { isClear = true; }; }; 手写 判断类数组 1 2 3 4 5 6 7 8 9 10 const isArrayLikeObject = (arr) =\u0026gt; { if (typeof arr !== \u0026#34;object\u0026#34; || arr === null) return false; const lengthMaxVal = Math.pow(2, 53) - 1; if (!Object.prototype.hasOwnProperty.call(arr, \u0026#34;length\u0026#34;)) return false; if (typeof arr.length !== \u0026#34;number\u0026#34;) return false; if (!isFinite(arr.length)) return false; if (Array !== arr.constructor) return false; if (arr.length \u0026gt; 0 \u0026amp;\u0026amp; arr.length \u0026lt; lengthMaxVal) return true; return false; }; 手写 模拟私有 1 2 3 4 5 6 7 8 9 function cls() { this.a = \u0026#34;who care\u0026#34;; return { getVal: () =\u0026gt; this.a, }; } let obj = new cls(); obj.getVal(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const myWm = new WeakMap(); class Fish { constructor(name) { myWm.set(this, { _fishbone: [ \u0026#34;草鱼\u0026#34;, \u0026#34;鲫鱼\u0026#34;, \u0026#34;青鱼\u0026#34;, \u0026#34;鲤鱼\u0026#34;, \u0026#34;鲢鱼\u0026#34;, \u0026#34;鳙鱼\u0026#34;, \u0026#34;鳊鱼\u0026#34;, \u0026#34;翘嘴\u0026#34;, \u0026#34;餐条\u0026#34;, ], }); this.name = name; } isBone() { return myWm.get(this)._fishbone.includes(this.name); } } // 测试，买了两条鱼 let fish1 = new Fish(\u0026#34;草鱼\u0026#34;); let fish2 = new Fish(\u0026#34;回鱼\u0026#34;); // 返回 true，有刺 console.log(fish1.isBone()); // 返回 false，没有肌间刺 console.log(fish2.isBone()); 获取当前 url 中的参数的值 1 2 3 4 5 const query = (name) =\u0026gt; { const search = location.search; const params = new URLSearchParams(search); return params.get(name); }; 将 URL 参数解析为 JS 对象 1 2 3 4 5 6 7 8 9 function queryToObject() { const res = {}; const search = location.search; const pList = new URLSearchParams(search); pList.forEach((key, val) =\u0026gt; { res[key] = val; }); return res; } ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C/","summary":"手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } 手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj;","title":"有手就行"},{"content":"使用 C++中的哈希表——unordered_map\u0026lt;int, int\u0026gt;\n循环一遍 nums 数组，在每步循环中我们判断 target - nums[i] 是否在哈希表中 ：\n如果是就找到和为 target 的一对数字，直接返回答案即可； 如果否就将 nums[i] 插入哈希表中；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt; hash; for (int i = 0; i \u0026lt; nums.size();i ++) { if (hash.count(target - nums[i])) { return {hash[target - nums[i]], i}; } else { hash[nums[i]] = i; } } return {}; } }; ","permalink":"https://zzydev.top/posts/leetcode/lc01_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"使用 C++中的哈希表——unordered_map\u0026lt;int, int\u0026gt; 循环一遍 nums 数组，在每步循环中我们判断 target - nums[i] 是否在哈希表中 ： 如果是就找到和","title":"Lc01_两数之和"}]