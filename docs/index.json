[{"content":" \u0026nbsp;函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 函数类型 function info(username: string, age: number) : number { return age; } let info: (username: string, age: number) =\u0026gt; number = function(username, age) { return age; } // 接口当名字的函数类型 interface ActionContext { (state: any, commit: any): void } let actionContext: Action = (state, commit) =\u0026gt; { console.log(state) } \u0026nbsp;string 与 String 的区别 1 2 3 4 5 //string和String都可以作为类型 let username: string | String = \u0026#34;zzy\u0026#34; //string. 点不出方法 //String. 可以得到静态方法 如String.fromCharCode、String.fromCodePoint等 \u0026nbsp;对象取值的坑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let obj = {username: \u0026#34;zzy\u0026#34;, age: 18} // 类型推导 obj[\u0026#34;username\u0026#34;] // ✅ let username = \u0026#34;username\u0026#34; obj[username] // ❎ const username = \u0026#34;username\u0026#34; obj[username] // ✅ -------------------------------------------------- let obj:object | Object = {username: \u0026#34;zzy\u0026#34;, age: 18} const username = \u0026#34;username\u0026#34; let res = obj[username] // ❎ 如下图所示 let res = (obj as any)[username] // ✅ \u0026nbsp;never的应用场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // dataFlowAnalysisWithNever 方法穷尽了 DataFlow 的所有可能类型。 // 使用 never 避免出现未来扩展新的类没有对应类型的实现, 目的就是写出类型绝对安全的代码。 type DataFlow = string | number function dataFlowAnalysisWithNever(dataFlow: DataFlow) { if (typeof dataFlow === \u0026#34;string\u0026#34;) { console.log(\u0026#34;字符串类型:\u0026#34;, dataFlow.length); } else if (typeof dataFlow === \u0026#34;number\u0026#34;) { console.log(\u0026#34;数值类型:\u0026#34;, dataFlow.toFixed(2)); }else{ let data=dataFlow // data现在为never类型，假如以后DateFlow的类型加上boolean,那data就变成boolean类型 } } dataFlowAnalysisWithNever(\u0026#34;zzy\u0026#34;) dataFlowAnalysisWithNever(3.1415926) \u0026nbsp;数字枚举和字符串枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //数字枚举 enum A{ A = 10, B = 12, // 没有写值，默认以上一个值自增1 C , D, } console.log(A[\u0026#34;B\u0026#34;]) // 12 数字枚举 可以双重映射 由键到值，也可以由值到键 console.log(A[10]) // A // 字符串枚举 enum WeekEnd { Monday = \u0026#34;monday\u0026#34;, Tuesday = \u0026#34;tuesday\u0026#34;, Wensday = \u0026#34;wensday\u0026#34;, ThirsDay = \u0026#34;thirsDay\u0026#34;, Friday = \u0026#34;friday\u0026#34;, Sarturday = \u0026#34;sarturday\u0026#34;, Sunday = \u0026#34;sunday\u0026#34; } console.log(WeekEnd.Monday) console.log(WeekEnd[\u0026#34;Monday\u0026#34;]) console.log(WeekEnd[\u0026#34;monday\u0026#34;]) // ❎ 不能反向映射 console.log(weekEnd[1]) // ❎ \u0026nbsp;枚举的编译成ES5的真面目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var A; (function (A) { A[A[\u0026#34;A\u0026#34;] = 10] = \u0026#34;A\u0026#34;; A[A[\u0026#34;B\u0026#34;] = 12] = \u0026#34;B\u0026#34;; A[A[\u0026#34;C\u0026#34;] = 13] = \u0026#34;C\u0026#34;; A[A[\u0026#34;D\u0026#34;] = 14] = \u0026#34;D\u0026#34;; })(A || (A = {})); var WeekEnd; (function (WeekEnd) { WeekEnd[\u0026#34;Monday\u0026#34;] = \u0026#34;monday\u0026#34;; WeekEnd[\u0026#34;Tuesday\u0026#34;] = \u0026#34;tuesday\u0026#34;; WeekEnd[\u0026#34;Wensday\u0026#34;] = \u0026#34;wensday\u0026#34;; WeekEnd[\u0026#34;ThirsDay\u0026#34;] = \u0026#34;thirsDay\u0026#34;; WeekEnd[\u0026#34;Friday\u0026#34;] = \u0026#34;friday\u0026#34;; WeekEnd[\u0026#34;Sarturday\u0026#34;] = \u0026#34;sarturday\u0026#34;; WeekEnd[\u0026#34;Sunday\u0026#34;] = \u0026#34;sunday\u0026#34;; })(WeekEnd || (WeekEnd = {})); \u0026nbsp;函数重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 type MessageType = \u0026#34;image\u0026#34; | \u0026#34;audio\u0026#34; | string;//微信消息类型 type Message = { id: number; type: MessageType; sendmessage: string; }; let messages: Message[] = [ //let messages: Array\u0026lt;Message\u0026gt; = [ { id: 1, type: \u0026#39;image\u0026#39;, sendmessage: \u0026#34;我要涩涩.png\u0026#34;, }, { id: 2, type: \u0026#39;audio\u0026#39;, sendmessage: \u0026#34;深夜在浅色床单痛哭失声\u0026#34; }, { id: 3, type: \u0026#39;audio\u0026#39;, sendmessage: \u0026#34;永远失败\u0026#34; }, { id: 4, type: \u0026#39;image\u0026#39;, sendmessage: \u0026#34;不可以涩涩.png\u0026#34; }, { id: 5, type: \u0026#39;image\u0026#39;, sendmessage: \u0026#34;810975指的是8月10号打了9盘吃了7鸡，其中还有一个五连鸡...\u0026#34; }] //不用函数重载来实现 //函数结构不分明,可读性，可维护性变差 function getMessage(value: number | MessageType): Message | undefined | Array\u0026lt;Message\u0026gt; { if (typeof value === \u0026#34;number\u0026#34;) { return messages.find((msg) =\u0026gt; value === msg.id) } else { return messages.filter((msg) =\u0026gt; value === msg.type) } } console.log(getMessage(\u0026#34;audio\u0026#34;)); // TS没有办法运行之前根据传递的值来推导方法最终返回的数据的数据类型 // 只可以根据方法定义的类型展现 //let msg=getMessage(1) //⚠️ console.log(msg.sendMessage)//错误 类型“Message | Message[]”上不存在属性“sendMessage”。 // 类型“Message”上不存在属性“sendMessage” let msg = (\u0026lt;Message\u0026gt;getMessage(1)).sendmessage console.log(\u0026#34;msg:\u0026#34;, msg) function getMessage(value: number): Message//第一个根据数字id来查询单个消息的重载签名 function getMessage(value: MessageType, readRecordCount: number): Message[]//第二个根据消息类型来查询消息数组的重载签名 //实现签名参数个数可以少于重载签名的参数个数，但实现签名如果准备包含重载签名的某个位置的参数 ，那实现签名就必须兼容所有重载签名该位置的参数类型【联合类型或 any 或 unknown 类型的一种】。 //不管重载签名返回值类型是何种类型，实现签名都可以返回 any 类型 或 unknown类型，当然一般我们两者都不选择，让 TS 默认为实现签名自动推导返回值类型。 //由于实现签名第二个参数有默认值，所以这里的重载签名可以没有第二个参数，也可以在实现签名的参数加上可选? function getMessage(value: any, value2: any = 1) { // function getMessage(value: any, value2?: any) { if (typeof value === \u0026#34;number\u0026#34;) { return messages.find((msg) =\u0026gt; { return msg === msg.id }) } else { return messages.filter((msg) =\u0026gt; value === msg.type).splice(0, value2) } } getMessage(1) \u0026nbsp;单件设计模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 第一步：把构造器设置为私有的，不允许外部来创建类的实例【对象】 // 第二步: 至少应该提供一个外部访问的方法或属性，外部可以通过这个方法或属性来得到一个对象 // 所以应该把这个方法设置为静态方法 // 第三步：外部调用第二步提供的静态方法来获取一个对象 export default class MyLocalStorage { static localstorage: MyLocalStorage//静态引用属性 static count: number = 3;//静态的基本类型属性 constructor() { console.log(\u0026#34;这是TS的单件设计模式的静态方法的构造器\u0026#34;); } // 提供一个外部访问的方法, // 通过这个方法用来提供外部得到一个对象的方法 // 1. 带static关键字的方法就是一个静态方法 // 2. 静态方法和对象无关，外部的对象变量不能调用静态方法和静态属性， // 3. 外部可以通过类名来调用 // 静态方法不可以访问实例属性或实例方法【对象属性或对象方法】 public static getInstance() { if (!this.localstorage) {//如果静态对象属性指向创建对象 console.log(\u0026#34;我是一个undefined的静态属性，用来指向一个对象空间的静态属性\u0026#34;) this.localstorage = new MyLocalStorage() } return this.localstorage } public setItem(key: string, value: any) { localStorage.setItem(key, JSON.stringify(value)) } public getItem(key: string) { let value = localStorage.getItem(key) return value != null ? JSON.parse(value) : null; } } ","permalink":"https://zzydev.top/posts/headfirstts/ts%E5%9F%BA%E7%A1%80%E6%8B%BE%E9%81%97/","summary":"\u0026nbsp;函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 函数类型 function info(username: string, age: number) : number { return age; } let info: (username: string, age: number) =\u0026gt; number = function(username, age) { return age; } // 接口当名字的函数类型 interface ActionContext","title":"TS基础拾遗"},{"content":"ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;我是第一段话\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是第二段话\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } const rootElement = document.getElementById(\u0026#34;root\u0026#34;); ReactDOM.render(\u0026lt;App /\u0026gt;, rootElement); 打开 Chrome 的 Performance 面板，点击下图红色圈圈所圈住的这个“记录”按钮： 然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图： 放大该图，定位“src/index.js”这个文件路径，我们就可以找到 ReactDOM.render 方法对应的调用栈，如下图所示： 图中 scheduleUpdateOnFiber 方法的作用是调度更新，在由 ReactDOM.render 发起的首屏渲染这个场景下，它触发的就是 performSyncWorkOnRoot。performSyncWorkOnRoot 开启的正是我们反复强调的 render 阶段；而 commitRoot 方法开启的则是真实 DOM 的渲染过程（commit 阶段）。因此以 scheduleUpdateOnFiber 和 commitRoot 两个方法为界，我们可以大致把 ReactDOM.render 的调用栈划分为三个阶段：\n初始化阶段 render 阶段 commit 阶段 拆解 ReactDOM.render 调用栈——初始化阶段 首先我们提取出初始化过程中涉及的调用栈大图： 图中的方法完成 Fiber 树中基本实体的创建\n在 ReactDOM.render 函数体中，如下面代码所示，调用了 legacyRenderSubtreeIntoContainer：\n1 2 3 4 5 6 7 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ); legacyRenderSubtreeIntoContainer 的关键逻辑如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function legacyRenderSubtreeIntoContainer( parentComponent, children, container, forceHydrate, callback ) { // container 对应的是我们传入的真实 DOM 对象 var root = container._reactRootContainer; // 初始化 fiberRoot 对象 var fiberRoot; // DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空 if (!root) { // 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate ); // legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot fiberRoot = root._internalRoot; // 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可 if (typeof callback === \u0026#34;function\u0026#34;) { var originalCallback = callback; callback = function () { var instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); }; } // Initial mount should not be batched. // 进入 unbatchedUpdates 方法 unbatchedUpdates(function () { updateContainer(children, fiberRoot, parentComponent, callback); }); } else { // else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致 fiberRoot = root._internalRoot; if (typeof callback === \u0026#34;function\u0026#34;) { var _originalCallback = callback; callback = function () { var instance = getPublicRootInstance(fiberRoot); _originalCallback.call(instance); }; } // Update updateContainer(children, fiberRoot, parentComponent, callback); } return getPublicRootInstance(fiberRoot); } 首次渲染过程中 legacyRenderSubtreeIntoContainer 方法的主要逻辑链路： 在这个流程中，你需要关注到 fiberRoot 这个对象。fiberRoot 到底是什么呢？这里我将运行时的 root 和 fiberRoot 为你截取出来，其中 root 对象的结构如下图所示： 可以看出，root 对象（container._reactRootContainer）上有一个 _internalRoot 属性，这个 _internalRoot 也就是 fiberRoot。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容： 或许你会对 current 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“current 对象是一个 FiberNode 实例”这一点，而 FiberNode，正是 Fiber 节点对应的对象类型。current 对象是一个 Fiber 节点，不仅如此，它还是当前 Fiber 树的头部节点。\n考虑到 current 属性对应的 FiberNode 节点，在调用栈中实际是由 createHostRootFiber 方法创建的，React 源码中也有多处以 rootFiber 代指 current 对象，因此下文中我们将以 rootFiber 指代 current 对象。\n读到这里，你脑海中应该不难形成一个这样的指向关系： 其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而 rootFiber 则作为虚拟 DOM 的根节点存在。这两个节点，将是后续整棵 Fiber 树构建的起点。\n接下来，fiberRoot 将和 ReactDOM.render 方法的其他入参一起，被传入 updateContainer 方法，从而形成一个回调。这个回调，正是接下来要调用的 unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates 做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function unbatchedUpdates(fn, a) { // 这里是对上下文的处理，不必纠结 var prevExecutionContext = executionContext; executionContext \u0026amp;= ~BatchedContext; executionContext |= LegacyUnbatchedContext; try { // 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法 return fn(a); } finally { // finally 逻辑里是对回调队列的处理，此处不用太关注 executionContext = prevExecutionContext; if (executionContext === NoContext) { // Flush the immediate callbacks that were scheduled during this batch resetRenderTimer(); flushSyncCallbackQueue(); } } } 在 unbatchedUpdates 函数体里，当下你只需要 Get 到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn 是什么呢？fn 是一个针对 updateContainer 的调用：\n1 2 3 unbatchedUpdates(function () { updateContainer(children, fiberRoot, parentComponent, callback); }); 接下来我们很有必要去看看 updateContainer 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function updateContainer(element, container, parentComponent, callback) { ...... // 这是一个 event 相关的入参，此处不必关注 var eventTime = requestEventTime(); ...... // 这是一个比较关键的入参，lane 表示优先级 var lane = requestUpdateLane(current$1); // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新 var update = createUpdate(eventTime, lane); // update 的 payload 对应的是一个 React 元素 update.payload = { element: element }; // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback callback = callback === undefined ? null : callback; if (callback !== null) { { if (typeof callback !== \u0026#39;function\u0026#39;) { error(\u0026#39;render(...): Expected the last optional `callback` argument to be a \u0026#39; + \u0026#39;function. Instead received: %s.\u0026#39;, callback); } } update.callback = callback; } // 将 update 入队 enqueueUpdate(current$1, update); // 调度 fiberRoot scheduleUpdateOnFiber(current$1, lane, eventTime); // 返回当前节点（fiberRoot）的优先级 return lane; } updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：\n请求当前 Fiber 节点的 lane（优先级）；\n结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；\n调度当前节点（rootFiber）。\n函数体中的 scheduleWork 其实就是 scheduleUpdateOnFiber，scheduleUpdateOnFiber 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是在 ReactDOM.render 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：\nperformSyncWorkOnRoot 直译过来就是“执行根节点的同步任务”，这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。\n前面我们曾经提到过，performSyncWorkOnRoot 是 render 阶段的起点，render 阶段的任务就是完成 Fiber 树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render 阶段应该是一个可打断的异步过程（下一讲我们就将针对 render 过程作详细的逻辑拆解）。\n而现在，我相信你心里更多的疑惑在于：都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢？\n关于异步模式下的首次渲染链路 Concurrent 模式开启后，首次渲染的调用栈变成了如下图所示的样子： 乍一看，好像和 ReactDOM.render 差别很大，其实不然。图中 createRoot 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示： 我们拉近一点来看，如下图所示： 你会发现这地方也调用了一个 render。再顺着这个调用往下看，发现有大量的熟悉面孔：updateContainer、requestUpdateLane、createUpdate、scheduleUpdateOnFiber\u0026hellip;\u0026hellip;这些函数在 ReactDOM.render 的调用栈中也出现过。\n其实，当前你看到的这个 render 调用链路，和 ReactDOM.render 的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber 的这个判断里： 在异步渲染模式下，由于请求到的 lane 不再是 SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot 这个调用，而是会转而执行 else 中调度相关的逻辑。\n这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 requestUpdateLane 函数为例，下面是它局部的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 function requestUpdateLane(fiber) { // 获取 mode 属性 var mode = fiber.mode; // 结合 mode 属性判断当前的 if ((mode \u0026amp; BlockingMode) === NoMode) { return SyncLane; } else if ((mode \u0026amp; ConcurrentMode) === NoMode) { return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane; } ...... return lane; } 上面代码中需要注意 fiber 节点上的 mode 属性：React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式。\n因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。\n关于异步挂载/更新的实现细节，我们将在后续的第 16 讲“Fiber 架构实现原理与编码形态”中详细探讨。\n","permalink":"https://zzydev.top/posts/headfirstreact/10_reactdom.render%E7%9A%84%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%B8%8A/","summary":"ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是标题\u0026lt;/h1\u0026gt; \u0026l","title":"10.ReactDom.render的渲染链路(上)"},{"content":" \u0026nbsp;请按以下要求实现 compose 方法 1 2 3 4 5 6 7 8 9 10 11 12 var list = [ [\u0026#34;热\u0026#34;, \u0026#34;冷\u0026#34;, \u0026#34;冰\u0026#34;], [\u0026#34;大\u0026#34;, \u0026#34;中\u0026#34;, \u0026#34;小\u0026#34;], [\u0026#34;重辣\u0026#34;, \u0026#34;微辣\u0026#34;], [\u0026#34;重麻\u0026#34;, \u0026#34;微麻\u0026#34;], ]; // 输出所有维度的组合，如 [[\u0026#39;热\u0026#39;, \u0026#39;冷\u0026#39;\u0026#39;], [\u0026#39;大\u0026#39;, \u0026#39;中\u0026#39;]] =\u0026gt; 热 + 大，热 + 中，冷 + 大，冷 + 中 function compose(list) {} compose(list); \u0026nbsp;根据运算优先级添加括号 现已知一个字符串是由正整数和加减乘除四个运算符(+ - * /)组成。\n例如存在字符串 const str = '11+2-3*4+5/2*4+10/5'，现在需要将高优先级运算，用小括号包裹起来，例如结果为 '11+2-(3*4)+(5/2*4)+(10/5)'。注意可能会出现连续的乘除运算，需要包裹到一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function addBrackets(str) { return str .split(\u0026#34;-\u0026#34;) .map((item) =\u0026gt; { if (item.includes(\u0026#34;+\u0026#34;)) { return item .split(\u0026#34;+\u0026#34;) .map((val) =\u0026gt; { if (val.includes(\u0026#34;*\u0026#34;) || val.includes(\u0026#34;/\u0026#34;)) { return `(${val})`; } return val; }) .join(\u0026#34;+\u0026#34;); } else { return item; } }) .join(\u0026#34;-\u0026#34;); } \u0026nbsp;实现一个类，其实例可以链式调用，它有一个sleep方法 1 2 3 4 5 6 7 8 const badboy = new PlayBoy(\u0026#34;zzydev\u0026#34;); // [译]playboy n.渣男 badboy.sayHi().sleep(1000).do(\u0026#34;学穿搭\u0026#34;).sleep(2000).do(\u0026#34;学瑜伽\u0026#34;); // 输出 // 妹妹你好，我是zzydev // 1s 之后 // 我在学穿搭 // 2s 之后 // 我在学瑜伽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 首先 定义一个类 PlayBoy class PlayBoy { constructor(name) { this.name = name; this.queue = []; //创建一个任务队列（利用队列的先进先出性质来模拟链式调用函数的执行顺序） setTimeout(() =\u0026gt; { // 进入异步任务队列 也是开启 自定义任务队列 queue 的入口 this.next(); // next是类PlayBoy 原型上的方法，用来从queue 任务队列中取出函数执行 }, 0); return this; } } PlayBoy.prototype.sayHi = function () { const fn = () =\u0026gt; { console.log(\u0026#34;妹妹你好，我是\u0026#34;, this.name); this.next(); }; this.queue.push(fn); return this; }; PlayBoy.prototype.sleep = function (timer) { const fn = () =\u0026gt; { setTimeout(() =\u0026gt; { this.next(); }, timer); }; this.queue.push(fn); return this; }; PlayBoy.prototype.do = function (...args) { const fn = () =\u0026gt; { console.log(\u0026#34;我在\u0026#34;, ...args); this.next(); }; this.queue.push(fn); return this; }; PlayBoy.prototype.next = function () { const fn = this.queue.shift(); // 从任务队列中取出函数 函数存在的话即调用 fn \u0026amp;\u0026amp; fn(); }; new PlayBoy(\u0026#34;zzydev\u0026#34;).sayHi().sleep(1000).do(\u0026#34;学穿搭\u0026#34;).sleep(2000).do(\u0026#34;学瑜伽\u0026#34;); \u0026nbsp;模拟 let 和 const 块级作用域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 模拟let (function () { var a = 1; console.log(\u0026#34;内部a:\u0026#34;, a); })(); //模拟const const值不可变 (function () { var a = { a: 1, b: 2 }; //对象 if (Object.prototype.toString.call(a) === \u0026#34;[object Object]\u0026#34;) { var b = a; a.c = 3; //或者 // a = {}; if (a !== b) { console.error(\u0026#34;变量不能再次赋值\u0026#34;); a = b; } console.log(a); } else { //基础类型值 var prev = a; a = 2; if (a !== prev) { console.error(\u0026#34;变量不能再次赋值\u0026#34;); a = prev; } console.log(a); } })(); \u0026nbsp;使用Promise封装一个异步加载图片的方法 1 2 3 4 5 6 7 8 9 10 11 function loadImg(url) { return new Promise((resolve, reject) =\u0026gt; { const img = new Image(); img.onload = function() { resolve(img); }; img.onerror = function() { reject(new Error(\u0026#39;Could not load image at\u0026#39; + url)); }; img.src = url; }); \u0026nbsp;实现事件委托 循环创建 10 个 li 标签，当点击 li 标签时，打印其对应的索引\n1 \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function loadNode(len) { var html = \u0026#34;\u0026#34;; for (let index = 0; index \u0026lt; 10; index++) { html += \u0026#34;\u0026lt;li\u0026gt;\u0026#34; + index + \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } var list = document.getElementById(\u0026#34;list\u0026#34;); list.onclick = function (event) { event = event || window.event; var target = event.target || event.srcElement; if (target.nodeName.toLowerCase() === \u0026#34;li\u0026#34;) { console.log(target.innerText); } }; list.innerHTML = html; } loadNode(); \u0026nbsp;模拟私有 1 2 3 4 5 6 7 8 9 function cls() { this.a = \u0026#34;who care\u0026#34;; return { getVal: () =\u0026gt; this.a, }; } let obj = new cls(); obj.getVal(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const myWm = new WeakMap(); class Fish { constructor(name) { myWm.set(this, { _fishbone: [ \u0026#34;草鱼\u0026#34;, \u0026#34;鲫鱼\u0026#34;, \u0026#34;青鱼\u0026#34;, \u0026#34;鲤鱼\u0026#34;, \u0026#34;鲢鱼\u0026#34;, \u0026#34;鳙鱼\u0026#34;, \u0026#34;鳊鱼\u0026#34;, \u0026#34;翘嘴\u0026#34;, \u0026#34;餐条\u0026#34;, ], }); this.name = name; } isBone() { return myWm.get(this)._fishbone.includes(this.name); } } // 测试，买了两条鱼 let fish1 = new Fish(\u0026#34;草鱼\u0026#34;); let fish2 = new Fish(\u0026#34;回鱼\u0026#34;); // 返回 true，有刺 console.log(fish1.isBone()); // 返回 false，没有肌间刺 console.log(fish2.isBone()); \u0026nbsp;如何实现上拉加载，下拉刷新？ 上拉加载 \u0026nbsp;判断一个对象是普通对象还是通过类创建的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const isPlainObject = (obj: any): boolean =\u0026gt; { if (typeof obj !== \u0026#34;object\u0026#34; || obj === null) { return false; } let proto = Object.getPrototypeOf(obj); if (proto === null) { return true; } let baseProto = proto; while (Object.getPrototypeOf(baseProto) !== null) { baseProto = Object.getPrototypeOf(baseProto); } return proto === baseProto; }; \u0026nbsp;图片加载失败处理方式 1 2 3 \u0026lt;!-- 图片加载失败，使用图片自带的 error 事件处理即可 --\u0026gt; \u0026lt;img src={imgSrc} onError={event =\u0026gt; { event.currentTarget.src = defaultSrc; }} /\u0026gt; \u0026nbsp;判断是不是NaN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function isNaNVal(val) { return Object.is(val, NaN); } function isNaNVal(val) { return val !== val; } function isNaNVal(val) { return typeof val === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; isNaN(val); } if (!(\u0026#34;isNaN\u0026#34; in Number)) { Number.isNaN = function (val) { return typeof val === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; isNaN(val); }; } // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness var arr = [NaN]; arr.indexOf(NaN); // -1 Number::equal arr.includes(NaN); // true Number::sameValueZero [ ] ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%88%91%E7%9A%84%E6%8B%B7%E9%9D%A2%E7%BB%8F_2/","summary":"\u0026nbsp;请按以下要求实现 compose 方法 1 2 3 4 5 6 7 8 9 10 11 12 var list = [ [\u0026#34;热\u0026#34;, \u0026#34;冷\u0026#34;, \u0026#34;冰\u0026#34;]","title":"我的拷面经（二）"},{"content":" 我是没事的时候\n在无聊的时候，想的时候\n到一个地方，不相同的地方\n到这个地方来，来到吧\n可以瞧瞧，不一样的地方\n不相同的地方\n很多，很多……\n\u0026mdash;\u0026mdash;\u0026mdash; 淳·简·拉基茨德\n\u0026nbsp;Symbol不能使用new操作符，那如何得到一个Symbol类型的对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //利用一个函数的call方法来强迫产生装箱 var symbolObject = function () { return this; }.call(Symbol(\u0026#34;a\u0026#34;)); console.log(typeof symbolObject); //object console.log(symbolObject instanceof Symbol); //true console.log(symbolObject.constructor == Symbol); //true //使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力 var symbolObject = Object(Symbol(\u0026#34;a\u0026#34;)); console.log(typeof symbolObject); //object console.log(symbolObject instanceof Symbol); //true console.log(symbolObject.constructor == Symbol); //true //每一类装箱对象皆有私有的Class属性，这些属性可以用 Object.prototype.toString 获取： console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol] //在JS中，没有任何方法可以更改私有的Class属性 \u0026nbsp;new fn与new fn()有什么区别吗？ 1 2 3 4 5 6 7 8 9 10 11 function Parent() { this.num = 1; } console.log(new Parent()); //输出Parent对象：{num:1} console.log(new Parent()); //输出Parent对象：{num:1} function Parent() { this.num = 1; } console.log(new Parent().num); //1 console.log(new Parent.num()); //报错 从报错信息来看，new Parent.num执行顺序是这样的：先执行Parent.num，此时返回结果为undefined；后执行new，因new后面必须跟构造函数，所以new undefined会报错。\nnew Parent().num相当于(new Parent()).num，所以结果返回 1。\n\u0026nbsp;拆箱转换相关问题 对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的原始类型。\nSymbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var o = { valueOf: () =\u0026gt; { console.log(\u0026#34;valueOf\u0026#34;); return {}; }, toString: () =\u0026gt; { console.log(\u0026#34;toString\u0026#34;); return {}; }, }; o[Symbol.toPrimitive] = () =\u0026gt; { return \u0026#34;hello\u0026#34;; }; console.log(o + \u0026#34;\u0026#34;); // hello // 练习一 const arr = [4, 10]; arr[Symbol.toPrimitive] = function (hint) { return hint; }; arr.valueOf = function () { return this; }; const obj = {} + arr + obj + arr + obj; //\u0026#39;NaN[object Object]default[object Object]\u0026#39; { } +arr; //[object Object]default\u0026#39; // 练习二 const val = (([] == ![][(+val, [] + 1)]) == // \u0026#39;\u0026#39;转数字为0 [1, 1] + [][(+val, [] + 1)]) == //[1, \u0026#39;1\u0026#39;].toString() == [1, 1] + \u0026#39;\u0026#39; =\u0026gt; \u0026#39;1, 1\u0026#39; == \u0026#39;1, 1\u0026#39; true [1, \u0026#34;1\u0026#34;]; // false \u0026nbsp;[]\u0026#43;[],[]\u0026#43;{},{}\u0026#43;[],{}\u0026#43;{} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 二元操作符 + 的规则 // 如果操作数是对象，则对象会转换为原始值 // 如果其中一个操作数是字符串，另一个操作数也会转换为字符串进行拼接 // 否则两个操作数都将转换为数字或者NaN，进行加法操作 10n + 10 Symbol(10) + 10 // 对象转换为原始数据类型的值 // Symbol.toPrimitive 优先级最高 // Object.prototype.valueOf // 调用 valueOf，如果转换为原始类型，就返回转换的值。如果不返回原始类型的值就调用toString。 // Object.prototype.toString // 调用toString，如果转换为原始类型，就返回转换的值。如果不返回原始类型的值就调用valueOf。 typeof [][Symbol.toPrimitive] // undefined [].valueOf() // [] [].toString() // \u0026#39;\u0026#39; 所以[]转换为原始值是‘’ typeof {}[Symbol.toPrimitive] //undefined ({}).valueOf() // {} ({}).toString() // \u0026#39;[object Object]\u0026#39; [] + [] // \u0026#34;\u0026#34; [] + {} // \u0026#34;[object Object]\u0026#34; {} + [] // 0 相当于 {}; + [] {} + {} // Chrome \u0026#39;[object Object][object Object]\u0026#39; 其他浏览器 NaN \u0026nbsp;toString相关问题 1 2 3 4 5 6 7 8 9 10 11 const user = { name: \u0026#34;zzy\u0026#34;, id: 233, valueOf() { return this.id; }, }; console.log(`${user}`); //会调用原型链上的toString 返回[object Object] Object.prototype.toString = undefined; console.log(`${user}`); // 233 1 Object.prototype.toString.call(Boolean.prototype); // [object Boolean] \u0026nbsp;px % rem vh/vw有什么区别 px 是绝对单位，\n% 是相对于父元素的比例，\nem 是相对于当前元素的 font-size，rem 是相对与根(root)元素的 font-size，\n1 2 3 4 5 6 7 \u0026lt;div style=\u0026#34;font-size:20px\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;text-indent: 2em; font-size: 40px\u0026#34;\u0026gt;首行缩进\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;text-indent: 2em\u0026#34;\u0026gt; 这个元素的font-size继承了父元素的font-size，所以缩进比上面的小一些 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-size: 2rem\u0026#34;\u0026gt;相对根元素font-size\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; vh/vw 是屏幕的百分比\nvmin 是 min(屏幕宽度,屏幕高度)、vmax 是 max(屏幕宽度,屏幕高度)\n\u0026nbsp;for in 和 for of的区别 遍历对象：for\u0026hellip;in 可以, for\u0026hellip;of 不可以\n遍历 Map、Set：for\u0026hellip;of 可以, for\u0026hellip;in 不可以\n遍历 generator：for\u0026hellip;of 可以, for\u0026hellip;in 不可以\n1 2 3 4 5 6 7 8 function* gen() { yield 1; yield 2; yield 3; } for (let i of gen()) { console.log(i); } for\u0026hellip;in 用于可枚举数据，如对象、数组、字符串\n1 2 3 4 5 6 Object.defineProperty(obj, \u0026#34;key\u0026#34;, { enumerable: true, // 可枚举 configurable: false, writable: false, value: \u0026#34;static\u0026#34;, }); for\u0026hellip;of 用于可迭代数据，如数组、字符串、Set、Map\n存在 Symbol.iterator 属性的对象，可以用 for\u0026hellip;of 迭代\nfor await of 有什么作用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function createPromise(val) { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(val); }, 1000); }); } (async function () { const p1 = createPromise(100); const p2 = createPromise(200); const res1 = await p1; console.log(res1); const res2 = await p2; console.log(res2); //直接三个一起打印出来 const list = [p1, p2]; Promise.all(list).then((res) =\u0026gt; console.log(res)); // Promise.all的代替品 //直接三个一起打印出来 for await (let res of list) { console.log(res); } //每隔一秒打印一个 const arr = [100, 200]; for (let num of arr) { const res = await createPromise(num); console.log(res); } })(); \u0026nbsp;offsetHeight、scrollHeight和clientHeight的区别 scrollHeight\nscrollTop\nscrollLeft\n\u0026nbsp;HTMLCollection和NodeList的区别 Node 是 Element 的基类\nElement 是其他 HTML 元素的基类，如 HTMLDivElement HTMLCollection 是 Element 的集合\nNodeList 是 Node 的集合\nHTMLCollection 和 NodeList 都是类数组\n1 2 3 4 \u0026lt;p id=\u0026#34;p1\u0026#34;\u0026gt; \u0026lt;b\u0026gt;node\u0026lt;/b\u0026gt; vs \u0026lt;em\u0026gt;element\u0026lt;/em \u0026gt;\u0026lt;!--注释--\u0026gt; \u0026lt;/p\u0026gt; 1 2 3 4 5 6 const p1 = document.getElementById(\u0026#34;p1\u0026#34;); console.log(p1.children); // 不包含Text和Comment 是HTMLCollection类型 console.log(p1.childNode); // 包含Text和Comment 是NodeList类型 p1.tagName; // Element类型属性 p1.nodeName; // Node类型属性 \u0026nbsp;Node和浏览器的EventLoop有什么区别 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则:\n浏览器中的 EventLoop 函数会在执行栈中执行，当遇到异步代码的时候，会被挂起在 Task 队列中，一旦执行栈为空，就会从 Task 队列中拿出需要执行的代码执行，所以本质上讲 JS 中的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。\n宏任务(script、setTimeout、setInterval、setImmidiate、I/O、UI Rendering) 微任务(procress.nextTick、Promise.then、Object.observe、mutataionObserver) Event Loop 执行顺序如下所示：\n首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 1 2 3 4 5 6 7 8 9 10 11 12 13 const $p1 = $(\u0026#39;\u0026lt;p\u0026gt;一段文字\u0026lt;/p\u0026gt;\u0026#39;) const $p2 = $(\u0026#39;\u0026lt;p\u0026gt;一段文字\u0026lt;/p\u0026gt;\u0026#39;) const $p3 = $(\u0026#39;\u0026lt;p\u0026gt;一段文字\u0026lt;/p\u0026gt;\u0026#39;) $(\u0026#39;#container\u0026#39;).append($p1).append($p2).append($p3) //微任务: DOM渲染前触发 Promise.resolve().then(() =\u0026gt; { console.log(\u0026#39;length1\u0026#39;, $(\u0026#39;#container\u0026#39;).children.length) // 3 alert(\u0026#39;Promise then\u0026#39;) // 出现alert弹窗，DOM此时未渲染 }) //宏任务：DOM渲染后触发 setTimeout(()=\u0026gt; { console.log(\u0026#39;setTimeout\u0026#39;) }) \u0026nbsp;回顾Promise知识点 手写Promise\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 //Promise 有三种状态：pending、resolved、rejected //pending 状态的Promise，不会触发 then 或 catch //resolved 状态的 Promise， 会触发 then 回调函数 //rejected 状态的 Promise， 会触发 catch 回调函数 const p1 = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(); }); }); console.log(\u0026#34;p1\u0026#34;, p1); // Promise {\u0026lt;pending\u0026gt;} setTimeout(() =\u0026gt; console.log(\u0026#34;p1-setTimeout\u0026#34;, p1)); // Promise { \u0026lt;resolved\u0026gt; } // ------------------------------------------------------------------------- // then 正常返回 resolved 状态的 Promise，里面有报错则返回 rejected 状态的 Promise // catch 正常返回 resolved 状态的 Promise，里面有报错则返回 rejected 状态的 Promise const p1 = Promise.reject(\u0026#34;my error\u0026#34;).catch((err) =\u0026gt; console.log(err)); console.log(\u0026#34;p1\u0026#34;, p1); // ⚠️ Promise { \u0026lt;resolved\u0026gt; } const p2 = Promise.reject(\u0026#34;my error\u0026#34;).then( (err) =\u0026gt; throw new Error(\u0026#34;catch error\u0026#34;) ); console.log(\u0026#34;p2\u0026#34;, p2); // ⚠️ Promise { \u0026lt;rejected\u0026gt; } Promise.resolve().then(()=\u0026gt;console.log(1)).catch(() =\u0026gt; { return new Error(\u0026#34;err\u0026#34;) }).then(()=\u0026gt;console.log(3)).catch((err) =\u0026gt; console.log(err) ) // ⚠️ 1 3 // ------------------------------------------------------------------------- // async 函数返回的是 Promise 对象 // await 相当于 Promise 的 then // try/catch 可捕获异常，相当于 Promise 的 catch async function fn1() { // return 100; 相当于 return Promise.resolve(100) return Promise.resolve(100); } const res1 = fn1(); // res1: Promise { \u0026lt;resolved\u0026gt; } !(async function () { const p1 = Promise.resolve(100); const data = await p1; // await 相当于 Promise 的 then console.log(data); })(); !(async function () { const data = await 100; // 相当于 await Promise.resolve(100); console.log(data); })(); !(async function () { const p1 = Promise.reject(new Error(\u0026#34;my error\u0026#34;)); try { const data = await p1; console.log(data); } catch (err) { console.error(err); // try catch 相当于 Promise 的 catch } })(); // ------------------------------------------------------------------------- async function async1() { console.log(\u0026#34;async1 start\u0026#34;); // 2 await async2(); //先执行 async2,再执行 await 的操作 // await 后面的内容，都可以看成 callback 的内容，微任务 console.log(\u0026#34;async1 end\u0026#34;); // 6 } async function async2() { console.log(\u0026#34;async2 start\u0026#34;); // 3 } console.log(\u0026#34;script start\u0026#34;); // 1 setTimeout(() =\u0026gt; { // 宏任务 console.log(\u0026#34;setTimeout\u0026#34;) // 8 }) async1(); //初始化Promise时，传入的函数会立刻被执行 new Promise(function(resolve) { console.log(\u0026#34;Promise1\u0026#34;) // 4 resolve() }).then(() =\u0026gt; { // 微任务 console.log(\u0026#34;Promise2\u0026#34;) // 7 }) console.log(\u0026#34;script end\u0026#34;); // 5 //同步代码执行完毕 (call stack被清空) //执行微任务 //尝试进行DOM渲染 //触发EventLoop 执行宏任务 \u0026nbsp;浏览器缓存:强缓存和协商缓存 强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。\n","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%88%91%E7%9A%84%E6%8B%B7%E9%9D%A2%E7%BB%8F_1/","summary":"我是没事的时候 在无聊的时候，想的时候 到一个地方，不相同的地方 到这个地方来，来到吧 可以瞧瞧，不一样的地方 不相同的地方 很多，很多…… \u0026mdash;\u0026mdash;\u0026mdash; 淳·简·拉","title":"我的拷面经（一）"},{"content":"babel是什么\nbabel 的编译流程 \u0026nbsp;parse parse 阶段的目的是把源码字符串转换成机器能够理解的抽象语法树(AST)，这个过程分为词法分析、语法分析。\nlet name = 'zzydev' 经过词法分析得到 let、 name、 =、 \u0026quot;zzydev\u0026quot;Token串。\n词法分析的工作是将一个长长的字符串识别出一个个的单词，这一个个单词就是 Token。 读取token串，把它转化为AST，这个过程就叫语法分析。\n\u0026nbsp;transform transform 阶段是对 parse 生成的 AST 的处理，会进行 AST 的遍历，遍历的过程中处理到不同的 AST 节点会调用注册的相应的 visitor 函数，visitor 函数里可以对 AST 节点进行增删改，返回新的 AST（可以指定是否继续遍历新生成的 AST）。这样遍历完一遍 AST 之后就完成了对代码的修改。\n\u0026nbsp;generate 把转换后的 AST 打印成目标代码，并生成 sourcemap\n","permalink":"https://zzydev.top/posts/headfirstbabel/1_%E5%88%9D%E8%A7%81babel/","summary":"babel是什么 babel 的编译流程 \u0026nbsp;parse parse 阶段的目的是把源码字符串转换成机器能够理解的抽象语法树(AST)，这个过程分为词法分析、语法分析。 let name = 'zzydev' 经","title":"1_初见Babel"},{"content":"前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。\n在这样的机制下，若 JavaScript 线程长时间地占用了主线程，那么**渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”。**一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，事件线程也在等待 JavaScript，这就导致你触发的事件也将是难以被响应的。\n为什么会产生“卡顿”这样的困局？ Stack Reconciler 需要的（同步递归）调和时间很长，这就意味着 JavaScript 线程将长时间地占用主线程，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题。\n设计思想：Fiber 是如何解决问题的 Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”。纤程的出现，意在对渲染过程实现更加精细的控制。\n从架构角度 Fiber 是对 React 核心算法（即调和过程）的重写 从编码角度 Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM” 从工作流的角度 Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。 Fiber 架构的应用目的，按照 React 官方的说法，是实现“增量渲染”。所谓“增量渲染”，通俗来说就是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里面。不过严格来说，增量渲染其实也只是一种手段，实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验。\nFiber 架构核心：“可中断”“可恢复”与“优先级” React15 架构 React15 架构可以分为两层：\nReconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Reconciler 协调器 我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等 API 触发更新。\n每当有更新发生时，Reconciler会做如下工作：\n调用函数组件、或 class 组件的render方法，将返回的 JSX 转化为虚拟 DOM 将虚拟 DOM 和上次更新时的虚拟 DOM 对比 通过对比找出本次更新中变化的虚拟 DOM 通知Renderer将变化的虚拟 DOM 渲染到页面上 你可以在这里 看到React官方对Reconciler的解释\nReact15 架构的缺点 在Reconciler中，mount的组件会调用mountComponent ，update的组件会调用updateComponent 。这两个方法都会递归更新子组件。\nReact16 架构 React16 架构可以分为三层：\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 相较于 React15，React16 中新增了Scheduler（调度器）\nScheduler（调度器） 既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。\n其实部分浏览器已经实现了这个 API，这就是requestIdleCallback。但是由于以下因素，React放弃使用：\n浏览器兼容性 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的requestIdleCallback触发的频率会变得很低 基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。\nScheduler 是独立于React的库\nReconciler（协调器） 我们知道，在 React15 中Reconciler是递归处理虚拟 DOM 的。让我们看看React16 的 Reconciler。\n我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。\n1 2 3 4 5 6 function workLoopConcurrent() { // Perform work until Scheduler asks us to yield while (workInProgress !== null \u0026amp;\u0026amp; !shouldYield()) { workInProgress = performUnitOfWork(workInProgress); } } 那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？\n在 React16 中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上代表增/删/更新的标记，类似这样：\n1 2 3 4 export const Placement = /* */ 0b0000000000010; export const Update = /* */ 0b0000000000100; export const PlacementAndUpdate = /* */ 0b0000000000110; export const Deletion = /* */ 0b0000000001000; 全部的标记见这里\n整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。\n你可以在这里看到React官方对 React16 新Reconciler的解释\nRenderer（渲染器） Renderer根据Reconciler为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。\n总结 在这套新的架构模式下，更新的处理工作流变成了这样：首先，每个更新任务都会被赋予一个优先级。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”。\nFiber 架构对生命周期的影响 Fiber 对生命周期的影响\n","permalink":"https://zzydev.top/posts/headfirstreact/9_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/","summary":"前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂","title":"9.如何理解Fiber架构的迭代动机与设计思想"},{"content":"从一道面试题说起 其他 setState 原理的文章\nonline Demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import React from \u0026#34;react\u0026#34;; import \u0026#34;./styles.css\u0026#34;; export default class App extends React.Component { state = { count: 0, }; increment = () =\u0026gt; { console.log(\u0026#34;increment setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;increment setState后的count\u0026#34;, this.state.count); }; triple = () =\u0026gt; { console.log(\u0026#34;triple setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); this.setState({ count: this.state.count + 1, }); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;triple setState后的count\u0026#34;, this.state.count); }; reduce = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;点我增加\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.triple}\u0026gt;点我增加三倍\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.reduce}\u0026gt;点我减少\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 结果打印如下： 异步的动机和原理——批量更新 从图上我们可以看出，一个完整的更新流程，涉及了包括 re-render（重渲染） 在内的多个步骤。re-render 本身涉及对 DOM 的操作，它会带来较大的性能开销。假如说“一次 setState 就触发一个完整的更新流程”这个结论成立，那么每一次 setState 的调用都会触发一次 re-render，我们的视图很可能没刷新几次就卡死了。这个过程如我们下面代码中的箭头流程图所示：\n1 2 3 4 5 6 7 8 9 this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); this.setState({ count: this.state.count + 1 ===\u0026gt; shouldComponentUpdate-\u0026gt;componentWillUpdate-\u0026gt;render-\u0026gt;componentDidUpdate }); 事实上，这正是 setState 异步的一个重要的动机——避免频繁的 re-render。\n在实际的 React 运行时中，setState 异步的实现方式有点类似于 Vue 的 $nextTick 和浏览器里的 Event-Loop：每来一个 setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。 这个过程，叫作“批量更新”，批量更新的过程正如下面代码中的箭头流程图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count + 1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队，[count + 1的任务，count + 1的任务] }); this.setState({ count: this.state.count + 1 ===\u0026gt; 入队, [count + 1的任务，count + 1的任务, count + 1的任务] }); ↓ 合并 state，[count + 1的任务] ↓ 执行 count + 1的任务 值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。因此就算我们在 React 中写了这样一个 100 次的 setState 循环：\n1 2 3 4 5 6 7 8 9 test = () =\u0026gt; { console.log(\u0026#34;循环100次 setState前的count\u0026#34;, this.state.count); for (let i = 0; i \u0026lt; 100; i++) { this.setState({ count: this.state.count + 1, }); } console.log(\u0026#34;循环100次 setState后的count\u0026#34;, this.state.count); }; 也只是会增加 state 任务入队的次数，并不会带来频繁的 re-render。当 100 次调用结束后，仅仅是 state 的任务队列内容发生了变化， state 本身并不会立刻改变：\n“同步现象”背后的故事：从源码角度看 setState 工作流\n读到这里，相信你对异步这回事多少有些眉目了。接下来我们就要重点理解刚刚代码里最诡异的一部分——setState 的同步现象：\n1 2 3 4 5 6 7 8 9 reduce = () =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); }; 从题目上看，setState 似乎是在 setTimeout 函数的“保护”之下，才有了同步这一“特异功能”。事实也的确如此，假如我们把 setTimeout 摘掉，setState 前后的 console 表现将会与 increment 方法中无异：\n1 2 3 4 5 6 7 8 9 reduce = () =\u0026gt; { // setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); // },0); }; 点击后的输出结果如下图所示：\n现在问题就变得清晰多了：为什么 setTimeout 可以将 setState 的执行顺序从异步变为同步？\n这里我先给出一个结论：并不是 setTimeout 改变了 setState，而是 setTimeout 帮助 setState “逃脱”了 React 对它的管控。只要是在 React 管控下的 setState，一定是异步的。\n接下来我们就从 React 源码里，去寻求佐证这个结论的线索。\n解读 setState 工作流 接下来我们就沿着这个流程，逐个在源码中对号入座。首先是 setState 入口函数：\n1 2 3 4 5 6 ReactComponent.prototype.setState = function (partialState, callback) { this.updater.enqueueSetState(this, partialState); if (callback) { this.updater.enqueueCallback(this, callback, \u0026#34;setState\u0026#34;); } }; 入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。这里我们以对象形式的入参为例，可以看到它直接调用了 this.updater.enqueueSetState 这个方法：\n1 2 3 4 5 6 7 8 9 enqueueSetState: function (publicInstance, partialState) { // 根据 this 拿到对应的组件实例 var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, \u0026#39;setState\u0026#39;); // 这个 queue 对应的就是一个组件实例的 state 数组 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); // enqueueUpdate 用来处理当前的组件实例 enqueueUpdate(internalInstance); } 总结一下，enqueueSetState 做了两件事：\n将新的 state 放进组件的状态队列里； 用 enqueueUpdate 来处理将要更新的实例对象。 继续往下走，看看 enqueueUpdate 做了什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function enqueueUpdate(component) { ensureInjected(); // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段 if (!batchingStrategy.isBatchingUpdates) { // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件 batchingStrategy.batchedUpdates(enqueueUpdate, component); return; } // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等” dirtyComponents.push(component); if (component._updateBatchNumber == null) { component._updateBatchNumber = updateBatchNumber + 1; } } enqueueUpdate 引出了一个关键的对象——batchingStrategy，该对象所具备的 isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；其中的 batchedUpdates 方法更是能够直接发起更新流程。由此我们可以大胆推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * batchingStrategy源码 **/ var ReactDefaultBatchingStrategy = { // 全局唯一的锁标识 isBatchingUpdates: false, // 发起更新动作的方法 batchedUpdates: function (callback, a, b, c, d, e) { // 缓存锁变量 var alreadyBatchingStrategy = ReactDefaultBatchingStrategy.isBatchingUpdates; // 把锁“锁上” ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingStrategy) { callback(a, b, c, d, e); } else { // 启动事务，将 callback 放进事务里执行 transaction.perform(callback, null, a, b, c, d, e); } }, }; batchingStrategy 对象并不复杂，你可以理解为它是一个“锁管理器”。\n这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。\n理解了批量更新整体的管理机制，还需要注意 batchedUpdates 中，有一个引人注目的调用：\n1 transaction.perform(callback, null, a, b, c, d, e); 这行代码为我们引出了一个更为硬核的概念——React 中的 Transaction（事务）机制。\n理解 React 中的 Transaction（事务） 机制 Transaction 在 React 源码中的分布可以说非常广泛。如果你在 Debug React 项目的过程中，发现函数调用栈中出现了 initialize、perform、close、closeAll 或者 notifyAll 这样的方法名，那么很可能你当前就处于一个 Trasaction 中。\nTransaction 在 React 源码中表现为一个核心类，React 官方曾经这样描述它：Transaction 是创建一个黑盒，该黑盒能够封装任何的方法。因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行），实例化 Transaction 时只需提供相关的方法即可。\n这段话初读有点拗口，这里我推荐你结合 React 源码中的一段针对 Transaction 的注释来理解它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 * \u0026lt;pre\u0026gt; * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------\u0026gt;|-|---|-|---|--\u0026gt;|anyMethod|---|---|-|---|-|--------\u0026gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * \u0026lt;/pre\u0026gt; 说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，同时需要使用 Transaction 类暴露的 perform 方法去执行它。如上面的注释所示，在 anyMethod 执行之前，perform 会先执行所有 wrapper 的 initialize 方法，执行完后，再执行所有 wrapper 的 close 方法。这就是 React 中的事务机制。\n“同步现象”的本质 下面结合对事务机制的理解，我们继续来看在 ReactDefaultBatchingStrategy 这个对象。ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。\n1 2 3 4 5 6 7 8 9 10 11 var RESET_BATCHED_UPDATES = { initialize: emptyFunction, close: function () { ReactDefaultBatchingStrategy.isBatchingUpdates = false; }, }; var FLUSH_BATCHED_UPDATES = { initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates), }; var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; 我们把这两个 wrapper 套进 Transaction 的执行机制里，不难得出一个这样的流程：\n到这里，相信你对 isBatchingUpdates 管控下的批量更新机制已经了然于胸。但是 setState 为何会表现同步这个问题，似乎还是没有从当前展示出来的源码里得到根本上的回答。这是因为 batchedUpdates 这个方法，不仅仅会在 setState 之后才被调用。若我们在 React 源码中全局搜索 batchedUpdates，会发现调用它的地方很多，但与更新流有关的只有这两个地方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ReactMount.js _renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) { // 实例化组件 var componentInstance = instantiateReactComponent(nextElement); // 初始渲染直接调用 batchedUpdates 进行同步渲染 ReactUpdates.batchedUpdates( batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context ); ... } 这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次 batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用 setState。因此，我们需要通过开启 batch 来确保所有的更新都能够进入 dirtyComponents 里去，进而确保初始渲染流程中所有的 setState 都是生效的。\n下面代码是 React 事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。\n1 2 3 4 5 6 7 8 9 10 11 // ReactEventListener.js dispatchEvent: function (topLevelType, nativeEvent) { ... try { // 处理事件 ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); } finally { TopLevelCallbackBookKeeping.release(bookKeeping); } } 话说到这里，一切都变得明朗了起来：isBatchingUpdates 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 悄悄修改为了 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。\n以开头示例中的 increment 方法为例，整个过程像是这样：\n1 2 3 4 5 6 7 8 9 10 11 increment = () =\u0026gt; { // 进来先锁上 isBatchingUpdates = true; console.log(\u0026#34;increment setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count + 1, }); console.log(\u0026#34;increment setState后的count\u0026#34;, this.state.count); // 执行完函数再放开 isBatchingUpdates = false; }; 很明显，在 isBatchingUpdates 的约束下，setState 只能是异步的。而当 setTimeout 从中作祟时，事情就会发生一点点变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 reduce = () =\u0026gt; { // 进来先锁上 isBatchingUpdates = true; setTimeout(() =\u0026gt; { console.log(\u0026#34;reduce setState前的count\u0026#34;, this.state.count); this.setState({ count: this.state.count - 1, }); console.log(\u0026#34;reduce setState后的count\u0026#34;, this.state.count); }, 0); // 执行完函数再放开 isBatchingUpdates = false; }; 会发现，咱们开头锁上的那个 isBatchingUpdates，对 setTimeout 内部的执行逻辑完全没有约束力。因为 isBatchingUpdates 是在同步代码中变化的，而 setTimeout 的逻辑是异步执行的。当 this.setState 调用真正发生的时候，isBatchingUpdates 早已经被重置为了 false，这就使得当前场景下的 setState 具备了立刻发起同步更新的能力。所以咱们前面说的没错——setState 并不是具备同步这种特性，只是在特定的情境下，它会从 React 的异步管控中“逃脱”掉。\n","permalink":"https://zzydev.top/posts/headfirstreact/8_setstate%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/","summary":"从一道面试题说起 其他 setState 原理的文章 online Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52","title":"8.SetState是同步的还是异步的？"},{"content":"调和（Reconciliation）过程与 Diff 算法 Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。 \u0026mdash;- React 官方\nReconciler（调和器）所做的工作是一系列的，包括组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用。\nDiff 策略的设计思想 React 团队结合设计层面的一些推导，为将 O (n3) 复杂度转换成 O (n) 复杂度确立了大前提，总结了以下两个规律，：\n若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构； 处于同一层级的一组子节点，可用通过设置 key 作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性。 除了这两个“板上钉钉”的规律之外，还有一个和实践结合比较紧密的规律，它为 React 实现高效的 Diff 提供了灵感：DOM 节点之间的跨层级操作并不多，同层级操作是主流。\n把握三个“要点”，图解 Diff 逻辑 1. 改变时间复杂度量级的决定性思路：分层对比 结合“DOM 节点之间的跨层级操作并不多，同层级操作是主流”这一规律，React 的 Diff 过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比，如下图所示。这样一来，只需要从上到下的一次遍历，就可以完成对整棵树的对比，这是降低复杂度量级方面的一个最重要的设计。\n需要注意的是：虽然栈调和将传统的树对比算法优化为了分层对比，但整个算法仍然是以递归的形式运转的，分层递归也是递归\n那么如果真的发生了跨层级的节点操作（比如将以 B 节点为根节点的子树从 A 节点下面移动到 C 节点下面，如下图所示）会怎样呢？很遗憾，作为“次要矛盾”，在这种情况下 React 并不能够判断出“移动”这个行为，它只能机械地认为移出子树那一层的组件消失了，对应子树需要被销毁；而移入子树的那一层新增了一个组件，需要重新为其创建一棵子树。\n销毁 + 重建的代价是昂贵的，因此 React 官方也建议开发者不要做跨层级的操作，尽量保持 DOM 结构的稳定性。\n2. 减少递归的“一刀切”策略：类型的一致性决定递归的必要性 结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，我们虽不能直接反推出“不同类型的组件 DOM 结构不同”，但在大部分的情况下，这个结论都是成立的。毕竟，实际开发中遇到两个 DOM 结构完全一致、而类型不一致的组件的概率确实太低了。\n本着抓“主要矛盾”的基本原则，React 认为，只有同类型的组件，才有进一步对比的必要性；若参与 Diff 的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点，如下图所示。只有确认组件类型相同后，React 才会在保留组件对应 DOM 树（或子树）的基础上，尝试向更深层次去 Diff。\n这样一来，便能够从很大程度上减少 Diff 过程中冗余的递归操作。\n3. 重用节点的好帮手：key 属性帮 React “记住”节点 key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性。 \u0026mdash;- React 对 key 的定义\n它试图解决的是同一层级下节点的重用问题。在展开分析之前，我们先结合到现在为止对 Diff 过程的理解，来思考这样一种情况，如下图所示：\n图中 A 组件在保持类型和其他属性均不变的情况下，在两个子节点（B 和 D）之间插入了一个新的节点（C）。按照已知的 Diff 原则，两棵树之间的 Diff 过程应该是这样的：\n首先对比位于第 1 层的节点，发现两棵树的节点类型是一致的（都是 A），于是进一步 Diff； 开始对比位于第 2 层的节点，第 1 个接受比较的是 B 这个位置，对比下来发现两棵树这个位置上的节点都是 B，没毛病，放过它； 第 2 个接受比较的是 D 这个位置，对比 D 和 C，发现前后的类型不一致，直接删掉 D 重建 C； 第 3 个接受比较的是 E 这个位置，对比 E 和 D，发现前后的类型不一致，直接删掉 E 重建 D； 最后接受“比较”的是树 2 的 E 节点这个位置，这个位置在树 1 里是空的，也就是说树 2 的 E 是一个新增节点，所以新增一个 E。 奇怪的事情发生了：C、D、E 三个节点，其实都是可以直接拿来用的。原本新增 1 个节点就能搞定的事情，现在却又是删除又是重建地搞了半天，而且这个蠢操作和跨层级移动节点还不太一样，后者本来就属于低频操作，加以合理的最佳实践约束一下基本上可以完全规避掉；但图示的这种插入节点的形式是高频操作。频繁增删节点必定拖垮性能，这时候就需要请出 key 属性来帮我们重用节点了。\nkey 属性的形式，我们肯定都不陌生。在基于数组动态生成节点时，我们一般都会给每个节点加装一个 key 属性（下面是一段代码示例）：\n1 const todoItems = todos.map((todo) =\u0026gt; \u0026lt;li key={todo.id}\u0026gt;{todo.text}\u0026lt;/li\u0026gt;); 如果你忘记写 key，React 虽然不至于因此报错，但控制台标红是难免的，它会给你抛出一个“请给列表元素补齐 key 属性”的 warning，这个常见的 warning 也从侧面反映出了 key 的重要性。事实上，当我们没有设定 key 值的时候，Diff 的过程就正如上文所描述的一样惨烈。但只要你按照规范加装一个合适的 key，这个 key 就会像一个记号一样，帮助 React “记住”某一个节点，从而在后续的更新中实现对这个节点的追踪。比如说刚刚那棵虚拟 DOM 树，若我们给位于第 2 层的每一个子节点一个 key 值，如下图所示：\n这个 key 就充当了每个节点的 ID（唯一标识），有了这个标识之后，当 C 被插入到 B 和 D 之间时，React 并不会再认为 C、D、E 这三个坑位都需要被重建——它会通过识别 ID，意识到 D 和 E 并没有发生变化（D 的 ID 仍然是 1，E 的 ID 仍然是 2），而只是被调整了顺序而已。接着，React 便能够轻松地重用它“追踪”到旧的节点，将 D 和 E 转移到新的位置，并完成对 C 的插入。这样一来，同层级下元素的操作成本便大大降低。\n作为一个节点的唯一标识，在使用 key 之前，请务必确认 key 的唯一和稳定。\n","permalink":"https://zzydev.top/posts/headfirstreact/7_react%E4%B8%AD%E7%9A%84%E6%A0%88%E8%B0%83%E5%92%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/","summary":"调和（Reconciliation）过程与 Diff 算法 Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中","title":"7.React中的栈调和过程是怎样的？"},{"content":"React 中的虚拟 DOM 大致是如何工作的? 挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；\n更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM\n模板引擎与虚拟 DOM 有哪些区别？ 区别就在于多出了一层虚拟 DOM 作为缓冲层。这个缓冲层带来的利好是：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“差量更新”。这个过程对应的虚拟 DOM 工作流如下图所示：\nReact 选用虚拟 DOM，真的是为了更好的性能吗？\n虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。\n虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级。\n那么虚拟 DOM 的价值到底是什么呢？ 研发体验/研发效率的问题：这一点前面已经反复强调过，DOM 操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。 跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟 DOM，它描述的东西可以是真实 DOM，也可以是 iOS 界面、安卓界面、小程序\u0026hellip;\u0026hellip;同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和 1 是高度呼应的。 ","permalink":"https://zzydev.top/posts/headfirstreact/6_%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdomreact%E9%80%89%E5%AE%83%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%80%A7%E8%83%BD%E5%90%97/","summary":"React 中的虚拟 DOM 大致是如何工作的? 挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）； 更新","title":"6.真正理解虚拟DOM,React选它是因为性能吗"},{"content":" React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：\n只在 React 函数中调用 Hooks； 不要在循环、条件或嵌套函数中调用 Hooks。 原则 2 中强调的所有“不要”，都是在指向同一个目的，那就是要确保 Hooks 在每次渲染时都保持同样的执行顺序。 PersonalInfoComponent 里去，看看实际项目中，变量到底是怎么发生变化的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import React, { useState } from \u0026#34;react\u0026#34;; // isMounted 用于记录是否已挂载（是否是首次渲染） let isMounted = false; function PersonalInfoComponent() { // 定义变量的逻辑不变 let name, age, career, setName, setCareer; // 这里追加对 isMounted 的输出，这是一个 debug 性质的操作 console.log(\u0026#34;isMounted is\u0026#34;, isMounted); // 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态 if (!isMounted) { // eslint-disable-next-line [name, setName] = useState(\u0026#34;zzy\u0026#34;); // eslint-disable-next-line [age] = useState(\u0026#34;99\u0026#34;); // if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了） isMounted = true; } // 对职业信息的获取逻辑不变 [career, setCareer] = useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); // 这里追加对 career 的输出，这也是一个 debug 性质的操作 console.log(\u0026#34;career\u0026#34;, career); // UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示 return ( \u0026lt;div className=\u0026#34;personalInfo\u0026#34;\u0026gt; {name ? \u0026lt;p\u0026gt;姓名：{name}\u0026lt;/p\u0026gt; : null} {age ? \u0026lt;p\u0026gt;年龄：{age}\u0026lt;/p\u0026gt; : null} \u0026lt;p\u0026gt;职业：{career}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; { setName(\u0026#34;唔知\u0026#34;); }} \u0026gt; 修改姓名 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default PersonalInfoComponent; Hooks 的正常运作，在底层依赖于顺序链表 以 useState 为例，分析 React-Hooks 的调用链路 在这个流程中，useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 进入 mounState 逻辑 function mountState(initialState) { // 将新的 hook 对象追加进链表尾部 var hook = mountWorkInProgressHook(); // initialState 可以是一个回调，若是回调，则取回调执行后的值 if (typeof initialState === \u0026#34;function\u0026#34;) { // $FlowFixMe: Flow doesn\u0026#39;t like mixed types initialState = initialState(); } // 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch const queue = (hook.queue = { last: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), }); // 将 initialState 作为一个“记忆值”存下来 hook.memoizedState = hook.baseState = initialState; // dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么 var dispatch = (queue.dispatch = dispatchAction.bind( null, currentlyRenderingFiber$1, queue )); // 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈 return [hook.memoizedState, dispatch]; } 从这段源码中我们可以看出，mounState 的主要工作是初始化 Hooks。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式。以下是 mountWorkInProgressHook 方法的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function mountWorkInProgressHook() { // 注意，单个 hook 是以对象的形式存在的 var hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, }; if (workInProgressHook === null) { // 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理 firstWorkInProgressHook = workInProgressHook = hook; } else { // 若链表不为空，则将 hook 追加到链表尾部 workInProgressHook = workInProgressHook.next = hook; } // 返回当前的 hook return workInProgressHook; } 到这里可以看出，hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联。\n接下来我们再看更新过程的大图：\n根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染。\n我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。\n看到这里，你是不是已经大概知道怎么回事儿了？没错，hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的。\n这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。Hooks 的本质其实是链表。\n站在底层视角，重现 PersonalInfoComponent 从代码里面，我们可以提取出来的 useState 调用有三个：\n1 2 3 [name, setName] = useState(\u0026#34;zzy\u0026#34;); [age] = useState(\u0026#34;99\u0026#34;); [career, setCareer] = useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); 当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：\n1 useState(\u0026#34;我是一个前端，爱吃小熊饼干\u0026#34;); 链表此时的状态如下图所示：\n更新（二次渲染）的时候会发生什么事情：updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它会认为：你想要的是第一个位置的 hook 。\n然后就会有下面这样的效果：\n","permalink":"https://zzydev.top/posts/headfirstreact/5_%E6%B7%B1%E5%85%A5react-hooks%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/","summary":"React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下： 只在 React 函数中调用 Hooks； 不要在循环、条件或嵌套函数中调用 Hooks。 原则 2 中强调","title":"5.深入React Hooks工作机制,Hooks本质是链表"},{"content":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。\n如果你在这个在线 Demo中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：\n明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！\n这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？\n因为虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。\n多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。\n但如果我们把 ProfilePage 改造为一个像这样的函数组件：\n1 2 3 4 5 6 7 8 9 function ProfilePage(props) { const showMessage = () =\u0026gt; { alert(\u0026#34;Followed \u0026#34; + props.user); }; const handleClick = () =\u0026gt; { setTimeout(showMessage, 3000); }; return \u0026lt;button onClick={handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt;; } 事情就会大不一样。\nprops 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。\n总结：“函数组件会捕获 render 内部的状态”，函数组件真正地把数据和渲染绑定到了一起。\n函数组件是一个更加匹配 React 设计理念、也更有利于逻辑拆分与重用的组件表达形式\n从核心 API 看 Hooks 的基本形态 useState()：为函数组件引入状态 1 2 3 4 5 6 7 8 9 10 11 12 const [state, setState] = useState(initialState); //状态和修改状态的 API 名都是可以自定义的 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;); //它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值 // 定义为数组 const [author, setAuthor] = useState([\u0026#34;zzydev\u0026#34;, \u0026#34;zzy\u0026#34;]); // 定义为数值 const [length, setLength] = useState(100); // 定义为字符串 const [text, setText] = useState(\u0026#34;初始文本\u0026#34;); state 中永远不要保存可以通过计算得到的值。 比如：\n从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。 从 URL 中读到的值。有时我们要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候，从 URL 中读取，而不是读出来放在 state 中。 从 cookie、localStorage 中读取的值。通常每次要用的时候直接去读取，而不是读出来放到 state 中。 state 虽然便于维护状态，但也有自己的弊端。一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。\nuseEffect()：允许函数组件执行副作用操作 useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。\nuseEffect 是每次组件 render 完后判断依赖并执行\n没有依赖项，则每次 render 后都会重新执行。 1 2 3 4 useEffect(() =\u0026gt; { // 每次 render 完都会执行 console.log(\u0026#34;re-rendered\u0026#34;); }); 仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组作为依赖项。对应到 Class 组件就是 componentDidMount。 1 2 3 4 useEffect(() =\u0026gt; { // 这里是业务逻辑 console.log(\u0026#34;did mount\u0026#34;); }, []); 仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。这个机制就几乎等价于类组件中的 componentWillUnmount。 1 2 3 4 5 6 useEffect(() =\u0026gt; { // 这里是 A 的业务逻辑 // 返回一个函数记为 B return () =\u0026gt; {}; }, []); useEffect 回调中返回的函数被称为“清除函数”，当 React 识别到清除函数时，会在卸载时执行清除函数内部的逻辑。这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理。\n每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。 1 2 3 4 5 6 7 useEffect(() =\u0026gt; { // 这里是 A 的业务逻辑 // 返回一个函数记为 B return () =\u0026gt; {}; }); //React 在每一次渲染都去触发 A 逻辑，并且在下一次 A 逻辑被触发之前去触发 B 逻辑。 根据一定的依赖条件来触发的副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述），同时传入一个非空的数组。 1 2 3 4 5 6 7 8 9 10 11 12 useEffect(() =\u0026gt; { // 这是回调函数的业务逻辑 // 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发 return xxx; }, [num1, num2, num3]); /* 数组中的变量一般都是来源于组件本身的数据（props 或者 state）。 若数组不为空，那么 React 就会在新的一次渲染后去对比前后两次的渲染， 查看数组内是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了）， 并在有更新的前提下去触发 useEffect 中定义的副作用逻辑。 */ 理解 Hooks 的依赖 Hooks(useEffect、useCallback、useMemo) 提供了让你监听某个数据变化的能力。这个变化可能会触发组件的刷新，也可能是去创建一个副作用，又或者是刷新一个缓存。那么定义要监听哪些数据变化的机制，其实就是指定 Hooks 的依赖项。\n那么在定义依赖项时，我们需要注意以下三点：\n依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。 依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。 React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方。例如下面的代码： 1 2 3 4 5 6 7 function Sample() { // 这里在每次组件执行时创建了一个新数组 const todos = [{ text: \u0026#34;Learn hooks.\u0026#34; }]; useEffect(() =\u0026gt; { console.log(\u0026#34;Todos changed.\u0026#34;); }, [todos]); } 代码的原意可能是在 todos 变化的时候去产生一些副作用，但是这里的 todos 变量是在函数内创建的，实际上每次都产生了一个新数组。所以在作为依赖项的时候进行引用的比较，实际上被认为是发生了变化的。\nReact 为什么要发明 Hooks 告别难以理解的 Class: Class 的“痛点”:\n生命周期\n生命周期的带来的麻烦提现在：学习成本和不合理的逻辑规划方式 React 组件之间是不会相互继承的\n比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 组件来继承 Button。React 实际上没利用到 Class 的继承特性的。 UI 由状态驱动，很少在外部调用类实例（即组件）的方法。\n组件所有的方法都是在类内部调用或者作为生命周期函数被自动调用。 this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Example extends Component { state = { name: \u0026#39;zzydev\u0026#39;, age: \u0026#39;99\u0026#39;; }; changeAge() { // 这里会报错 this.setState({ age: \u0026#39;100\u0026#39; }); } render() { return \u0026lt;button onClick={this.changeAge}\u0026gt;{this.state.name}的年龄是{this.state.age}\u0026lt;/button\u0026gt; } } changeAge 这个方法：它是 button 按钮的事件监听函数。当我点击 button 按钮时，希望它能够帮我修改状态，但事实是，点击发生后，程序会报错。原因很简单，changeAge 里并不能拿到组件实例的 this。为了解决 this 不符合预期的问题，可以使用 this.changeAga = this.changeAga.bind(this) 或 箭头函数的方式，但这两种方式 本质上都是在用实践层面的约束来解决设计层面的问题\nHooks 如何实现更好的逻辑拆分 过去我们组织自己业务逻辑的方式：先想清楚业务的需要是什么样的，然后将对应的业务逻辑拆到不同的生命周期函数里去。逻辑与生命周期耦合在一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 componentDidMount() { // 1. 这里发起异步调用 // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM // 3. 这里设置一个订阅 // 4. 这里随便干点别的什么 // ... } componentWillUnMount() { // 在这里卸载订阅 } componentDidUpdate() { // 1. 在这里根据 DidMount 获取到的异步数据更新 DOM // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样） } 像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。\n而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。\n状态复用：Hooks 将复杂的问题变简单 过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。\nHooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。\nReact Hooks 的局限性 Hooks 暂时还不能完全地为函数组件补齐类组件的能力 比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。\nHooks 在使用层面有着严格的规则约束 Hooks 的使用规则包括以下两个: 只能在函数组件的顶级作用域使用；只能在函数组件或者其他 Hooks 中使用。 所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。Hooks 使用规则背后的”原理“\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function MyComp() { const [count, setCount] = useState(0); if (count \u0026gt; 10) { // ⚠️ 错误：不能将 Hook 用在条件判断里 useEffect(() =\u0026gt; { // ... }, [count]); } // ⚠️ 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了 if (count === 0) { return \u0026#34;No content\u0026#34;; } // ⚠️ 错误：不能将 Hook 放在可能的 return 之后 const [loading, setLoading] = useState(false); //... return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; } Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，一种是在函数组件内，另外一种则是在自定义的 Hooks 里面。 但是如果一定要在 Class 组件中使用，那应该如何做呢？其实有一个通用的机制，那就是利用高阶组件的模式，将 Hooks 封装成高阶组件，从而让类组件使用。 举个例子。我们已经定义了监听窗口大小变化的一个 Hook：useWindowSize。那么很容易就可以将其转换为高阶组件：\n1 2 3 4 5 6 7 8 9 import React from \u0026#34;react\u0026#34;; import { useWindowSize } from \u0026#34;../hooks/useWindowSize\u0026#34;; export const withWindowSize = (Comp) =\u0026gt; { return (props) =\u0026gt; { const windowSize = useWindowSize(); return \u0026lt;Comp windowSize={windowSize} {...props} /\u0026gt;; }; }; 那么我们就可以通过如下代码来使用这个高阶组件：\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34;; import { withWindowSize } from \u0026#34;./withWindowSize\u0026#34;; class MyComp { render() { const { windowSize } = this.props; // ... } } // 通过 withWindowSize 高阶组件给 MyComp 添加 windowSize 属性 export default withWindowSize(MyComp); 这样，通过 withWindowSize 这样一个高阶组件模式，你就可以把 useWindowSize 的结果作为属性，传递给需要使用窗口大小的类组件，这样就可以实现在 Class 组件中复用 Hooks 的逻辑了。\n使用 ESLint 插件帮助检查 Hooks 的使用 1 yarn add eslint-plugin-react-hooks -S 然后在你的 ESLint 配置文件中加入两个规则：rules-of-hooks 和 exhaustive-deps。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;plugins\u0026#34;: [ // ... \u0026#34;react-hooks\u0026#34; ], \u0026#34;rules\u0026#34;: { // ... // 检查 Hooks 的使用规则 \u0026#34;react-hooks/rules-of-hooks\u0026#34;: \u0026#34;error\u0026#34;, // 检查依赖项的声明 \u0026#34;react-hooks/exhaustive-deps\u0026#34;: \u0026#34;warn\u0026#34; } } ","permalink":"https://zzydev.top/posts/headfirstreact/4_react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","summary":"函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用","title":"4.React Hooks设计动机与工作模式"},{"content":"React 的核心特征是“数据驱动视图”，即 UI = render(data)\n基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。 父子组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 子组件 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } //父组件 class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34;, }; // 按钮的监听函数，用于更新 text 值 changeText = () =\u0026gt; { this.setState({ text: \u0026#34;改变后的父组件文本\u0026#34;, }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;button onClick={this.changeText}\u0026gt; 点击修改父组件传入子组件的文本 \u0026lt;/button\u0026gt; {/* 引入子组件，并通过 props 下发具体的状态值实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 子-父组件通信 考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。假如父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，以此来间接地实现数据从子组件到父组件的流动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Child extends React.Component { // 初始化子组件的 state state = { text: \u0026#39;子组件的文本\u0026#39; } // 子组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text) } render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本的动作放在了 Child 里 */} \u0026lt;button onClick={this.changeText}\u0026gt; 点击更新父组件的文本 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34; }; // 这个方法会作为 props 传给子组件，用于更新父组件 text 值。newText 正是开放给子组件的数据通信入口 changeText = (newText) =\u0026gt; { this.setState({ text: newText }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`父组件的文本内容是：[${this.state.text}]`}\u0026lt;/p\u0026gt; {/* 引入子组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;Child changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } 兄弟组件通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function Child(props) { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{`子组件所接收到的来自父组件的文本内容是：[${props.fatherText}]`}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } class NewChild extends React.Component { state = { text: \u0026#34;来自 newChild 的文本\u0026#34;, }; // NewChild 组件的按钮监听函数 changeText = () =\u0026gt; { // changeText 中，调用了父组件传入的 changeFatherText 方法 this.props.changeFatherText(this.state.text); }; render() { return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; {/* 注意这里把修改父组件文本（同时也是 Child 组件的文本）的动作放在了 NewChild 里 */} \u0026lt;button onClick={this.changeText}\u0026gt;点击更新 Child 组件的文本\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } class Father extends React.Component { // 初始化父组件的 state state = { text: \u0026#34;初始化的父组件的文本\u0026#34;, }; // 传给 NewChild 组件按钮的监听函数，用于更新父组件 text 值（这个 text 值同时也是 Child 的 props） changeText = (newText) =\u0026gt; { this.setState({ text: newText, }); }; // 渲染父组件 render() { return ( \u0026lt;div className=\u0026#34;father\u0026#34;\u0026gt; {/* 引入 Child 组件，并通过 props 中下发具体的状态值 实现父-子通信 */} \u0026lt;Child fatherText={this.state.text} /\u0026gt; {/* 引入 NewChild 组件，并通过 props 中下发可传参的函数 实现子-父通信 */} \u0026lt;NewChild changeFatherText={this.changeText} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 利用“发布-订阅”模式驱动数据流 使用发布-订阅模式的优点在于，监听事件的位置和触发事件的位置是不受限的，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。\n发布-订阅模型 API 设计思路 on()：负责注册事件的监听器，指定事件触发时的回调函数。 emit()：负责触发事件，可以通过传参使其在触发的时候携带数据 。 off()：负责监听器的删除。 发布-订阅模型编码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class myEventEmitter { constructor() { // eventMap 用来存储事件和监听函数之间的关系 this.eventMap = {}; } // type 这里就代表事件的名称 on(type, handler) { // hanlder 必须是一个函数，如果不是直接报错 if (!(handler instanceof Function)) { throw new Error(\u0026#34;hanlder必须是一个函数\u0026#34;); } // 判断 type 事件对应的队列是否存在 if (!this.eventMap[type]) { // 若不存在，新建该队列 this.eventMap[type] = []; } // 若存在，直接往队列里推入 handler this.eventMap[type].push(handler); } // 别忘了我们前面说过触发时是可以携带数据的，params 就是数据的载体 emit(type, params) { // 假设该事件是有订阅的（对应的事件队列存在） if (this.eventMap[type]) { // 将事件队列里的 handler 依次执行出队 this.eventMap[type].forEach((handler, index) =\u0026gt; { // 注意别忘了读取 params handler(params); }); } } off(type, handler) { if (this.eventMap[type]) { // indexOf找不到元素会返回-1，splice从右往左截取，右移运算会将-1变成4294967295 this.eventMap[type].splice(this.eventMap[type].indexOf(handler) \u0026gt;\u0026gt;\u0026gt; 0, 1); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 注意这个 myEvent 是提前实例化并挂载到全局的，此处不再重复示范实例化过程 const globalEvent = window.myEvent; class B extends React.Component { // 这里省略掉其他业务逻辑 state = { newParams: \u0026#34;\u0026#34;, }; handler = (params) =\u0026gt; { this.setState({ newParams: params, }); }; bindHandler = () =\u0026gt; { globalEvent.on(\u0026#34;someEvent\u0026#34;, this.handler); }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.bindHandler}\u0026gt;点我监听A的动作\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;A传入的内容是[{this.state.newParams}]\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } } class A extends React.Component { // 这里省略掉其他业务逻辑 state = { infoToB: \u0026#34;哈哈哈哈我来自A\u0026#34;, }; reportToB = () =\u0026gt; { // 这里的 infoToB 表示 A 自身状态中需要让 B 感知的那部分数据 globalEvent.emit(\u0026#34;someEvent\u0026#34;, this.state.infoToB); }; render() { return \u0026lt;button onClick={this.reportToB}\u0026gt;点我把state传递给B\u0026lt;/button\u0026gt;; } } export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;B /\u0026gt; \u0026lt;A /\u0026gt; \u0026lt;/div\u0026gt; ); } 使用 Context 维护全局状态 useContext\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //作用是创建一个context对象,可以选择性地传入一个defaultValue const AppContext = React.createContext(defaultValue) //从创建出的context对象中，可以读取到 Provider 和 Consumer const { Provider, Consumer } = AppContext //使用 Provider 对组件树中的根组件进行包裹， //然后传入名为“value”的属性，这个 value 就是后续在组件树中流动的“数据”， //它可以被 Consumer 消费。 \u0026lt;Provider value={title: this.state.title, content: this.state.content}\u0026gt; \u0026lt;Title /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/Provider\u0026gt; //Consumer，顾名思义就是“数据的消费者”，它可以读取 Provider 下发下来的数据 //其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。 \u0026lt;Consumer\u0026gt; {value =\u0026gt; \u0026lt;div\u0026gt;{value.title}\u0026lt;/div\u0026gt;} \u0026lt;/Consumer\u0026gt; //注意: 当 Consumer 没有对应的 Provider 时， //value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。 Redux createStore.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const createStore = (reducer, enhancer) =\u0026gt; { if (enhancer) { return enhancer(createStore)(reducer); } let currentState = void 0; let currentListeners = []; const getState = () =\u0026gt; currentState; const dispatch = (action) =\u0026gt; { currentState = reducer(currentState, action); currentListeners.forEach((listener) =\u0026gt; listener()); }; const subscribe = (listener) =\u0026gt; { currentListeners.push(listener); return () =\u0026gt; { const index = currentListeners.indexOf(listener); currentListeners.splice(index, 1); }; }; //手动触发一次订阅，加上默认值 dispatch({ type: \u0026#34;@z—redux/INIT\u0026#34; }); return { getState, dispatch, subscribe, }; }; export default createStore; applyMiddleware.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const applyMiddleware = (...middleware) =\u0026gt; { return (createStore) =\u0026gt; (reducer) =\u0026gt; { const store = createStore(reducer); let dispatch = store.dispatch; const midApi = { getState: store.getState, dispatch: (action, ...args) =\u0026gt; dispatch(action, ...args), }; const chain = middleware.map((middleware) =\u0026gt; middleware(midApi)); dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch, }; }; }; const compose = (...funcs) =\u0026gt; { if (funcs.length === 0) { return (arg) =\u0026gt; arg; } if (funcs.length === 1) { return funcs[0]; } return funcs.reduce( (a, b) =\u0026gt; (...args) =\u0026gt; a(b(...args)) ); }; export default applyMiddleware; combineReducer.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const combineReducers = (reducers) =\u0026gt; (state = {}, action) =\u0026gt; { let nextState = {}; let hasChange = false; for (let key in reducers) { const reducer = reducers[key]; nextState[key] = reducer(state[key], action); hasChange = hasChange || nextState[key] !== state[key]; } hasChange = hasChange || Object.keys(nextState) !== Object.keys(state); return hasChange ? nextState : state; }; export default combineReducers; React-Redux 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import { useReducer } from \u0026#34;react\u0026#34;; import React from \u0026#34;react\u0026#34;; import { useCallback, useState, useEffect, useLayoutEffect, useContext, } from \u0026#34;react\u0026#34;; const Context = React.createContext(); export const Provider = ({ store, children }) =\u0026gt; { return \u0026lt;Context.Provider value={store}\u0026gt;{children}\u0026lt;/Context.Provider\u0026gt;; }; export const connect = (mapStateToProps = (state) =\u0026gt; state, mapDispatchToProps) =\u0026gt; (WrapperComponent) =\u0026gt; (props) =\u0026gt; { const store = useContext(Context); const { getState, dispatch, subscribe } = store; const stateProps = mapStateToProps(getState()); let dispatchProps = { dispatch }; if (typeof mapDispatchToProps === \u0026#34;object\u0026#34;) { dispatchProps = { ...bindActionCreators(mapDispatchToProps, dispatch), dispatch, }; } else if (typeof mapDispatchToProps === \u0026#34;function\u0026#34;) { dispatchProps = mapDispatchToProps(dispatch); } const forceUpdate = useForceUpdate(); useLayoutEffect(() =\u0026gt; { const unsubscribe = subscribe(() =\u0026gt; { forceUpdate(); }); return () =\u0026gt; { if (unsubscribe) { unsubscribe(); } }; }, []); return \u0026lt;WrapperComponent {...props} {...stateProps} {...dispatchProps} /\u0026gt;; }; function bindActionCreator(creator, dispatch) { return (...args) =\u0026gt; dispatch(creator(...args)); } export const bindActionCreators = (creators, dispatch) =\u0026gt; { let obj = {}; for (let key in creators) { obj[key] = bindActionCreator(creators[key], dispatch); } return obj; }; const useForceUpdate = () =\u0026gt; { const [state, setState] = useState(0); //const [, setState] = useReducer((prev) =\u0026gt; prev + 1, 0); const update = useCallback(() =\u0026gt; { setState((prev) =\u0026gt; prev + 1); }, []); return update; }; ","permalink":"https://zzydev.top/posts/headfirstreact/3_%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8react%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%E7%9A%84/","summary":"React 的核心特征是“数据驱动视图”，即 UI = render(data) 基于 props 的单向数据流 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更","title":"3.数据是如何在React组件之间流动的？"},{"content":"React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”。\n注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来做的。\ncomponentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里**执行真实 DOM 相关的操作，**类似于发起异步请求、数据初始化这样的操作也大可以放在这个生命周期来做。\nUpdating 阶段：组件的更新 componentWillReceiProps(nextProps) 是由什么触发的？ 在这个生命周期方法里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）可以通过 this.props 拿到，由此便能够感知到 props 的变化。\ncomponentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。\n如果父组件导致组件重新渲染，即使 props 没有更改也会调用此方法（componentWillReceiveProps） 如果只想处理更改，请确保当前值与变更值的比较\n\u0026mdash;\u0026mdash; React 官方\n组件自身 setState 触发的更新 componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。\nrender 与性能： shouldComponentUpdate(nextProps, nextState) React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行re-render（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。\nUnmounting 阶段：组件的卸载 组件销毁的常见原因有以下两个。\n组件在父组件中被移除了：这种情况相对比较直观 组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被销毁。 React16 的生命周期 推荐 👉🏻 React16 生命周期图示\nMounting 阶段：组件的初始化渲染 认识 getDerivedStateFromProps(props,state) getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉componentWillMount ，而是试图替换掉 componentWillReceiveProps，因此它有且仅有一个用途:使用 props 来派生/更新 state\ngetDerivedStateFromProps 是一个静态方法，静态方法不依赖组件实例而存在，因此在这个方法内部是访问不到 this 的。\n该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。\ngetDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番。\ngetDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：\n1 2 3 { fatherText: props.text; } 该对象并不会替换掉组件原始的这个 state：\n1 this.state = { text: \u0026#34;子组件的文本\u0026#34; }; 而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示： Updating 阶段：组件的更新 React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：\n在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；\n而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。\n为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？ 做合理的减法：\ngetDerivedStateFromProps 直接被定义为 static 方法，static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。 这是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。 消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate 方法需要一个返回值，它的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state\u0026amp;props 的信息。\n重点把握它与 componentDidUpdate 间的通信过程：\n1 2 3 4 5 6 7 8 9 10 11 // 组件更新时调用 getSnapshotBeforeUpdate(prevProps, prevState) { console.log(\u0026#34;getSnapshotBeforeUpdate方法执行\u0026#34;); return \u0026#34;haha\u0026#34;; } // 组件更新后调用 componentDidUpdate(prevProps, prevState, valueFromSnapshot) { console.log(\u0026#34;componentDidUpdate方法执行\u0026#34;); console.log(\u0026#34;从 getSnapshotBeforeUpdate 获取到的值是\u0026#34;, valueFromSnapshot); } 这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。\nReact16 为何两次求变？ Fiber 会使原本同步的渲染过程变成异步的。 同步更新与异步更新对比 Demo\n同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，调度器会看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”。\n换个角度看生命周期工作流 Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：\n总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。\n为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，这个过程必须用同步渲染。\n生命周期变更的考量 在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。\n带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：\ncomponentWillMount； componentWillUpdate； componentWillReceiveProps。 这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。\n在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:\nsetState()； fetch 发起异步请求； 操作真实 DOM。 这些操作的问题（或不必要性）包括但不限于以下 3 点：\n完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做。\n比如在 componentWillMount 里发起异步请求，以为这样做就可以更快得到异步请求返回的结果，从而避免首次渲染白屏。\n但是（React 15 下）同步的生命周期函数必然先于异步请求执行。componentWillMount 结束后，render 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题。\n在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。\n比如在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。\n又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。\ngetDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了———避免开发者触碰 this，就是在避免各种危险的错误操作。\n即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。\n比如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。\n总的来说，React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制。在这个改造的过程中，React 团队针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也 确保了生命周期方法的行为更加纯粹、可控、可预测 。\n","permalink":"https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”","title":"2.React生命周期"},{"content":" JSX 的本质：JavaScript 的语法糖 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。\nBabel 具备将 JSX 语法转换为 javascript 的能力\nBabel 的在线 playground\nJSX 是如何映射为 DOM 的 createElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //React的创建元素方法 export function createElement(type, config, children) { // propName 变量用于储存后面需要用到的元素属性 let propName; // props 变量用于储存元素属性的键值对集合 const props = {}; // key、ref、self、source 均为 React 元素的属性，此处不必深究 let key = null; let ref = null; let self = null; let source = null; // config 对象中存储的是元素的属性 if (config != null) { // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值 if (hasValidRef(config)) { ref = config.ref; } // 此处将 key 值转换为字符串 if (hasValidKey(config)) { key = \u0026#34;\u0026#34; + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面 for (propName in config) { if ( // 筛选出可以提进 props 对象里的属性 hasOwnProperty.call(config, propName) \u0026amp;\u0026amp; !RESERVED_PROPS.hasOwnProperty(propName) ) { props[propName] = config[propName]; } } } // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度 const childrenLength = arguments.length - 2; // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了 if (childrenLength === 1) { // 直接把这个参数的值赋给props.children props.children = children; // 处理嵌套多个子元素的情况 } else if (childrenLength \u0026gt; 1) { // 声明一个子元素数组 const childArray = Array(childrenLength); // 把子元素推进数组里 for (let i = 0; i \u0026lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } // 最后把这个数组赋值给props.children props.children = childArray; } // 处理 defaultProps if (type \u0026amp;\u0026amp; type.defaultProps) { const defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props ); } createElement 入参解析 1 export function createElement(type, config, children) type：用于标识节点的类型。它可以是类似“h1”、“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。 config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。 children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。 createElement 函数拆解 createElement 的每一个步骤几乎都是在格式化数据\ncreateElement 就像是开发者和 ReactElement 调用之间的一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。整个过程如下图所示：\ncreateElement 出参解析 ReactElement 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const ReactElement = function (type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; if (DEV) { /*这里是一些针对 __DEV__ 环境下的处理，对于理解主要逻辑意义不大，故省略*/ } return element; }; 打印输出 JSX 部分：\n1 2 3 4 5 6 7 8 const AppJSX = ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt;I am the title\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;content\u0026#34;\u0026gt;I am the content\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); console.log(AppJSX); 你会发现它确实是一个标准的 ReactElement 对象实例，如下图：\n这个 ReactElement 对象实例，本质上是 以 JavaScript 对象形式存在的对 DOM 的描述 ，也就是 虚拟 DOM 中的一个节点 。\n“虚拟 DOM”需要通过 ReactDOM.render方法，变成渲染到页面上的真实 DOM\n","permalink":"https://zzydev.top/posts/headfirstreact/1_jsx%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E4%B8%BAdom%E7%9A%84/","summary":"JSX 的本质：JavaScript 的语法糖 JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的","title":"1.JSX 是如何变成为 DOM 的"},{"content":" \u0026nbsp;手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } \u0026nbsp;手写 getType 1 2 3 4 5 6 7 8 function getType(obj) { let type = typeof obj; if (type !== \u0026#34;object\u0026#34;) return type; return Object.prototype .toString() .call(obj) .replace(/^\\[object (\\S+)\\]$/, \u0026#34;S1\u0026#34;); } \u0026nbsp;手写浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 function shallowClone(target) { if (typeof target === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; target !== null) { const cloneTarget = Array.isArray() ? [] : {}; for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = target[prop]; } } return cloneTarget; } else { return target; } } \u0026nbsp;手写深拷贝 小杯\n1 2 3 4 5 6 7 8 9 10 11 function deepClone(obj) { let cloneObj = {}; for (let key in obj) { if (typeof key === \u0026#34;obj\u0026#34; \u0026amp;\u0026amp; key !== null) { cloneObj[key] = deepClone(obj[key]); } else { cloneObj[key] = obj[key]; } } return cloneObj; } 超大杯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const isComplexDataType = (obj) =\u0026gt; (typeof obj === \u0026#34;object\u0026#34; || typeof obj === \u0026#34;function\u0026#34;) \u0026amp;\u0026amp; obj !== null; function deepClone(obj, hash = new WeakMap()) { if (obj instanceof Date) return +new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (hash.has(obj)) return hash.get(obj); //获取对象所有属性及其对应的特征 let allDesc = Object.getOwnPropertyDescriptors(obj); //继承原对象的原型链 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc); hash.set(obj, cloneObj); for (let key of Reflect.ownKeys()) { cloneObj[key] = isComplexDataType(obj[key]) \u0026amp;\u0026amp; typeof obj[key] !== \u0026#34;function\u0026#34; ? deepClone(obj[key], hash) : obj[key]; } return cloneObj; } JS WeakMap 应该什么时候使用\n1 const newData = structuredClone(data); structuredClone MDN\n\u0026nbsp;手写深比较 1 2 3 4 5 6 7 8 9 10 11 12 13 const isObject = (obj) =\u0026gt; typeof obj === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj !== null; function isEqual(obj1, obj2) { if (isObject(obj1) ^ isObject(obj2)) return false; if (obj1 === obj2) return true; const obj1Key = Object.keys(obj1); const obj2Key = Object.keys(obj2); if (obj1Key.length !== obj2Key.length) return false; for (let key in obj) { const res = isEqual(obj1[key], obj2[key]); if (!res) return false; } return true; } \u0026nbsp;手写函数AOP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Function.prototype.before = function (beforeFn) { const self = this; return function beforeFunc() { const args = arguments; beforeFn.apply(this, args); return self.apply(this, args); }; }; Function.prototype.after = function (afterFn) { const self = this; return function afterFunc() { const args = arguments; const result = self.apply(this, args); afterFn.apply(this, args); return result; }; }; function func() { console.log(\u0026#34;2\u0026#34;); } const newFunc = func .before(() =\u0026gt; { console.log(\u0026#34;1\u0026#34;); }) .after(() =\u0026gt; { console.log(\u0026#34;3\u0026#34;); }); newFunc(); // 1 2 3 \u0026nbsp;手写柯里化 1 2 3 4 5 6 7 8 9 10 11 12 // 通用的柯里化 var currying = function (fn) { var args = []; return function () { if (arguments.length == 0) { return fn.apply(this, args); } else { Array.prototype.push.apply(args, arguments); return arguments.callee; } }; }; \u0026nbsp;手写 call 、apply 、bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Function.prototype.myCall = function (context, ...args) { // xxx.myCall() this就是这里的xxx myApply和myBind中的this同理 context.func = this; context.func(...args); delete context.func; }; Function.prototype.myBind = function () { const args = Array.from(arguments); const t = args.shift(); const self = this; return function () { return self.apply(t, args); }; }; Function.prototype.myApply = function (context, args) { context.func = this; context.func(...args); delete context.func; }; \u0026nbsp;手写 Object.create() 1 2 3 4 5 6 //这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型 Object.create = function (prototype) { var cls = function () {}; cls.prototype = prototype; return new cls(); }; \u0026nbsp;手写 new 1 2 3 4 5 6 7 8 9 10 11 12 function myNew(...args) { // 取出 args 数组第一个参数，即目标构造函数 const constructor = args.shift(); // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性 // 即实现 obj.__proto__ = constructor.prototype const obj = Object.create(constructor.prototype); // 执行构造函数，得到构造函数返回结果 // 注意这里我们使用 apply，将构造函数内的 this 指向为 obj const result = constructor.apply(obj, args); // 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象 return typeof result === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; result != null ? result : obj; } \u0026nbsp;手写防抖节流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Throttle(事件节流)： 第一个人说了算 // fn是我们需要包装的事件回调, interval是时间间隔的阈值 function throttle(fn, interval) { // last为上一次触发回调的时间 let last = 0; // 将throttle处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 记录本次触发回调的时间 let now = new Date(); // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last \u0026gt;= interval) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.apply(context, args); } }; } // 用throttle来包装scroll的回调 const better_scroll = throttle(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); // Debounce(事件防抖)： 最后一个人说了算 // fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间 function debounce(fn, delay) { // 定时器 let timer = null; // 将debounce处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this; // 保留调用时传入的参数 let args = arguments; // 每次事件被触发时，都去清除之前的旧定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(function () { fn.apply(context, args); }, delay); }; } // 用debounce来包装scroll的回调 const better_scroll = debounce(() =\u0026gt; console.log(\u0026#34;触发了滚动事件\u0026#34;), 1000); document.addEventListener(\u0026#34;scroll\u0026#34;, better_scroll); \u0026nbsp;手写原生AJAX请求 原生 ajax 步骤\n创建XMLHttpRequest对象 使用open方法设置和服务器的交互信息 使用send发送数据 注册事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const getJSON = function (url) { return new Promise((resolve, reject) =\u0026gt; { const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\u0026#34;Mscrosoft.XMLHttp\u0026#34;); xhr.open(\u0026#34;GET\u0026#34;, url, false); xhr.setRequestHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); xhr.onreadystatechange = function () { if (xhr.readyState !== 4) return; if (xhr.status === 200 || xhr.status === 304) { resolve(xhr.responseText); } else { reject(new Error(xhr.responseText)); } }; xhr.send(); }); }; \u0026nbsp;手写 String.prototype.trim 1 2 3 String.prototype.trim = function () { return this.replace(/^\\s+/, \u0026#34;\u0026#34;).replace(/\\s+$/, \u0026#34;\u0026#34;); }; \u0026nbsp;手写 Array.flat 1 2 3 4 5 6 7 const flat = (arr) =\u0026gt; { const isDeep = arr.some((item) =\u0026gt; item instanceof Array); if (!isDeep) return arr; const res = Array.prototype.concat.apply([], arr); return flat(res); }; \u0026nbsp;手写去重 1 2 3 4 const unique = (arr) =\u0026gt; { const set = new Set(arr); return [...arr]; }; \u0026nbsp;手写 setInterval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const mySetInterval = (fn, delay) =\u0026gt; { let timer = null, isClear = false; function loop() { if (isClear) { isClear = false; clearTimeout(timer); return; } fn(); timer = setTimeout(loop, delay); } timer = setTimeout(loop, delay); return () =\u0026gt; { isClear = true; }; }; \u0026nbsp; 手写 判断类数组 1 2 3 4 5 6 7 8 9 10 const isArrayLikeObject = (arr) =\u0026gt; { if (typeof arr !== \u0026#34;object\u0026#34; || arr === null) return false; const lengthMaxVal = Math.pow(2, 53) - 1; if (!Object.prototype.hasOwnProperty.call(arr, \u0026#34;length\u0026#34;)) return false; if (typeof arr.length !== \u0026#34;number\u0026#34;) return false; if (!isFinite(arr.length)) return false; if (Array !== arr.constructor) return false; if (arr.length \u0026gt; 0 \u0026amp;\u0026amp; arr.length \u0026lt; lengthMaxVal) return true; return false; }; \u0026nbsp;获取当前 url 中的参数的值 1 2 3 4 5 const query = (name) =\u0026gt; { const search = location.search; const params = new URLSearchParams(search); return params.get(name); }; \u0026nbsp;将 URL 参数解析为 JS 对象 1 2 3 4 5 6 7 8 9 function queryToObject() { const res = {}; const search = location.search; const pList = new URLSearchParams(search); pList.forEach((key, val) =\u0026gt; { res[key] = val; }); return res; } \u0026nbsp;手写JSON.Stringify JSON.stringify()将值转换为相应的 JSON 格式：\n转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。\n非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。\n布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。\nundefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined).\n对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。\n所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。\nDate 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。\nNaN 和 Infinity 格式的数值及 null 都会被当做 null。\n其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。\n\u0026mdash;\u0026mdash;\u0026mdash; MDN\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function jsonStringify(data) { let type = typeof data; if (type !== \u0026#34;object\u0026#34;) { let result = data; //data 可能是基础数据类型的情况在这里处理 if (Number.isNaN(data) || data === Infinity) { //NaN 和 Infinity 序列化返回 \u0026#34;null\u0026#34; result = \u0026#34;null\u0026#34;; } else if ( type === \u0026#34;function\u0026#34; || type === \u0026#34;undefined\u0026#34; || type === \u0026#34;symbol\u0026#34; ) { // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理 return undefined; } else if (type === \u0026#34;string\u0026#34;) { result = \u0026#39;\u0026#34;\u0026#39; + data + \u0026#39;\u0026#34;\u0026#39;; } return String(result); } else if (type === \u0026#34;object\u0026#34;) { if (data === null) { return \u0026#34;null\u0026#34;; } else if (data.toJSON \u0026amp;\u0026amp; typeof data.toJSON === \u0026#34;function\u0026#34;) { return jsonStringify(data.toJSON()); } else if (data instanceof Array) { let result = []; //如果是数组，那么数组里面的每一项类型又有可能是多样的 data.forEach((item, index) =\u0026gt; { if ( typeof item === \u0026#34;undefined\u0026#34; || typeof item === \u0026#34;function\u0026#34; || typeof item === \u0026#34;symbol\u0026#34; ) { result[index] = \u0026#34;null\u0026#34;; } else { result[index] = jsonStringify(item); } }); result = \u0026#34;[\u0026#34; + result + \u0026#34;]\u0026#34;; return result.replace(/\u0026#39;/g, \u0026#39;\u0026#34;\u0026#39;); } else { // 处理普通对象 let result = []; Object.keys(data).forEach((item, index) =\u0026gt; { if (typeof item !== \u0026#34;symbol\u0026#34;) { //key 如果是 symbol 对象，忽略 if ( data[item] !== undefined \u0026amp;\u0026amp; typeof data[item] !== \u0026#34;function\u0026#34; \u0026amp;\u0026amp; typeof data[item] !== \u0026#34;symbol\u0026#34; ) { //键值如果是 undefined、function、symbol 为属性值，忽略 result.push(\u0026#39;\u0026#34;\u0026#39; + item + \u0026#39;\u0026#34;\u0026#39; + \u0026#34;:\u0026#34; + jsonStringify(data[item])); } } }); return (\u0026#34;{\u0026#34; + result + \u0026#34;}\u0026#34;).replace(/\u0026#39;/g, \u0026#39;\u0026#34;\u0026#39;); } } } \u0026nbsp;手写runGenerator \u0026nbsp;手写Promise Promise\nPromise.race\n1 2 3 4 5 6 7 8 9 10 11 Promise.race = function (arr) { return new Promise(function (resolve, reject) { if (!Array.isArray(arr)) { return reject(new TypeError(\u0026#34;Promise.race accepts an array\u0026#34;)); } for (var i = 0, len = arr.length; i \u0026lt; len; i++) { Promise.resolve(arr[i]).then(resolve, reject); } }); }; Promise.all\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 输入不仅仅只有Array function promiseAll(args) { return new Promise((resolve, reject) =\u0026gt; { const promiseResults = []; let iteratorIndex = 0; // 已完成的数量，用于最终的返回，不能直接用完成数量作为iteratorIndex // 输出顺序和完成顺序是两码事 let fullCount = 0; // 用于迭代iterator数据 for (const item of args) { // for of 遍历顺序，用于返回正确顺序的结果 // 因iterator用forEach遍历后的key和value一样，所以必须存一份for of的 iteratorIndex let resultIndex = iteratorIndex; iteratorIndex += 1; // 包一层，以兼容非promise的情况 Promise.resolve(item) .then((res) =\u0026gt; { promiseResults[resultIndex] = res; fullCount += 1; // Iterator 接口的数据无法单纯的用length和size判断长度，不能局限于Array和 Map类型中 if (fullCount === iteratorIndex) { resolve(promiseResults); } }) .catch((err) =\u0026gt; { reject(err); }); } // 处理空 iterator 的情况 if (iteratorIndex === 0) { resolve(promiseResults); } }); } if (!Promise.all) Promise.all = promiseAll; \u0026nbsp;实现lodash.get 实现类似 lodash.get ，有以下测试用例:\n1 2 3 4 5 6 7 8 9 10 var object = { a: [{ b: { c: 3 } }] }; get(object, \u0026#34;a[0].b.c\u0026#34;); // =\u0026gt; 3 get(object, [\u0026#34;a\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]); // =\u0026gt; 3 get(object, \u0026#34;a.b.c\u0026#34;, \u0026#34;default\u0026#34;); // =\u0026gt; \u0026#39;default\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * object: 对象 * path: 输入的路径 * defaultVal: 默认值 **/ function get(object, path, defaultVal = \u0026#34;undefined\u0026#34;) { // 先将path处理成统一格式 let newPath = []; if (Array.isArray(path)) { newPath = path; } else { // 先将字符串中的\u0026#39;[\u0026#39;、\u0026#39;]\u0026#39;去除替换为\u0026#39;.\u0026#39;，split分割成数组形式 newPath = path.replace(/\\[/g, \u0026#34;.\u0026#34;).replace(/\\]/g, \u0026#34;\u0026#34;).split(\u0026#34;.\u0026#34;); } // 递归处理，返回最后结果 return ( newPath.reduce((o, k) =\u0026gt; { // console.log(o, k); // 此处o初始值为下边传入的 object，后续值为每次取的内部值 return (o || {})[k]; }, object) || defaultVal ); } ","permalink":"https://zzydev.top/posts/eight-part-essay/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C/","summary":"\u0026nbsp;手写 instanceof 1 2 3 4 5 6 7 8 9 function myInstanceof(Left, Right) { if (typeof Left !== \u0026#34;object\u0026#34; || Left === null) return false; let proto = Object.getPrototypeOf(Left); while (true) { if (proto == null) return false; if (protp == Right.prototype) return true; proto = Object.getPrototypeOf(proto); } } \u0026nbsp;手写 getType 1 2 3 4","title":"有手就行"}]