<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>4.React Hooks设计动机与工作模式 | 人类低质量男性求职准备</title>
<meta name="keywords" content="react">
<meta name="description" content="函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用">
<meta name="author" content="zzydev">
<link rel="canonical" href="https://zzydev.top/posts/headfirstreact/4_react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6674d7a50459849e4062fe493da0c9c42da7aeff274291c318824f1e4cb20ec6.css" integrity="sha256-ZnTXpQRZhJ5AYv5JPaDJxC2nrv8nQpHDGIJPHkyyDsY=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zzydev.top/image/chance.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://zzydev.top/image/chance.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://zzydev.top/image/chance.gif">
<link rel="apple-touch-icon" href="https://zzydev.top/chance.gif">
<link rel="mask-icon" href="https://zzydev.top/chance.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="4.React Hooks设计动机与工作模式" />
<meta property="og:description" content="函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zzydev.top/posts/headfirstreact/4_react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-03T11:16:41&#43;08:00" />
<meta property="article:modified_time" content="2022-06-18T10:07:04&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="4.React Hooks设计动机与工作模式"/>
<meta name="twitter:description" content="函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章",
      "item": "https://zzydev.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "HeadFirstReact",
      "item": "https://zzydev.top/posts/headfirstreact/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "4.React Hooks设计动机与工作模式",
      "item": "https://zzydev.top/posts/headfirstreact/4_react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "4.React Hooks设计动机与工作模式",
  "name": "4.React Hooks设计动机与工作模式",
  "description": "函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用",
  "keywords": [
    "react"
  ],
  "articleBody": "函数组件会捕获 render 内部的状态，这是两类组件最大的不同。 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。\n如果你在这个在线 Demo中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：\n明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！\n这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？\n因为虽然 props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。\n多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，我们通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。\n但如果我们把 ProfilePage 改造为一个像这样的函数组件：\n1 2 3 4 5 6 7 8 9 function ProfilePage(props) { const showMessage = () =\u003e { alert(\"Followed \" + props.user); }; const handleClick = () =\u003e { setTimeout(showMessage, 3000); }; return Follow\u003c/button\u003e; } 事情就会大不一样。\nprops 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。\n总结：“函数组件会捕获 render 内部的状态”，函数组件真正地把数据和渲染绑定到了一起。\n函数组件是一个更加匹配 React 设计理念、也更有利于逻辑拆分与重用的组件表达形式\n从核心 API 看 Hooks 的基本形态 useState()：为函数组件引入状态 1 2 3 4 5 6 7 8 9 10 11 12 const [state, setState] = useState(initialState); //状态和修改状态的 API 名都是可以自定义的 const [text, setText] = useState(\"初始文本\"); //它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值 // 定义为数组 const [author, setAuthor] = useState([\"zzydev\", \"zzy\"]); // 定义为数值 const [length, setLength] = useState(100); // 定义为字符串 const [text, setText] = useState(\"初始文本\"); state 中永远不要保存可以通过计算得到的值。 比如：\n从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。 从 URL 中读到的值。有时我们要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候，从 URL 中读取，而不是读出来放在 state 中。 从 cookie、localStorage 中读取的值。通常每次要用的时候直接去读取，而不是读出来放到 state 中。 state 虽然便于维护状态，但也有自己的弊端。一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。\nuseEffect()：允许函数组件执行副作用操作 useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。\nuseEffect 是每次组件 render 完后判断依赖并执行\n没有依赖项，则每次 render 后都会重新执行。 1 2 3 4 useEffect(() =\u003e { // 每次 render 完都会执行 console.log(\"re-rendered\"); }); 仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组作为依赖项。对应到 Class 组件就是 componentDidMount。 1 2 3 4 useEffect(() =\u003e { // 这里是业务逻辑 console.log(\"did mount\"); }, []); 仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。这个机制就几乎等价于类组件中的 componentWillUnmount。 1 2 3 4 5 6 useEffect(() =\u003e { // 这里是 A 的业务逻辑 // 返回一个函数记为 B return () =\u003e {}; }, []); useEffect 回调中返回的函数被称为“清除函数”，当 React 识别到清除函数时，会在卸载时执行清除函数内部的逻辑。这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理。\n每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。 1 2 3 4 5 6 7 useEffect(() =\u003e { // 这里是 A 的业务逻辑 // 返回一个函数记为 B return () =\u003e {}; }); //React 在每一次渲染都去触发 A 逻辑，并且在下一次 A 逻辑被触发之前去触发 B 逻辑。 根据一定的依赖条件来触发的副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述），同时传入一个非空的数组。 1 2 3 4 5 6 7 8 9 10 11 12 useEffect(() =\u003e { // 这是回调函数的业务逻辑 // 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发 return xxx; }, [num1, num2, num3]); /* 数组中的变量一般都是来源于组件本身的数据（props 或者 state）。 若数组不为空，那么 React 就会在新的一次渲染后去对比前后两次的渲染， 查看数组内是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了）， 并在有更新的前提下去触发 useEffect 中定义的副作用逻辑。 */ 理解 Hooks 的依赖 Hooks(useEffect、useCallback、useMemo) 提供了让你监听某个数据变化的能力。这个变化可能会触发组件的刷新，也可能是去创建一个副作用，又或者是刷新一个缓存。那么定义要监听哪些数据变化的机制，其实就是指定 Hooks 的依赖项。\n那么在定义依赖项时，我们需要注意以下三点：\n依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。 依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。 React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方。例如下面的代码： 1 2 3 4 5 6 7 function Sample() { // 这里在每次组件执行时创建了一个新数组 const todos = [{ text: \"Learn hooks.\" }]; useEffect(() =\u003e { console.log(\"Todos changed.\"); }, [todos]); } 代码的原意可能是在 todos 变化的时候去产生一些副作用，但是这里的 todos 变量是在函数内创建的，实际上每次都产生了一个新数组。所以在作为依赖项的时候进行引用的比较，实际上被认为是发生了变化的。\nReact 为什么要发明 Hooks 告别难以理解的 Class: Class 的“痛点”:\n生命周期\n生命周期的带来的麻烦提现在：学习成本和不合理的逻辑规划方式 React 组件之间是不会相互继承的\n比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 组件来继承 Button。React 实际上没利用到 Class 的继承特性的。 UI 由状态驱动，很少在外部调用类实例（即组件）的方法。\n组件所有的方法都是在类内部调用或者作为生命周期函数被自动调用。 this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Example extends Component { state = { name: 'zzydev', age: '99'; }; changeAge() { // 这里会报错 this.setState({ age: '100' }); } render() { return this.changeAge}\u003e{this.state.name}的年龄是{this.state.age}\u003c/button\u003e } } changeAge 这个方法：它是 button 按钮的事件监听函数。当我点击 button 按钮时，希望它能够帮我修改状态，但事实是，点击发生后，程序会报错。原因很简单，changeAge 里并不能拿到组件实例的 this。为了解决 this 不符合预期的问题，可以使用 this.changeAga = this.changeAga.bind(this) 或 箭头函数的方式，但这两种方式 本质上都是在用实践层面的约束来解决设计层面的问题\nHooks 如何实现更好的逻辑拆分 过去我们组织自己业务逻辑的方式：先想清楚业务的需要是什么样的，然后将对应的业务逻辑拆到不同的生命周期函数里去。逻辑与生命周期耦合在一起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 componentDidMount() { // 1. 这里发起异步调用 // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM // 3. 这里设置一个订阅 // 4. 这里随便干点别的什么 // ... } componentWillUnMount() { // 在这里卸载订阅 } componentDidUpdate() { // 1. 在这里根据 DidMount 获取到的异步数据更新 DOM // 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样） } 像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。\n而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。\n状态复用：Hooks 将复杂的问题变简单 过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。\nHooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。\nReact Hooks 的局限性 Hooks 暂时还不能完全地为函数组件补齐类组件的能力 比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。\nHooks 在使用层面有着严格的规则约束 Hooks 的使用规则包括以下两个: 只能在函数组件的顶级作用域使用；只能在函数组件或者其他 Hooks 中使用。 所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。Hooks 使用规则背后的”原理“\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function MyComp() { const [count, setCount] = useState(0); if (count \u003e 10) { // ⚠️ 错误：不能将 Hook 用在条件判断里 useEffect(() =\u003e { // ... }, [count]); } // ⚠️ 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了 if (count === 0) { return \"No content\"; } // ⚠️ 错误：不能将 Hook 放在可能的 return 之后 const [loading, setLoading] = useState(false); //... return {count}\u003c/div\u003e; } Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，一种是在函数组件内，另外一种则是在自定义的 Hooks 里面。 但是如果一定要在 Class 组件中使用，那应该如何做呢？其实有一个通用的机制，那就是利用高阶组件的模式，将 Hooks 封装成高阶组件，从而让类组件使用。 举个例子。我们已经定义了监听窗口大小变化的一个 Hook：useWindowSize。那么很容易就可以将其转换为高阶组件：\n1 2 3 4 5 6 7 8 9 import React from \"react\"; import { useWindowSize } from \"../hooks/useWindowSize\"; export const withWindowSize = (Comp) =\u003e { return (props) =\u003e { const windowSize = useWindowSize(); return ; }; }; 那么我们就可以通过如下代码来使用这个高阶组件：\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \"react\"; import { withWindowSize } from \"./withWindowSize\"; class MyComp { render() { const { windowSize } = this.props; // ... } } // 通过 withWindowSize 高阶组件给 MyComp 添加 windowSize 属性 export default withWindowSize(MyComp); 这样，通过 withWindowSize 这样一个高阶组件模式，你就可以把 useWindowSize 的结果作为属性，传递给需要使用窗口大小的类组件，这样就可以实现在 Class 组件中复用 Hooks 的逻辑了。\n使用 ESLint 插件帮助检查 Hooks 的使用 1 yarn add eslint-plugin-react-hooks -S 然后在你的 ESLint 配置文件中加入两个规则：rules-of-hooks 和 exhaustive-deps。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \"plugins\": [ // ... \"react-hooks\" ], \"rules\": { // ... // 检查 Hooks 的使用规则 \"react-hooks/rules-of-hooks\": \"error\", // 检查依赖项的声明 \"react-hooks/exhaustive-deps\": \"warn\" } } ",
  "wordCount" : "4786",
  "inLanguage": "en",
  "datePublished": "2022-06-03T11:16:41+08:00",
  "dateModified": "2022-06-18T10:07:04Z",
  "author":[{
    "@type": "Person",
    "name": "zzydev"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zzydev.top/posts/headfirstreact/4_react-hooks%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "人类低质量男性求职准备",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zzydev.top/image/chance.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zzydev.top" accesskey="h" title="人类低质量男性求职准备 (Alt + H)">人类低质量男性求职准备</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zzydev.top/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zzydev.top">Home</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/">文章</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/headfirstreact/">HeadFirstReact</a></div>
    <h1 class="post-title">
      4.React Hooks设计动机与工作模式
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2022-06-03 11:16:41 +0800 CST'>2022-06-03</span>&nbsp;|&nbsp;更新:&nbsp;2022-06-18&nbsp;|&nbsp;字数:&nbsp;4786字&nbsp;|&nbsp;时长: 10分钟&nbsp;|&nbsp;zzydev

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e4%bc%9a%e6%8d%95%e8%8e%b7-render-%e5%86%85%e9%83%a8%e7%9a%84%e7%8a%b6%e6%80%81%e8%bf%99%e6%98%af%e4%b8%a4%e7%b1%bb%e7%bb%84%e4%bb%b6%e6%9c%80%e5%a4%a7%e7%9a%84%e4%b8%8d%e5%90%8c" aria-label="函数组件会捕获 render 内部的状态，这是两类组件最大的不同。">函数组件会捕获 render 内部的状态，这是两类组件最大的不同。</a></li>
                    <li>
                        <a href="#%e4%bb%8e%e6%a0%b8%e5%bf%83-api-%e7%9c%8b-hooks-%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%bd%a2%e6%80%81" aria-label="从核心 API 看 Hooks 的基本形态">从核心 API 看 Hooks 的基本形态</a><ul>
                            
                    <li>
                        <a href="#usestate%e4%b8%ba%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e5%bc%95%e5%85%a5%e7%8a%b6%e6%80%81" aria-label="useState()：为函数组件引入状态">useState()：为函数组件引入状态</a></li>
                    <li>
                        <a href="#useeffect%e5%85%81%e8%ae%b8%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e6%89%a7%e8%a1%8c%e5%89%af%e4%bd%9c%e7%94%a8%e6%93%8d%e4%bd%9c" aria-label="useEffect()：允许函数组件执行副作用操作">useEffect()：允许函数组件执行副作用操作</a></li>
                    <li>
                        <a href="#%e7%90%86%e8%a7%a3-hooks-%e7%9a%84%e4%be%9d%e8%b5%96" aria-label="理解 Hooks 的依赖">理解 Hooks 的依赖</a></li></ul>
                    </li>
                    <li>
                        <a href="#react-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%8f%91%e6%98%8e-hooks" aria-label="React 为什么要发明 Hooks">React 为什么要发明 Hooks</a><ul>
                            
                    <li>
                        <a href="#%e5%91%8a%e5%88%ab%e9%9a%be%e4%bb%a5%e7%90%86%e8%a7%a3%e7%9a%84-class" aria-label="告别难以理解的 Class:">告别难以理解的 Class:</a></li>
                    <li>
                        <a href="#hooks-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%9b%b4%e5%a5%bd%e7%9a%84%e9%80%bb%e8%be%91%e6%8b%86%e5%88%86" aria-label="Hooks 如何实现更好的逻辑拆分">Hooks 如何实现更好的逻辑拆分</a></li>
                    <li>
                        <a href="#%e7%8a%b6%e6%80%81%e5%a4%8d%e7%94%a8hooks-%e5%b0%86%e5%a4%8d%e6%9d%82%e7%9a%84%e9%97%ae%e9%a2%98%e5%8f%98%e7%ae%80%e5%8d%95" aria-label="状态复用：Hooks 将复杂的问题变简单">状态复用：Hooks 将复杂的问题变简单</a></li></ul>
                    </li>
                    <li>
                        <a href="#react-hooks-%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7" aria-label="React Hooks 的局限性">React Hooks 的局限性</a><ul>
                            
                    <li>
                        <a href="#hooks-%e6%9a%82%e6%97%b6%e8%bf%98%e4%b8%8d%e8%83%bd%e5%ae%8c%e5%85%a8%e5%9c%b0%e4%b8%ba%e5%87%bd%e6%95%b0%e7%bb%84%e4%bb%b6%e8%a1%a5%e9%bd%90%e7%b1%bb%e7%bb%84%e4%bb%b6%e7%9a%84%e8%83%bd%e5%8a%9b" aria-label="Hooks 暂时还不能完全地为函数组件补齐类组件的能力">Hooks 暂时还不能完全地为函数组件补齐类组件的能力</a></li>
                    <li>
                        <a href="#hooks-%e5%9c%a8%e4%bd%bf%e7%94%a8%e5%b1%82%e9%9d%a2%e6%9c%89%e7%9d%80%e4%b8%a5%e6%a0%bc%e7%9a%84%e8%a7%84%e5%88%99%e7%ba%a6%e6%9d%9f" aria-label="Hooks 在使用层面有着严格的规则约束">Hooks 在使用层面有着严格的规则约束</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-eslint-%e6%8f%92%e4%bb%b6%e5%b8%ae%e5%8a%a9%e6%a3%80%e6%9f%a5-hooks-%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="使用 ESLint 插件帮助检查 Hooks 的使用">使用 ESLint 插件帮助检查 Hooks 的使用</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="函数组件会捕获-render-内部的状态这是两类组件最大的不同">函数组件会捕获 render 内部的状态，这是两类组件最大的不同。<a hidden class="anchor" aria-hidden="true" href="#函数组件会捕获-render-内部的状态这是两类组件最大的不同">#</a></h2>
<p>React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。</p>
<p>如果你在这个<a href="https://codesandbox.io/s/pjqnl16lm7" target="_blank">在线 Demo</a>中尝试点击基于类组件形式编写的 ProfilePage 按钮后 3s 内把用户切换为 Sophie，你就会看到如下图所示的效果：</p>
<p><img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/4-1.png" alt=""  />
</p>
<p>明明我们是在 Dan 的主页点击的关注，结果却提示了“Followed Sophie”！</p>
<p>这个现象必然让许多人感到困惑：user 的内容是通过 props 下发的，props 作为不可变值，为什么会从 Dan 变成 Sophie 呢？</p>
<p>因为虽然 <strong>props 本身是不可变的，但 this 却是可变的，this 上的数据是可以被修改的</strong>，this.props 的调用每次都会获取最新的 props，而这正是 React 确保数据实时性的一个重要手段。</p>
<p>多数情况下，在 React 生命周期对执行顺序的调控下，this.props 和 this.state 的变化都能够和预期中的渲染动作保持一致。但在这个案例中，我们<strong>通过 setTimeout 将预期中的渲染推迟了 3s，打破了 this.props 和渲染动作之间的这种时机上的关联</strong>，进而导致渲染时捕获到的是一个错误的、修改后的 this.props。这就是问题的所在。</p>
<p>但如果我们把 ProfilePage 改造为一个像这样的函数组件：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> ProfilePage(props) {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">const</span> showMessage = () =&gt; {
</span></span><span style="display:flex;"><span>    alert(<span style="color:#0ff;font-weight:bold">&#34;Followed &#34;</span> + props.user);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">const</span> handleClick = () =&gt; {
</span></span><span style="display:flex;"><span>    setTimeout(showMessage, <span style="color:#ff0;font-weight:bold">3000</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> &lt;button onClick={handleClick}&gt;Follow&lt;<span style="color:#f00">/button&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>事情就会大不一样。</p>
<p>props 会在 ProfilePage 函数执行的一瞬间就被捕获，而 props 本身又是一个不可变值，因此<strong>我们可以充分确保从现在开始，在任何时机下读取到的 props，都是最初捕获到的那个 props</strong>。当父组件传入新的 props 来尝试重新渲染 ProfilePage 时，本质上是基于新的 props 入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props 的捕获。这样一来，我们便确保了渲染结果确实能够符合预期。</p>
<p>总结：<strong>“函数组件会捕获 render 内部的状态”</strong>，<strong>函数组件真正地把数据和渲染绑定到了一起。</strong></p>
<p><strong>函数组件是一个更加匹配 React 设计理念、也更有利于逻辑拆分与重用的组件表达形式</strong></p>
<h2 id="从核心-api-看-hooks-的基本形态">从核心 API 看 Hooks 的基本形态<a hidden class="anchor" aria-hidden="true" href="#从核心-api-看-hooks-的基本形态">#</a></h2>
<h3 id="usestate为函数组件引入状态">useState()：为函数组件引入状态<a hidden class="anchor" aria-hidden="true" href="#usestate为函数组件引入状态">#</a></h3>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">const</span> [state, setState] = useState(initialState);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//状态和修改状态的 API 名都是可以自定义的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> [text, setText] = useState(<span style="color:#0ff;font-weight:bold">&#34;初始文本&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// 定义为数组
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> [author, setAuthor] = useState([<span style="color:#0ff;font-weight:bold">&#34;zzydev&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;zzy&#34;</span>]);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 定义为数值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> [length, setLength] = useState(<span style="color:#ff0;font-weight:bold">100</span>);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 定义为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">const</span> [text, setText] = useState(<span style="color:#0ff;font-weight:bold">&#34;初始文本&#34;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><p>
<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p><strong>state 中永远不要保存可以通过计算得到的值。</strong> 比如：</p>
<ol>
<li>从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。</li>
<li>从 URL 中读到的值。有时我们要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候，从 URL 中读取，而不是读出来放在 state 中。</li>
<li>从 cookie、localStorage 中读取的值。通常每次要用的时候直接去读取，而不是读出来放到 state 中。</li>
</ol></div>

state 虽然便于维护状态，但也有自己的弊端。一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。</p>
<h3 id="useeffect允许函数组件执行副作用操作">useEffect()：允许函数组件执行副作用操作<a hidden class="anchor" aria-hidden="true" href="#useeffect允许函数组件执行副作用操作">#</a></h3>
<p>useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。</p>

<div class="notice notice-tip" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>useEffect 是每次组件 render 完后判断依赖并执行</p></div>

<ul>
<li>没有依赖项，则每次 render 后都会重新执行。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 每次 render 完都会执行
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  console.log(<span style="color:#0ff;font-weight:bold">&#34;re-rendered&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组作为依赖项。对应到 Class 组件就是 componentDidMount。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这里是业务逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  console.log(<span style="color:#0ff;font-weight:bold">&#34;did mount&#34;</span>);
</span></span><span style="display:flex;"><span>}, []);
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，那么将在挂载阶段执行 A，卸载阶段执行 B。这个机制就几乎等价于类组件中的 componentWillUnmount。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这里是 A 的业务逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 返回一个函数记为 B
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">return</span> () =&gt; {};
</span></span><span style="display:flex;"><span>}, []);
</span></span></code></pre></td></tr></table>
</div>
</div><p>useEffect 回调中返回的函数被称为“清除函数”，当 React 识别到清除函数时，会在卸载时执行清除函数内部的逻辑。这个规律不会受第二个参数或者其他因素的影响，只要你在 useEffect 回调中返回了一个函数，它就会被作为清除函数来处理。</p>
<ul>
<li>每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这里是 A 的业务逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 返回一个函数记为 B
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">return</span> () =&gt; {};
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//React 在每一次渲染都去触发 A 逻辑，并且在下一次 A 逻辑被触发之前去触发 B 逻辑。
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>根据一定的依赖条件来触发的副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述），同时传入一个非空的数组。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这是回调函数的业务逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">return</span> xxx;
</span></span><span style="display:flex;"><span>}, [num1, num2, num3]);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/*
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">数组中的变量一般都是来源于组件本身的数据（props 或者 state）。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">若数组不为空，那么 React 就会在新的一次渲染后去对比前后两次的渲染，
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">查看数组内是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了），
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">并在有更新的前提下去触发 useEffect 中定义的副作用逻辑。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="理解-hooks-的依赖">理解 Hooks 的依赖<a hidden class="anchor" aria-hidden="true" href="#理解-hooks-的依赖">#</a></h3>
<p>Hooks(useEffect、useCallback、useMemo) 提供了让你监听某个数据变化的能力。这个变化可能会触发组件的刷新，也可能是去创建一个副作用，又或者是刷新一个缓存。那么定义要监听哪些数据变化的机制，其实就是指定 Hooks 的依赖项。</p>
<p>那么在定义依赖项时，我们需要注意以下三点：</p>
<ol>
<li>依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。</li>
<li>依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。</li>
<li>React 会使用<strong>浅比较</strong>来对比依赖项是否发生了变化，所以要<strong>特别注意数组或者对象类型</strong>。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方。例如下面的代码：</li>
</ol>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> Sample() {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这里在每次组件执行时创建了一个新数组
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">const</span> todos = [{ text: <span style="color:#0ff;font-weight:bold">&#34;Learn hooks.&#34;</span> }];
</span></span><span style="display:flex;"><span>  useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#0ff;font-weight:bold">&#34;Todos changed.&#34;</span>);
</span></span><span style="display:flex;"><span>  }, [todos]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码的原意可能是在 todos 变化的时候去产生一些副作用，但是这里的 todos 变量是在函数内创建的，实际上每次都产生了一个新数组。所以在作为依赖项的时候进行引用的比较，实际上被认为是发生了变化的。</p>
<h2 id="react-为什么要发明-hooks">React 为什么要发明 Hooks<a hidden class="anchor" aria-hidden="true" href="#react-为什么要发明-hooks">#</a></h2>
<h3 id="告别难以理解的-class">告别难以理解的 Class:<a hidden class="anchor" aria-hidden="true" href="#告别难以理解的-class">#</a></h3>
<p>Class 的“痛点”:</p>
<ol>
<li>生命周期<br>
生命周期的带来的麻烦提现在：学习成本和不合理的逻辑规划方式</li>
<li>React 组件之间是不会相互继承的<br>
比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 组件来继承 Button。React 实际上没利用到 Class 的继承特性的。</li>
<li>UI 由状态驱动，很少在外部调用类实例（即组件）的方法。<br>
组件所有的方法都是在类内部调用或者作为生命周期函数被自动调用。</li>
<li>this</li>
</ol>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Example <span style="color:#fff;font-weight:bold">extends</span> Component {
</span></span><span style="display:flex;"><span> state = {
</span></span><span style="display:flex;"><span>   name: <span style="color:#0ff;font-weight:bold">&#39;zzydev&#39;</span>,
</span></span><span style="display:flex;"><span>   age: <span style="color:#0ff;font-weight:bold">&#39;99&#39;</span>;
</span></span><span style="display:flex;"><span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> changeAge() {
</span></span><span style="display:flex;"><span> <span style="color:#007f7f">// 这里会报错
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span> <span style="color:#fff;font-weight:bold">this</span>.setState({
</span></span><span style="display:flex;"><span> age: <span style="color:#0ff;font-weight:bold">&#39;100&#39;</span>
</span></span><span style="display:flex;"><span> });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> render() {
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">return</span> &lt;button onClick={<span style="color:#fff;font-weight:bold">this</span>.changeAge}&gt;{<span style="color:#fff;font-weight:bold">this</span>.state.name}的年龄是{<span style="color:#fff;font-weight:bold">this</span>.state.age}&lt;<span style="color:#f00">/button&gt;</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>changeAge 这个方法：它是 button 按钮的事件监听函数。当我点击 button 按钮时，希望它能够帮我修改状态，但事实是，点击发生后，程序会报错。原因很简单，changeAge 里并不能拿到组件实例的 this。为了解决 this 不符合预期的问题，可以使用 this.changeAga = this.changeAga.bind(this) 或 箭头函数的方式，但这两种方式 <strong>本质上都是在用实践层面的约束来解决设计层面的问题</strong></p>
<h3 id="hooks-如何实现更好的逻辑拆分">Hooks 如何实现更好的逻辑拆分<a hidden class="anchor" aria-hidden="true" href="#hooks-如何实现更好的逻辑拆分">#</a></h3>
<p>过去我们组织自己业务逻辑的方式：先想清楚业务的需要是什么样的，然后将对应的业务逻辑拆到不同的生命周期函数里去。<strong>逻辑与生命周期耦合在一起</strong>。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>componentDidMount() {
</span></span><span style="display:flex;"><span> <span style="color:#007f7f">// 1. 这里发起异步调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span> <span style="color:#007f7f">// 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span> <span style="color:#007f7f">// 3. 这里设置一个订阅
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span> <span style="color:#007f7f">// 4. 这里随便干点别的什么
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span> <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>componentWillUnMount() {
</span></span><span style="display:flex;"><span> <span style="color:#007f7f">// 在这里卸载订阅
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>componentDidUpdate() {
</span></span><span style="display:flex;"><span> <span style="color:#007f7f">// 1. 在这里根据 DidMount 获取到的异步数据更新 DOM
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span> <span style="color:#007f7f">// 2. 这里从 props 里获取某个数据，根据这个数据更新 DOM（和 DidMount 的第2步一样）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，<strong>这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样</strong>。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。</p>
<p>而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作<strong>按照逻辑上的关联拆分进不同的函数组件里：<strong>我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们</strong>实现业务逻辑的聚合，避免复杂的组件和冗余的代码</strong>。</p>
<h3 id="状态复用hooks-将复杂的问题变简单">状态复用：Hooks 将复杂的问题变简单<a hidden class="anchor" aria-hidden="true" href="#状态复用hooks-将复杂的问题变简单">#</a></h3>
<p>过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。</p>
<p>Hooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。</p>
<h2 id="react-hooks-的局限性">React Hooks 的局限性<a hidden class="anchor" aria-hidden="true" href="#react-hooks-的局限性">#</a></h2>
<h3 id="hooks-暂时还不能完全地为函数组件补齐类组件的能力">Hooks 暂时还不能完全地为函数组件补齐类组件的能力<a hidden class="anchor" aria-hidden="true" href="#hooks-暂时还不能完全地为函数组件补齐类组件的能力">#</a></h3>
<p>比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。</p>
<h3 id="hooks-在使用层面有着严格的规则约束">Hooks 在使用层面有着严格的规则约束<a hidden class="anchor" aria-hidden="true" href="#hooks-在使用层面有着严格的规则约束">#</a></h3>
<p>Hooks 的使用规则包括以下两个: 只能在函数组件的顶级作用域使用；只能在函数组件或者其他 Hooks 中使用。
所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。<a href="https://zzydev.top/posts/headfirstreact/5_%E6%B7%B1%E5%85%A5react-hooks%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/" target="_blank">Hooks 使用规则背后的”原理“</a></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> MyComp() {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">const</span> [count, setCount] = useState(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (count &gt; <span style="color:#ff0;font-weight:bold">10</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ⚠️ 错误：不能将 Hook 用在条件判断里
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }, [count]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// ⚠️ 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">if</span> (count === <span style="color:#ff0;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;No content&#34;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// ⚠️ 错误：不能将 Hook 放在可能的 return 之后
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">const</span> [loading, setLoading] = useState(<span style="color:#fff;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">//...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">return</span> &lt;div&gt;{count}&lt;<span style="color:#f00">/div&gt;;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，<strong>一种是在函数组件内，另外一种则是在自定义的 Hooks 里面。</strong>
但是如果一定要在 Class 组件中使用，那应该如何做呢？其实有一个通用的机制，那就是利用高阶组件的模式，将 Hooks 封装成高阶组件，从而让类组件使用。
举个例子。我们已经定义了监听窗口大小变化的一个 Hook：useWindowSize。那么很容易就可以将其转换为高阶组件：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> React from <span style="color:#0ff;font-weight:bold">&#34;react&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> { useWindowSize } from <span style="color:#0ff;font-weight:bold">&#34;../hooks/useWindowSize&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">export</span> <span style="color:#fff;font-weight:bold">const</span> withWindowSize = (Comp) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> (props) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">const</span> windowSize = useWindowSize();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> &lt;Comp windowSize={windowSize} {...props} /&gt;;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么我们就可以通过如下代码来使用这个高阶组件：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> React from <span style="color:#0ff;font-weight:bold">&#34;react&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> { withWindowSize } from <span style="color:#0ff;font-weight:bold">&#34;./withWindowSize&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> MyComp {
</span></span><span style="display:flex;"><span>  render() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">const</span> { windowSize } = <span style="color:#fff;font-weight:bold">this</span>.props;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 通过 withWindowSize 高阶组件给 MyComp 添加 windowSize 属性
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">export</span> <span style="color:#fff;font-weight:bold">default</span> withWindowSize(MyComp);
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，通过 withWindowSize 这样一个高阶组件模式，你就可以把 useWindowSize 的结果作为属性，传递给需要使用窗口大小的类组件，这样就可以实现在 Class 组件中复用 Hooks 的逻辑了。</p>
<h3 id="使用-eslint-插件帮助检查-hooks-的使用">使用 ESLint 插件帮助检查 Hooks 的使用<a hidden class="anchor" aria-hidden="true" href="#使用-eslint-插件帮助检查-hooks-的使用">#</a></h3>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>yarn add eslint-plugin-react-hooks -S
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在你的 ESLint 配置文件中加入两个规则：rules-of-hooks 和 exhaustive-deps。如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">&#34;plugins&#34;</span>: [
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#0ff;font-weight:bold">&#34;react-hooks&#34;</span>
</span></span><span style="display:flex;"><span>  ],
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">&#34;rules&#34;</span>: {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 检查 Hooks 的使用规则
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="font-weight:bold">&#34;react-hooks/rules-of-hooks&#34;</span>: <span style="color:#0ff;font-weight:bold">&#34;error&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 检查依赖项的声明
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="font-weight:bold">&#34;react-hooks/exhaustive-deps&#34;</span>: <span style="color:#0ff;font-weight:bold">&#34;warn&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zzydev.top/tags/react/">react</a></li>
    </ul>
<nav class="paginav">
  
  <a class="prev" href="https://zzydev.top/posts/headfirstreact/3_%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8react%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%E7%9A%84/">
    <span class="title">« Prev</span>
    <br>
    <span>3.数据是如何在React组件之间流动的？</span>
  </a>
  <a class="next" href="https://zzydev.top/posts/headfirstreact/5_%E6%B7%B1%E5%85%A5react-hooks%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/">
    <span class="title">Next »</span>
    <br>
    <span>5.深入React Hooks工作机制,Hooks本质是链表</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 4.React Hooks设计动机与工作模式 on twitter"
        href="https://twitter.com/intent/tweet/?text=4.React%20Hooks%e8%ae%be%e8%ae%a1%e5%8a%a8%e6%9c%ba%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f&amp;hashtags=react">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 4.React Hooks设计动机与工作模式 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f&amp;title=4.React%20Hooks%e8%ae%be%e8%ae%a1%e5%8a%a8%e6%9c%ba%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f&amp;summary=4.React%20Hooks%e8%ae%be%e8%ae%a1%e5%8a%a8%e6%9c%ba%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f&amp;source=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 4.React Hooks设计动机与工作模式 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f&title=4.React%20Hooks%e8%ae%be%e8%ae%a1%e5%8a%a8%e6%9c%ba%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 4.React Hooks设计动机与工作模式 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 4.React Hooks设计动机与工作模式 on whatsapp"
        href="https://api.whatsapp.com/send?text=4.React%20Hooks%e8%ae%be%e8%ae%a1%e5%8a%a8%e6%9c%ba%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f%20-%20https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 4.React Hooks设计动机与工作模式 on telegram"
        href="https://telegram.me/share/url?text=4.React%20Hooks%e8%ae%be%e8%ae%a1%e5%8a%a8%e6%9c%ba%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f4_react-hooks%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E5%25B7%25A5%25E4%25BD%259C%25E6%25A8%25A1%25E5%25BC%258F%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div>
  <div class="pagination__title">
      <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
      <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.11/dist/twikoo.all.min.js"></script>
  <script>
      twikoo.init({
          envId: "https://twikoo-ah7vxzqs6-zzydev.vercel.app/",  
          el: "#tcomment",
          lang: 'zh-CN',
          region: 'ap-guangzhou',  
          path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
      });
  </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>zzydev</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
