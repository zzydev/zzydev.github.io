<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>10.ReactDom.render的渲染链路(上) | 人类低质量男性求职准备</title>
<meta name="keywords" content="react">
<meta name="description" content="ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from &#34;react&#34;; import ReactDOM from &#34;react-dom&#34;; function App() { return ( &lt;div className=&#34;App&#34;&gt; &lt;div className=&#34;container&#34;&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &l">
<meta name="author" content="zzydev">
<link rel="canonical" href="https://zzydev.top/posts/headfirstreact/10_reactdom.render%E7%9A%84%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%B8%8A/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4de2c28ad363a52d9d0f17b1eccc40e33b1a2e842ad060fe71bae5593a5d4c51.css" integrity="sha256-TeLCitNjpS2dDxex7MxA4zsaLoQq0GD&#43;cbrlWTpdTFE=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zzydev.top/image/chance.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://zzydev.top/image/chance.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://zzydev.top/image/chance.gif">
<link rel="apple-touch-icon" href="https://zzydev.top/chance.gif">
<link rel="mask-icon" href="https://zzydev.top/chance.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="10.ReactDom.render的渲染链路(上)" />
<meta property="og:description" content="ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from &#34;react&#34;; import ReactDOM from &#34;react-dom&#34;; function App() { return ( &lt;div className=&#34;App&#34;&gt; &lt;div className=&#34;container&#34;&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &l" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zzydev.top/posts/headfirstreact/10_reactdom.render%E7%9A%84%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%B8%8A/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T03:59:38&#43;08:00" />
<meta property="article:modified_time" content="2022-06-09T03:59:38&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="10.ReactDom.render的渲染链路(上)"/>
<meta name="twitter:description" content="ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from &#34;react&#34;; import ReactDOM from &#34;react-dom&#34;; function App() { return ( &lt;div className=&#34;App&#34;&gt; &lt;div className=&#34;container&#34;&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &l"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章",
      "item": "https://zzydev.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "HeadFirstReact",
      "item": "https://zzydev.top/posts/headfirstreact/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "10.ReactDom.render的渲染链路(上)",
      "item": "https://zzydev.top/posts/headfirstreact/10_reactdom.render%E7%9A%84%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%B8%8A/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "10.ReactDom.render的渲染链路(上)",
  "name": "10.ReactDom.render的渲染链路(上)",
  "description": "ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是标题\u0026lt;/h1\u0026gt; \u0026l",
  "keywords": [
    "react"
  ],
  "articleBody": "ReactDOM.render 调用栈的逻辑分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React from \"react\"; import ReactDOM from \"react-dom\"; function App() { return ( \u003cdiv className=\"App\"\u003e \u003cdiv className=\"container\"\u003e \u003ch1\u003e我是标题\u003c/h1\u003e \u003cp\u003e我是第一段话\u003c/p\u003e \u003cp\u003e我是第二段话\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 打开 Chrome 的 Performance 面板，点击下图红色圈圈所圈住的这个“记录”按钮： 然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图： 放大该图，定位“src/index.js”这个文件路径，我们就可以找到 ReactDOM.render 方法对应的调用栈，如下图所示： 图中 scheduleUpdateOnFiber 方法的作用是调度更新，在由 ReactDOM.render 发起的首屏渲染这个场景下，它触发的就是 performSyncWorkOnRoot。performSyncWorkOnRoot 开启的正是我们反复强调的 render 阶段；而 commitRoot 方法开启的则是真实 DOM 的渲染过程（commit 阶段）。因此以 scheduleUpdateOnFiber 和 commitRoot 两个方法为界，我们可以大致把 ReactDOM.render 的调用栈划分为三个阶段：\n初始化阶段 render 阶段 commit 阶段 拆解 ReactDOM.render 调用栈——初始化阶段 首先我们提取出初始化过程中涉及的调用栈大图： 图中的方法完成 Fiber 树中基本实体的创建\n在 ReactDOM.render 函数体中，如下面代码所示，调用了 legacyRenderSubtreeIntoContainer：\n1 2 3 4 5 6 7 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ); legacyRenderSubtreeIntoContainer 的关键逻辑如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 function legacyRenderSubtreeIntoContainer( parentComponent, children, container, forceHydrate, callback ) { // container 对应的是我们传入的真实 DOM 对象 var root = container._reactRootContainer; // 初始化 fiberRoot 对象 var fiberRoot; // DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空 if (!root) { // 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate ); // legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot fiberRoot = root._internalRoot; // 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可 if (typeof callback === \"function\") { var originalCallback = callback; callback = function () { var instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); }; } // Initial mount should not be batched. // 进入 unbatchedUpdates 方法 unbatchedUpdates(function () { updateContainer(children, fiberRoot, parentComponent, callback); }); } else { // else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致 fiberRoot = root._internalRoot; if (typeof callback === \"function\") { var _originalCallback = callback; callback = function () { var instance = getPublicRootInstance(fiberRoot); _originalCallback.call(instance); }; } // Update updateContainer(children, fiberRoot, parentComponent, callback); } return getPublicRootInstance(fiberRoot); } 首次渲染过程中 legacyRenderSubtreeIntoContainer 方法的主要逻辑链路： 在这个流程中，你需要关注到 fiberRoot 这个对象。fiberRoot 到底是什么呢？这里我将运行时的 root 和 fiberRoot 为你截取出来，其中 root 对象的结构如下图所示： 可以看出，root 对象（container._reactRootContainer）上有一个 _internalRoot 属性，这个 _internalRoot 也就是 fiberRoot。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容： 或许你会对 current 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“current 对象是一个 FiberNode 实例”这一点，而 FiberNode，正是 Fiber 节点对应的对象类型。current 对象是一个 Fiber 节点，不仅如此，它还是当前 Fiber 树的头部节点。\n考虑到 current 属性对应的 FiberNode 节点，在调用栈中实际是由 createHostRootFiber 方法创建的，React 源码中也有多处以 rootFiber 代指 current 对象，因此下文中我们将以 rootFiber 指代 current 对象。\n读到这里，你脑海中应该不难形成一个这样的指向关系： 其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而 rootFiber 则作为虚拟 DOM 的根节点存在。这两个节点，将是后续整棵 Fiber 树构建的起点。\n接下来，fiberRoot 将和 ReactDOM.render 方法的其他入参一起，被传入 updateContainer 方法，从而形成一个回调。这个回调，正是接下来要调用的 unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates 做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function unbatchedUpdates(fn, a) { // 这里是对上下文的处理，不必纠结 var prevExecutionContext = executionContext; executionContext \u0026= ~BatchedContext; executionContext |= LegacyUnbatchedContext; try { // 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法 return fn(a); } finally { // finally 逻辑里是对回调队列的处理，此处不用太关注 executionContext = prevExecutionContext; if (executionContext === NoContext) { // Flush the immediate callbacks that were scheduled during this batch resetRenderTimer(); flushSyncCallbackQueue(); } } } 在 unbatchedUpdates 函数体里，当下你只需要 Get 到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn 是什么呢？fn 是一个针对 updateContainer 的调用：\n1 2 3 unbatchedUpdates(function () { updateContainer(children, fiberRoot, parentComponent, callback); }); 接下来我们很有必要去看看 updateContainer 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function updateContainer(element, container, parentComponent, callback) { ...... // 这是一个 event 相关的入参，此处不必关注 var eventTime = requestEventTime(); ...... // 这是一个比较关键的入参，lane 表示优先级 var lane = requestUpdateLane(current$1); // 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新 var update = createUpdate(eventTime, lane); // update 的 payload 对应的是一个 React 元素 update.payload = { element: element }; // 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback callback = callback === undefined ? null : callback; if (callback !== null) { { if (typeof callback !== 'function') { error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback); } } update.callback = callback; } // 将 update 入队 enqueueUpdate(current$1, update); // 调度 fiberRoot scheduleUpdateOnFiber(current$1, lane, eventTime); // 返回当前节点（fiberRoot）的优先级 return lane; } updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：\n请求当前 Fiber 节点的 lane（优先级）；\n结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；\n调度当前节点（rootFiber）。\n函数体中的 scheduleWork 其实就是 scheduleUpdateOnFiber，scheduleUpdateOnFiber 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是在 ReactDOM.render 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：\nperformSyncWorkOnRoot 直译过来就是“执行根节点的同步任务”，这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。\n前面我们曾经提到过，performSyncWorkOnRoot 是 render 阶段的起点，render 阶段的任务就是完成 Fiber 树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render 阶段应该是一个可打断的异步过程（下一讲我们就将针对 render 过程作详细的逻辑拆解）。\n而现在，我相信你心里更多的疑惑在于：都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢？\n关于异步模式下的首次渲染链路 Concurrent 模式开启后，首次渲染的调用栈变成了如下图所示的样子： 乍一看，好像和 ReactDOM.render 差别很大，其实不然。图中 createRoot 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示： 我们拉近一点来看，如下图所示： 你会发现这地方也调用了一个 render。再顺着这个调用往下看，发现有大量的熟悉面孔：updateContainer、requestUpdateLane、createUpdate、scheduleUpdateOnFiber……这些函数在 ReactDOM.render 的调用栈中也出现过。\n其实，当前你看到的这个 render 调用链路，和 ReactDOM.render 的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber 的这个判断里： 在异步渲染模式下，由于请求到的 lane 不再是 SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot 这个调用，而是会转而执行 else 中调度相关的逻辑。\n这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 requestUpdateLane 函数为例，下面是它局部的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 function requestUpdateLane(fiber) { // 获取 mode 属性 var mode = fiber.mode; // 结合 mode 属性判断当前的 if ((mode \u0026 BlockingMode) === NoMode) { return SyncLane; } else if ((mode \u0026 ConcurrentMode) === NoMode) { return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane; } ...... return lane; } 上面代码中需要注意 fiber 节点上的 mode 属性：React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式。\n因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。\n关于异步挂载/更新的实现细节，我们将在后续的第 16 讲“Fiber 架构实现原理与编码形态”中详细探讨。\n",
  "wordCount" : "3278",
  "inLanguage": "en",
  "datePublished": "2022-06-09T03:59:38+08:00",
  "dateModified": "2022-06-09T03:59:38+08:00",
  "author":[{
    "@type": "Person",
    "name": "zzydev"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zzydev.top/posts/headfirstreact/10_reactdom.render%E7%9A%84%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%B8%8A/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "人类低质量男性求职准备",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zzydev.top/image/chance.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zzydev.top" accesskey="h" title="人类低质量男性求职准备 (Alt + H)">人类低质量男性求职准备</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zzydev.top/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zzydev.top">Home</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/">文章</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/headfirstreact/">HeadFirstReact</a></div>
    <h1 class="post-title">
      10.ReactDom.render的渲染链路(上)<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2022-06-09 03:59:38 +0800 CST'>2022-06-09</span>&nbsp;|&nbsp;更新:&nbsp;2022-06-09&nbsp;|&nbsp;字数:&nbsp;3278字&nbsp;|&nbsp;时长: 7分钟&nbsp;|&nbsp;zzydev

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#reactdomrender-%e8%b0%83%e7%94%a8%e6%a0%88%e7%9a%84%e9%80%bb%e8%be%91%e5%88%86%e5%b1%82" aria-label="ReactDOM.render 调用栈的逻辑分层">ReactDOM.render 调用栈的逻辑分层</a></li>
                    <li>
                        <a href="#%e6%8b%86%e8%a7%a3-reactdomrender-%e8%b0%83%e7%94%a8%e6%a0%88%e5%88%9d%e5%a7%8b%e5%8c%96%e9%98%b6%e6%ae%b5" aria-label="拆解 ReactDOM.render 调用栈——初始化阶段">拆解 ReactDOM.render 调用栈——初始化阶段</a></li>
                    <li>
                        <a href="#%e5%85%b3%e4%ba%8e%e5%bc%82%e6%ad%a5%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84%e9%a6%96%e6%ac%a1%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af" aria-label="关于异步模式下的首次渲染链路">关于异步模式下的首次渲染链路</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="reactdomrender-调用栈的逻辑分层">ReactDOM.render 调用栈的逻辑分层<a hidden class="anchor" aria-hidden="true" href="#reactdomrender-调用栈的逻辑分层">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> React from <span style="color:#0ff;font-weight:bold">&#34;react&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> ReactDOM from <span style="color:#0ff;font-weight:bold">&#34;react-dom&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> App() {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="font-weight:bold">div</span> <span style="color:#007f7f">className</span>=<span style="color:#0ff;font-weight:bold">&#34;App&#34;</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="font-weight:bold">div</span> <span style="color:#007f7f">className</span>=<span style="color:#0ff;font-weight:bold">&#34;container&#34;</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="font-weight:bold">h1</span>&gt;我是标题&lt;/<span style="font-weight:bold">h1</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="font-weight:bold">p</span>&gt;我是第一段话&lt;/<span style="font-weight:bold">p</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;<span style="font-weight:bold">p</span>&gt;我是第二段话&lt;/<span style="font-weight:bold">p</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;/<span style="font-weight:bold">div</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="font-weight:bold">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">const</span> rootElement = <span style="color:#fff;font-weight:bold">document</span>.getElementById(<span style="color:#0ff;font-weight:bold">&#34;root&#34;</span>);
</span></span><span style="display:flex;"><span>ReactDOM.render(&lt;<span style="font-weight:bold">App</span> /&gt;, rootElement);
</span></span></code></pre></td></tr></table>
</div>
</div><p>打开 Chrome 的 Performance 面板，点击下图红色圈圈所圈住的这个“记录”按钮：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-1.png" alt="10-1"  />
</p>
<p>然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-2.png" alt="10-2"  />
</p>
<p>放大该图，定位“src/index.js”这个文件路径，我们就可以找到 ReactDOM.render 方法对应的调用栈，如下图所示：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-3.png" alt="10-3"  />
</p>
<p>图中 scheduleUpdateOnFiber 方法的作用是调度更新，在由 ReactDOM.render 发起的首屏渲染这个场景下，它触发的就是 performSyncWorkOnRoot。performSyncWorkOnRoot 开启的正是我们反复强调的 render 阶段；而 commitRoot 方法开启的则是真实 DOM 的渲染过程（commit 阶段）。因此以 scheduleUpdateOnFiber 和 commitRoot 两个方法为界，我们可以大致把 ReactDOM.render 的调用栈划分为三个阶段：</p>
<ol>
<li>初始化阶段</li>
<li>render 阶段</li>
<li>commit 阶段</li>
</ol>
<h2 id="拆解-reactdomrender-调用栈初始化阶段">拆解 ReactDOM.render 调用栈——初始化阶段<a hidden class="anchor" aria-hidden="true" href="#拆解-reactdomrender-调用栈初始化阶段">#</a></h2>
<p>首先我们提取出初始化过程中涉及的调用栈大图：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-4.png" alt="10-4"  />

图中的方法完成 Fiber 树中基本实体的创建<br>
在 ReactDOM.render 函数体中，如下面代码所示，调用了 legacyRenderSubtreeIntoContainer：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> legacyRenderSubtreeIntoContainer(
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">null</span>,
</span></span><span style="display:flex;"><span>  element,
</span></span><span style="display:flex;"><span>  container,
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">false</span>,
</span></span><span style="display:flex;"><span>  callback
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></td></tr></table>
</div>
</div><p>legacyRenderSubtreeIntoContainer 的关键逻辑如下:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">46
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">47
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">48
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> legacyRenderSubtreeIntoContainer(
</span></span><span style="display:flex;"><span>  parentComponent,
</span></span><span style="display:flex;"><span>  children,
</span></span><span style="display:flex;"><span>  container,
</span></span><span style="display:flex;"><span>  forceHydrate,
</span></span><span style="display:flex;"><span>  callback
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// container 对应的是我们传入的真实 DOM 对象
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> root = container._reactRootContainer;
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 初始化 fiberRoot 对象
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> fiberRoot;
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">if</span> (!root) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
</span></span><span style="display:flex;"><span>      container,
</span></span><span style="display:flex;"><span>      forceHydrate
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    fiberRoot = root._internalRoot;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">typeof</span> callback === <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">var</span> originalCallback = callback;
</span></span><span style="display:flex;"><span>      callback = <span style="color:#fff;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">var</span> instance = getPublicRootInstance(fiberRoot);
</span></span><span style="display:flex;"><span>        originalCallback.call(instance);
</span></span><span style="display:flex;"><span>      };
</span></span><span style="display:flex;"><span>    } <span style="color:#007f7f">// Initial mount should not be batched.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 进入 unbatchedUpdates 方法
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    unbatchedUpdates(<span style="color:#fff;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>      updateContainer(children, fiberRoot, parentComponent, callback);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    fiberRoot = root._internalRoot;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">typeof</span> callback === <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">var</span> _originalCallback = callback;
</span></span><span style="display:flex;"><span>      callback = <span style="color:#fff;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">var</span> instance = getPublicRootInstance(fiberRoot);
</span></span><span style="display:flex;"><span>        _originalCallback.call(instance);
</span></span><span style="display:flex;"><span>      };
</span></span><span style="display:flex;"><span>    } <span style="color:#007f7f">// Update
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    updateContainer(children, fiberRoot, parentComponent, callback);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> getPublicRootInstance(fiberRoot);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>首次渲染过程中 legacyRenderSubtreeIntoContainer 方法的主要逻辑链路：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-5.png" alt="10-5"  />

在这个流程中，你需要关注到 fiberRoot 这个对象。fiberRoot 到底是什么呢？这里我将运行时的 root 和 fiberRoot 为你截取出来，其中 root 对象的结构如下图所示：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-6.png" alt="10-6"  />

可以看出，root 对象（container._reactRootContainer）上有一个 _internalRoot 属性，这个 _internalRoot 也就是 fiberRoot。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-7.png" alt="10-7"  />

或许你会对 current 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“current 对象是一个 FiberNode 实例”这一点，而 FiberNode，正是 Fiber 节点对应的对象类型。current 对象是一个 Fiber 节点，不仅如此，它还是当前 Fiber 树的头部节点。</p>
<p>考虑到 current 属性对应的 FiberNode 节点，在调用栈中实际是由 createHostRootFiber 方法创建的，React 源码中也有多处以 rootFiber 代指 current 对象，因此下文中我们将以 rootFiber 指代 current 对象。</p>
<p>读到这里，你脑海中应该不难形成一个这样的指向关系：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-8.png" alt="10-8"  />

其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而 rootFiber 则作为虚拟 DOM 的根节点存在。这两个节点，将是后续整棵 Fiber 树构建的起点。</p>
<p>接下来，fiberRoot 将和 ReactDOM.render 方法的其他入参一起，被传入 updateContainer 方法，从而形成一个回调。这个回调，正是接下来要调用的 unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates 做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> unbatchedUpdates(fn, a) {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这里是对上下文的处理，不必纠结
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> prevExecutionContext = executionContext;
</span></span><span style="display:flex;"><span>  executionContext &amp;= ~BatchedContext;
</span></span><span style="display:flex;"><span>  executionContext |= LegacyUnbatchedContext;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> fn(a);
</span></span><span style="display:flex;"><span>  } <span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// finally 逻辑里是对回调队列的处理，此处不用太关注
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    executionContext = prevExecutionContext;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (executionContext === NoContext) {
</span></span><span style="display:flex;"><span>      <span style="color:#007f7f">// Flush the immediate callbacks that were scheduled during this batch
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>      resetRenderTimer();
</span></span><span style="display:flex;"><span>      flushSyncCallbackQueue();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 unbatchedUpdates 函数体里，当下你只需要 Get 到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn 是什么呢？fn 是一个针对 updateContainer 的调用：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>unbatchedUpdates(<span style="color:#fff;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>  updateContainer(children, fiberRoot, parentComponent, callback);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来我们很有必要去看看 updateContainer 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> updateContainer(element, container, parentComponent, callback) {
</span></span><span style="display:flex;"><span>  ......
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这是一个 event 相关的入参，此处不必关注
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> eventTime = requestEventTime();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ......
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 这是一个比较关键的入参，lane 表示优先级
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> lane = requestUpdateLane(current$1);
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> update = createUpdate(eventTime, lane);
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// update 的 payload 对应的是一个 React 元素
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  update.payload = {
</span></span><span style="display:flex;"><span>    element: element
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  callback = callback === <span style="color:#fff;font-weight:bold">undefined</span> ? <span style="color:#fff;font-weight:bold">null</span> : callback;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (callback !== <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">typeof</span> callback !== <span style="color:#0ff;font-weight:bold">&#39;function&#39;</span>) {
</span></span><span style="display:flex;"><span>        error(<span style="color:#0ff;font-weight:bold">&#39;render(...): Expected the last optional `callback` argument to be a &#39;</span> + <span style="color:#0ff;font-weight:bold">&#39;function. Instead received: %s.&#39;</span>, callback);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    update.callback = callback;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 将 update 入队
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  enqueueUpdate(current$1, update);
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 调度 fiberRoot
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  scheduleUpdateOnFiber(current$1, lane, eventTime);
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 返回当前节点（fiberRoot）的优先级
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">return</span> lane;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p>
<ul>
<li>
<p>请求当前 Fiber 节点的 lane（优先级）；</p>
</li>
<li>
<p>结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</p>
</li>
<li>
<p>调度当前节点（rootFiber）。</p>
</li>
</ul>
<p>函数体中的 scheduleWork 其实就是 scheduleUpdateOnFiber，scheduleUpdateOnFiber 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是在 ReactDOM.render 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：</p>
<p><img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-9.png" alt="10-9"  />

performSyncWorkOnRoot 直译过来就是“执行根节点的同步任务”，这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。</p>
<p>前面我们曾经提到过，performSyncWorkOnRoot 是 render 阶段的起点，render 阶段的任务就是完成 Fiber 树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render 阶段应该是一个可打断的异步过程（下一讲我们就将针对 render 过程作详细的逻辑拆解）。</p>
<p>而现在，我相信你心里更多的疑惑在于：都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢？</p>
<h2 id="关于异步模式下的首次渲染链路">关于异步模式下的首次渲染链路<a hidden class="anchor" aria-hidden="true" href="#关于异步模式下的首次渲染链路">#</a></h2>
<p>Concurrent 模式开启后，首次渲染的调用栈变成了如下图所示的样子：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-10.png" alt="10-10"  />

乍一看，好像和 ReactDOM.render 差别很大，其实不然。图中 createRoot 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-11.png" alt="10-11"  />

我们拉近一点来看，如下图所示：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-12.png" alt="10-12"  />

你会发现这地方也调用了一个 render。再顺着这个调用往下看，发现有大量的熟悉面孔：updateContainer、requestUpdateLane、createUpdate、scheduleUpdateOnFiber&hellip;&hellip;这些函数在 ReactDOM.render 的调用栈中也出现过。</p>
<p>其实，当前你看到的这个 render 调用链路，和 ReactDOM.render 的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber 的这个判断里：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/10-13.png" alt="10-13"  />

在异步渲染模式下，由于请求到的 lane 不再是 SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot 这个调用，而是会转而执行 else 中调度相关的逻辑。</p>
<p>这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 requestUpdateLane 函数为例，下面是它局部的代码：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> requestUpdateLane(fiber) {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 获取 mode 属性
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">var</span> mode = fiber.mode;
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// 结合 mode 属性判断当前的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">if</span> ((mode &amp; BlockingMode) === NoMode) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> SyncLane;
</span></span><span style="display:flex;"><span>  } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> ((mode &amp; ConcurrentMode) === NoMode) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ......
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> lane;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码中需要注意 fiber 节点上的 mode 属性：React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式。</p>
<p>因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。</p>
<p>关于异步挂载/更新的实现细节，我们将在后续的第 16 讲“Fiber 架构实现原理与编码形态”中详细探讨。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zzydev.top/tags/react/">react</a></li>
    </ul>
<nav class="paginav">
  
  <a class="prev" href="https://zzydev.top/posts/eight-part-essay/%E6%88%91%E7%9A%84%E6%8B%B7%E9%9D%A2%E7%BB%8F_2/">
    <span class="title">« Prev</span>
    <br>
    <span>我的拷面经（二）</span>
  </a>
  <a class="next" href="https://zzydev.top/posts/headfirstts/ts%E5%9F%BA%E7%A1%80%E6%8B%BE%E9%81%97/">
    <span class="title">Next »</span>
    <br>
    <span>TS基础拾遗</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 10.ReactDom.render的渲染链路(上) on twitter"
        href="https://twitter.com/intent/tweet/?text=10.ReactDom.render%e7%9a%84%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af%28%e4%b8%8a%29&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f&amp;hashtags=react">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 10.ReactDom.render的渲染链路(上) on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f&amp;title=10.ReactDom.render%e7%9a%84%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af%28%e4%b8%8a%29&amp;summary=10.ReactDom.render%e7%9a%84%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af%28%e4%b8%8a%29&amp;source=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 10.ReactDom.render的渲染链路(上) on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f&title=10.ReactDom.render%e7%9a%84%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af%28%e4%b8%8a%29">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 10.ReactDom.render的渲染链路(上) on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 10.ReactDom.render的渲染链路(上) on whatsapp"
        href="https://api.whatsapp.com/send?text=10.ReactDom.render%e7%9a%84%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af%28%e4%b8%8a%29%20-%20https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 10.ReactDom.render的渲染链路(上) on telegram"
        href="https://telegram.me/share/url?text=10.ReactDom.render%e7%9a%84%e6%b8%b2%e6%9f%93%e9%93%be%e8%b7%af%28%e4%b8%8a%29&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f10_reactdom.render%25E7%259A%2584%25E6%25B8%25B2%25E6%259F%2593%25E9%2593%25BE%25E8%25B7%25AF%25E4%25B8%258A%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div>
  <div class="pagination__title">
      <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
      <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.11/dist/twikoo.all.min.js"></script>
  <script>
      twikoo.init({
          envId: "https://twikoo-ah7vxzqs6-zzydev.vercel.app/",  
          el: "#tcomment",
          lang: 'zh-CN',
          region: 'ap-guangzhou',  
          path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
      });
  </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>zzydev</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
