<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>9.如何理解Fiber架构的迭代动机与设计思想 | 人类低质量男性求职准备</title>
<meta name="keywords" content="react">
<meta name="description" content="前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂">
<meta name="author" content="zzydev">
<link rel="canonical" href="https://zzydev.top/posts/headfirstreact/9_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.ce8eaa724ac5cfa35cb5e776d031ea4b1e1eb3c88bbd1dd133fd07f82206c87d.css" integrity="sha256-zo6qckrFz6Ncted20DHqSx4es8iLvR3RM/0H&#43;CIGyH0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="apple-touch-icon" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="mask-icon" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="9.如何理解Fiber架构的迭代动机与设计思想" />
<meta property="og:description" content="前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zzydev.top/posts/headfirstreact/9_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-06T19:15:48&#43;08:00" />
<meta property="article:modified_time" content="2022-06-18T16:55:46&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="9.如何理解Fiber架构的迭代动机与设计思想"/>
<meta name="twitter:description" content="前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章 📖",
      "item": "https://zzydev.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "React",
      "item": "https://zzydev.top/posts/headfirstreact/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "9.如何理解Fiber架构的迭代动机与设计思想",
      "item": "https://zzydev.top/posts/headfirstreact/9_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "9.如何理解Fiber架构的迭代动机与设计思想",
  "name": "9.如何理解Fiber架构的迭代动机与设计思想",
  "description": "前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂",
  "keywords": [
    "react"
  ],
  "articleBody": "前置知识：单线程的 JavaScript 与多线程的浏览器 JavaScript 线程和渲染线程必须是互斥的：这两个线程不能够穿插执行，必须串行。当其中一个线程执行时，另一个线程只能挂起等待。\n在这样的机制下，若 JavaScript 线程长时间地占用了主线程，那么**渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”。**一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，事件线程也在等待 JavaScript，这就导致你触发的事件也将是难以被响应的。\n为什么会产生“卡顿”这样的困局？ Stack Reconciler 需要的（同步递归）调和时间很长，这就意味着 JavaScript 线程将长时间地占用主线程，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题。\n设计思想：Fiber 是如何解决问题的 Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”。纤程的出现，意在对渲染过程实现更加精细的控制。\n从架构角度 Fiber 是对 React 核心算法（即调和过程）的重写 从编码角度 Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM” 从工作流的角度 Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。 Fiber 架构的应用目的，按照 React 官方的说法，是实现“增量渲染”。所谓“增量渲染”，通俗来说就是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里面。不过严格来说，增量渲染其实也只是一种手段，实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验。\nFiber 架构核心：“可中断”“可恢复”与“优先级” React15 架构 React15 架构可以分为两层：\nReconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Reconciler 协调器 我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等 API 触发更新。\n每当有更新发生时，Reconciler会做如下工作：\n调用函数组件、或 class 组件的render方法，将返回的 JSX 转化为虚拟 DOM 将虚拟 DOM 和上次更新时的虚拟 DOM 对比 通过对比找出本次更新中变化的虚拟 DOM 通知Renderer将变化的虚拟 DOM 渲染到页面上 你可以在这里 看到React官方对Reconciler的解释\nReact15 架构的缺点 在Reconciler中，mount的组件会调用mountComponent ，update的组件会调用updateComponent 。这两个方法都会递归更新子组件。\nReact16 架构 React16 架构可以分为三层：\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 相较于 React15，React16 中新增了Scheduler（调度器）\nScheduler（调度器） 既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。\n其实部分浏览器已经实现了这个 API，这就是requestIdleCallback。但是由于以下因素，React放弃使用：\n浏览器兼容性 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的requestIdleCallback触发的频率会变得很低 基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。\nScheduler 是独立于React的库\nReconciler（协调器） 我们知道，在 React15 中Reconciler是递归处理虚拟 DOM 的。让我们看看React16 的 Reconciler。\n我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。\n1 2 3 4 5 6 function workLoopConcurrent() { // Perform work until Scheduler asks us to yield while (workInProgress !== null \u0026\u0026 !shouldYield()) { workInProgress = performUnitOfWork(workInProgress); } } 那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？\n在 React16 中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟 DOM 打上代表增/删/更新的标记，类似这样：\n1 2 3 4 export const Placement = /* */ 0b0000000000010; export const Update = /* */ 0b0000000000100; export const PlacementAndUpdate = /* */ 0b0000000000110; export const Deletion = /* */ 0b0000000001000; 全部的标记见这里\n整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。\n你可以在这里看到React官方对 React16 新Reconciler的解释\nRenderer（渲染器） Renderer根据Reconciler为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。\n总结 在这套新的架构模式下，更新的处理工作流变成了这样：首先，每个更新任务都会被赋予一个优先级。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”。\nFiber 架构对生命周期的影响 Fiber 对生命周期的影响\n",
  "wordCount" : "2230",
  "inLanguage": "en",
  "datePublished": "2022-06-06T19:15:48+08:00",
  "dateModified": "2022-06-18T16:55:46Z",
  "author":[{
    "@type": "Person",
    "name": "zzydev"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zzydev.top/posts/headfirstreact/9_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "人类低质量男性求职准备",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zzydev.top" accesskey="h" title="人类低质量男性求职准备 (Alt + H)">人类低质量男性求职准备</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zzydev.top/search" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/posts" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/links" title="友链">
                    <span>友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zzydev.top">Home</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/">文章 📖</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/headfirstreact/">React</a></div>
    <h1 class="post-title">
      9.如何理解Fiber架构的迭代动机与设计思想<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2022-06-06 19:15:48 +0800 CST'>2022-06-06</span>&nbsp;|&nbsp;更新:&nbsp;2022-06-18&nbsp;|&nbsp;字数:&nbsp;2230字&nbsp;|&nbsp;时长: 5分钟&nbsp;|&nbsp;zzydev<span id="busuanzi_container_page_pv">
        &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
    </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e5%8d%95%e7%ba%bf%e7%a8%8b%e7%9a%84-javascript-%e4%b8%8e%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%b5%8f%e8%a7%88%e5%99%a8" aria-label="前置知识：单线程的 JavaScript 与多线程的浏览器">前置知识：单线程的 JavaScript 与多线程的浏览器</a></li>
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e4%ba%a7%e7%94%9f%e5%8d%a1%e9%a1%bf%e8%bf%99%e6%a0%b7%e7%9a%84%e5%9b%b0%e5%b1%80" aria-label="为什么会产生“卡顿”这样的困局？">为什么会产生“卡顿”这样的困局？</a></li>
                    <li>
                        <a href="#%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3fiber-%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e9%97%ae%e9%a2%98%e7%9a%84" aria-label="设计思想：Fiber 是如何解决问题的">设计思想：Fiber 是如何解决问题的</a></li>
                    <li>
                        <a href="#fiber-%e6%9e%b6%e6%9e%84%e6%a0%b8%e5%bf%83%e5%8f%af%e4%b8%ad%e6%96%ad%e5%8f%af%e6%81%a2%e5%a4%8d%e4%b8%8e%e4%bc%98%e5%85%88%e7%ba%a7" aria-label="Fiber 架构核心：“可中断”“可恢复”与“优先级”">Fiber 架构核心：“可中断”“可恢复”与“优先级”</a><ul>
                            
                    <li>
                        <a href="#react15-%e6%9e%b6%e6%9e%84" aria-label="React15 架构">React15 架构</a><ul>
                            
                    <li>
                        <a href="#reconciler-%e5%8d%8f%e8%b0%83%e5%99%a8" aria-label="Reconciler 协调器">Reconciler 协调器</a></li>
                    <li>
                        <a href="#react15-%e6%9e%b6%e6%9e%84%e7%9a%84%e7%bc%ba%e7%82%b9" aria-label="React15 架构的缺点">React15 架构的缺点</a></li></ul>
                    </li>
                    <li>
                        <a href="#react16-%e6%9e%b6%e6%9e%84" aria-label="React16 架构">React16 架构</a><ul>
                            
                    <li>
                        <a href="#scheduler%e8%b0%83%e5%ba%a6%e5%99%a8" aria-label="Scheduler（调度器）">Scheduler（调度器）</a></li>
                    <li>
                        <a href="#reconciler%e5%8d%8f%e8%b0%83%e5%99%a8" aria-label="Reconciler（协调器）">Reconciler（协调器）</a></li>
                    <li>
                        <a href="#renderer%e6%b8%b2%e6%9f%93%e5%99%a8" aria-label="Renderer（渲染器）">Renderer（渲染器）</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                    </li>
                    <li>
                        <a href="#fiber-%e6%9e%b6%e6%9e%84%e5%af%b9%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%9a%84%e5%bd%b1%e5%93%8d" aria-label="Fiber 架构对生命周期的影响">Fiber 架构对生命周期的影响</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><h2 id="前置知识单线程的-javascript-与多线程的浏览器">前置知识：单线程的 JavaScript 与多线程的浏览器<a hidden class="anchor" aria-hidden="true" href="#前置知识单线程的-javascript-与多线程的浏览器">#</a></h2>
<p><strong>JavaScript 线程和渲染线程必须是互斥的</strong>：这两个线程不能够穿插执行，必须串行。<strong>当其中一个线程执行时，另一个线程只能挂起等待。</strong></p>
<p>在这样的机制下，若 JavaScript 线程长时间地占用了主线程，那么**渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”。**一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，<strong>事件线程也在等待 JavaScript，这就导致你触发的事件也将是难以被响应的。</strong></p>
<h2 id="为什么会产生卡顿这样的困局">为什么会产生“卡顿”这样的困局？<a hidden class="anchor" aria-hidden="true" href="#为什么会产生卡顿这样的困局">#</a></h2>
<p><strong>Stack Reconciler 需要的（同步递归）调和时间很长</strong>，这就意味着 <strong>JavaScript 线程将长时间地占用主线程</strong>，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题。</p>
<h2 id="设计思想fiber-是如何解决问题的">设计思想：Fiber 是如何解决问题的<a hidden class="anchor" aria-hidden="true" href="#设计思想fiber-是如何解决问题的">#</a></h2>
<p><strong>Fiber 就是比线程还要纤细的一个过程</strong>，也就是所谓的“<strong>纤程</strong>”。纤程的出现，意在<strong>对渲染过程实现更加精细的控制</strong>。</p>
<ul>
<li>从架构角度 Fiber 是对 React 核心算法（即调和过程）的重写</li>
<li>从编码角度 Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM”</li>
<li>从工作流的角度 Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。</li>
</ul>
<p>Fiber 架构的应用目的，按照 React 官方的说法，是实现“<strong>增量渲染</strong>”。所谓“增量渲染”，通俗来说就是<strong>把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里面</strong>。不过严格来说，增量渲染其实也只是一种手段，实现增量渲染的目的，是为了<strong>实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级</strong>，最终达成更加顺滑的用户体验。</p>
<h2 id="fiber-架构核心可中断可恢复与优先级">Fiber 架构核心：“可中断”“可恢复”与“优先级”<a hidden class="anchor" aria-hidden="true" href="#fiber-架构核心可中断可恢复与优先级">#</a></h2>
<h3 id="react15-架构">React15 架构<a hidden class="anchor" aria-hidden="true" href="#react15-架构">#</a></h3>
<p>React15 架构可以分为两层：</p>
<ul>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<h4 id="reconciler-协调器">Reconciler 协调器<a hidden class="anchor" aria-hidden="true" href="#reconciler-协调器">#</a></h4>
<p>我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等 API 触发更新。</p>
<p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p>
<ul>
<li>调用函数组件、或 class 组件的<code>render</code>方法，将返回的 JSX 转化为虚拟 DOM</li>
<li>将虚拟 DOM 和上次更新时的虚拟 DOM 对比</li>
<li>通过对比找出本次更新中变化的虚拟 DOM</li>
<li>通知<strong>Renderer</strong>将变化的虚拟 DOM 渲染到页面上</li>
</ul>

<div class="notice notice-note" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z"/></svg></div><blockquote class="quote">
      <p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers" target="_blank">这里 </a>看到<code>React</code>官方对<strong>Reconciler</strong>的解释</p></blockquote> </div>

<h4 id="react15-架构的缺点">React15 架构的缺点<a hidden class="anchor" aria-hidden="true" href="#react15-架构的缺点">#</a></h4>
<p>在<strong>Reconciler</strong>中，<code>mount</code>的组件会调用<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498" target="_blank">mountComponent </a>，<code>update</code>的组件会调用<a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877" target="_blank">updateComponent </a>。这两个方法都会递归更新子组件。</p>
<h3 id="react16-架构">React16 架构<a hidden class="anchor" aria-hidden="true" href="#react16-架构">#</a></h3>
<p>React16 架构可以分为三层：</p>
<ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入<strong>Reconciler</strong></li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>相较于 React15，React16 中新增了<strong>Scheduler（调度器）</strong></p>
<h4 id="scheduler调度器">Scheduler（调度器）<a hidden class="anchor" aria-hidden="true" href="#scheduler调度器">#</a></h4>
<p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>
<p>其实部分浏览器已经实现了这个 API，这就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank">requestIdleCallback</a>。但是由于以下因素，<code>React</code>放弃使用：</p>
<ul>
<li>浏览器兼容性</li>
<li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的<code>requestIdleCallback</code>触发的频率会变得很低</li>
</ul>
<p>基于以上原因，<code>React</code>实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<strong>Scheduler</strong>。除了在空闲时触发回调的功能外，<strong>Scheduler</strong>还提供了多种调度优先级供任务设置。</p>

<div class="notice notice-tip" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md" target="_blank">Scheduler </a>是独立于<code>React</code>的库</p></div>

<h4 id="reconciler协调器">Reconciler（协调器）<a hidden class="anchor" aria-hidden="true" href="#reconciler协调器">#</a></h4>
<p>我们知道，在 React15 中<strong>Reconciler</strong>是递归处理虚拟 DOM 的。让我们看看<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673" target="_blank">React16 的 Reconciler</a>。</p>
<p>我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">function</span> workLoopConcurrent() {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// Perform work until Scheduler asks us to yield
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">while</span> (workInProgress !== <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; !shouldYield()) {
</span></span><span style="display:flex;"><span>    workInProgress = performUnitOfWork(workInProgress);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p>
<p>在 React16 中，<strong>Reconciler</strong>与<strong>Renderer</strong>不再是交替工作。当<strong>Scheduler</strong>将任务交给<strong>Reconciler</strong>后，<strong>Reconciler</strong>会为变化的虚拟 DOM 打上代表增/删/更新的标记，类似这样：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">export</span> <span style="color:#fff;font-weight:bold">const</span> Placement = <span style="color:#007f7f">/*             */</span> <span style="color:#ff0;font-weight:bold">0b0000000000010</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">export</span> <span style="color:#fff;font-weight:bold">const</span> Update = <span style="color:#007f7f">/*                */</span> <span style="color:#ff0;font-weight:bold">0b0000000000100</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">export</span> <span style="color:#fff;font-weight:bold">const</span> PlacementAndUpdate = <span style="color:#007f7f">/*    */</span> <span style="color:#ff0;font-weight:bold">0b0000000000110</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">export</span> <span style="color:#fff;font-weight:bold">const</span> Deletion = <span style="color:#007f7f">/*              */</span> <span style="color:#ff0;font-weight:bold">0b0000000001000</span>;
</span></span></code></pre></td></tr></table>
</div>
</div>
<div class="notice notice-tip" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>全部的标记见<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js" target="_blank">这里</a></p></div>

<p>整个<strong>Scheduler</strong>与<strong>Reconciler</strong>的工作都在内存中进行。只有当所有组件都完成<strong>Reconciler</strong>的工作，才会统一交给<strong>Renderer</strong>。</p>

<div class="notice notice-tip" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><blockquote>
<p>你可以在<a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#fiber-reconciler" target="_blank">这里</a>看到<code>React</code>官方对 React16 新<strong>Reconciler</strong>的解释</p>
</blockquote></div>

<h4 id="renderer渲染器">Renderer（渲染器）<a hidden class="anchor" aria-hidden="true" href="#renderer渲染器">#</a></h4>
<p><strong>Renderer</strong>根据<strong>Reconciler</strong>为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。</p>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>在这套新的架构模式下，更新的处理工作流变成了这样：首先，<strong>每个更新任务都会被赋予一个优先级</strong>。当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 <strong>A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，这便是所谓“可恢复”</strong>。</p>
<h2 id="fiber-架构对生命周期的影响">Fiber 架构对生命周期的影响<a hidden class="anchor" aria-hidden="true" href="#fiber-架构对生命周期的影响">#</a></h2>
<p><a href="https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#%e7%bb%86%e8%af%b4%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%ba%9f%e6%97%a7%e7%ab%8b%e6%96%b0%e8%83%8c%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83" target="_blank">Fiber 对生命周期的影响</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zzydev.top/tags/react/">react</a></li>
    </ul>
<nav class="paginav">
  
  <a class="prev" href="https://zzydev.top/posts/headfirstreact/8_setstate%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/">
    <span class="title">« Prev</span>
    <br>
    <span>8.SetState是同步的还是异步的？</span>
  </a>
  <a class="next" href="https://zzydev.top/posts/headfirstbabel/1_%E5%88%9D%E8%A7%81babel/">
    <span class="title">Next »</span>
    <br>
    <span>1_初见Babel</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 9.如何理解Fiber架构的迭代动机与设计思想 on twitter"
        href="https://twitter.com/intent/tweet/?text=9.%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3Fiber%e6%9e%b6%e6%9e%84%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%8a%a8%e6%9c%ba%e4%b8%8e%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f&amp;hashtags=react">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 9.如何理解Fiber架构的迭代动机与设计思想 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f&amp;title=9.%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3Fiber%e6%9e%b6%e6%9e%84%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%8a%a8%e6%9c%ba%e4%b8%8e%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3&amp;summary=9.%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3Fiber%e6%9e%b6%e6%9e%84%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%8a%a8%e6%9c%ba%e4%b8%8e%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3&amp;source=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 9.如何理解Fiber架构的迭代动机与设计思想 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f&title=9.%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3Fiber%e6%9e%b6%e6%9e%84%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%8a%a8%e6%9c%ba%e4%b8%8e%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 9.如何理解Fiber架构的迭代动机与设计思想 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 9.如何理解Fiber架构的迭代动机与设计思想 on whatsapp"
        href="https://api.whatsapp.com/send?text=9.%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3Fiber%e6%9e%b6%e6%9e%84%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%8a%a8%e6%9c%ba%e4%b8%8e%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3%20-%20https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 9.如何理解Fiber架构的迭代动机与设计思想 on telegram"
        href="https://telegram.me/share/url?text=9.%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3Fiber%e6%9e%b6%e6%9e%84%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%8a%a8%e6%9c%ba%e4%b8%8e%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f9_%25E5%25A6%2582%25E4%25BD%2595%25E7%2590%2586%25E8%25A7%25A3fiber%25E6%259E%25B6%25E6%259E%2584%25E7%259A%2584%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258A%25A8%25E6%259C%25BA%25E4%25B8%258E%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div>
  <div class="pagination__title">
      <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
      <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.11/dist/twikoo.all.min.js"></script>
  <script>
      twikoo.init({
          envId: "https://twikoo-ah7vxzqs6-zzydev.vercel.app/",  
          el: "#tcomment",
          lang: 'zh-CN',
          region: 'ap-guangzhou',  
          path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
      });
  </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>zzydev</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span id="busuanzi_container_site_pv">
        本站访问量：<span id="busuanzi_value_site_pv"></span>次
    </span>
    &nbsp;
    <span id="busuanzi_container_site_uv">
        您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
