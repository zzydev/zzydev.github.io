<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>2.React生命周期 | 人类低质量男性求职准备</title>
<meta name="keywords" content="react">
<meta name="description" content="React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”">
<meta name="author" content="zzydev">
<link rel="canonical" href="https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.ce8eaa724ac5cfa35cb5e776d031ea4b1e1eb3c88bbd1dd133fd07f82206c87d.css" integrity="sha256-zo6qckrFz6Ncted20DHqSx4es8iLvR3RM/0H&#43;CIGyH0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="apple-touch-icon" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<link rel="mask-icon" href="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="2.React生命周期" />
<meta property="og:description" content="React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-02T17:58:52&#43;08:00" />
<meta property="article:modified_time" content="2022-06-17T21:57:20&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="2.React生命周期"/>
<meta name="twitter:description" content="React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章 📖",
      "item": "https://zzydev.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "React",
      "item": "https://zzydev.top/posts/headfirstreact/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "2.React生命周期",
      "item": "https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2.React生命周期",
  "name": "2.React生命周期",
  "description": "React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”",
  "keywords": [
    "react"
  ],
  "articleBody": "React15 的生命周期 Mounting 阶段：组件的初始化渲染 挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实 DOM 里，完成“首次渲染”。\n注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来做的。\ncomponentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里执行真实 DOM 相关的操作，类似于发起异步请求、数据初始化这样的操作也大可以放在这个生命周期来做。\nUpdating 阶段：组件的更新 componentWillReceiProps(nextProps) 是由什么触发的？ 在这个生命周期方法里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）可以通过 this.props 拿到，由此便能够感知到 props 的变化。\ncomponentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。\n如果父组件导致组件重新渲染，即使 props 没有更改也会调用此方法（componentWillReceiveProps） 如果只想处理更改，请确保当前值与变更值的比较\n—— React 官方\n组件自身 setState 触发的更新 componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。\nrender 与性能： shouldComponentUpdate(nextProps, nextState) React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行re-render（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。\nUnmounting 阶段：组件的卸载 组件销毁的常见原因有以下两个。\n组件在父组件中被移除了：这种情况相对比较直观 组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被销毁。 React16 的生命周期 推荐 👉🏻 React16 生命周期图示\nMounting 阶段：组件的初始化渲染 认识 getDerivedStateFromProps(props,state) getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉componentWillMount ，而是试图替换掉 componentWillReceiveProps，因此它有且仅有一个用途:使用 props 来派生/更新 state\ngetDerivedStateFromProps 是一个静态方法，静态方法不依赖组件实例而存在，因此在这个方法内部是访问不到 this 的。\n该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state。\ngetDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番。\ngetDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：\n1 2 3 { fatherText: props.text; } 该对象并不会替换掉组件原始的这个 state：\n1 this.state = { text: \"子组件的文本\" }; 而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示： Updating 阶段：组件的更新 React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：\n在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；\n而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。\n为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？ 做合理的减法：\ngetDerivedStateFromProps 直接被定义为 static 方法，static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。 这是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。 消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate 方法需要一个返回值，它的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state\u0026props 的信息。\n重点把握它与 componentDidUpdate 间的通信过程：\n1 2 3 4 5 6 7 8 9 10 11 // 组件更新时调用 getSnapshotBeforeUpdate(prevProps, prevState) { console.log(\"getSnapshotBeforeUpdate方法执行\"); return \"haha\"; } // 组件更新后调用 componentDidUpdate(prevProps, prevState, valueFromSnapshot) { console.log(\"componentDidUpdate方法执行\"); console.log(\"从 getSnapshotBeforeUpdate 获取到的值是\", valueFromSnapshot); } 这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。\nReact16 为何两次求变？ Fiber 会使原本同步的渲染过程变成异步的。 同步更新与异步更新对比 Demo\n同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，调度器会看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”。\n换个角度看生命周期工作流 Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 render 和 commit 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：\n总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。\n为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，这个过程必须用同步渲染。\n生命周期变更的考量 在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。\n带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：\ncomponentWillMount； componentWillUpdate； componentWillReceiveProps。 这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。\n在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:\nsetState()； fetch 发起异步请求； 操作真实 DOM。 这些操作的问题（或不必要性）包括但不限于以下 3 点：\n完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做。\n比如在 componentWillMount 里发起异步请求，以为这样做就可以更快得到异步请求返回的结果，从而避免首次渲染白屏。\n但是（React 15 下）同步的生命周期函数必然先于异步请求执行。componentWillMount 结束后，render 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题。\n在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。\n比如在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。\n又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。\ngetDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了———避免开发者触碰 this，就是在避免各种危险的错误操作。\n即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。\n比如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。\n总的来说，React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制。在这个改造的过程中，React 团队针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也 确保了生命周期方法的行为更加纯粹、可控、可预测 。\n",
  "wordCount" : "3645",
  "inLanguage": "en",
  "datePublished": "2022-06-02T17:58:52+08:00",
  "dateModified": "2022-06-17T21:57:20Z",
  "author":[{
    "@type": "Person",
    "name": "zzydev"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zzydev.top/posts/headfirstreact/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "人类低质量男性求职准备",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/other/avatar/caidog.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zzydev.top" accesskey="h" title="人类低质量男性求职准备 (Alt + H)">人类低质量男性求职准备</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zzydev.top/search" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/posts" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://zzydev.top/links" title="友链">
                    <span>友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zzydev.top">Home</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/">文章 📖</a>&nbsp;»&nbsp;<a href="https://zzydev.top/posts/headfirstreact/">React</a></div>
    <h1 class="post-title">
      2.React生命周期
    </h1>
    <div class="post-meta">










创建:&nbsp;<span title='2022-06-02 17:58:52 +0800 CST'>2022-06-02</span>&nbsp;|&nbsp;更新:&nbsp;2022-06-17&nbsp;|&nbsp;字数:&nbsp;3645字&nbsp;|&nbsp;时长: 8分钟&nbsp;|&nbsp;zzydev<span id="busuanzi_container_page_pv">
        &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
    </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#react15-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="React15 的生命周期">React15 的生命周期</a><ul>
                            
                    <li>
                        <a href="#mounting-%e9%98%b6%e6%ae%b5%e7%bb%84%e4%bb%b6%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b8%b2%e6%9f%93" aria-label="Mounting 阶段：组件的初始化渲染">Mounting 阶段：组件的初始化渲染</a></li>
                    <li>
                        <a href="#updating-%e9%98%b6%e6%ae%b5%e7%bb%84%e4%bb%b6%e7%9a%84%e6%9b%b4%e6%96%b0" aria-label="Updating 阶段：组件的更新">Updating 阶段：组件的更新</a><ul>
                            
                    <li>
                        <a href="#componentwillreceipropsnextprops-%e6%98%af%e7%94%b1%e4%bb%80%e4%b9%88%e8%a7%a6%e5%8f%91%e7%9a%84" aria-label="componentWillReceiProps(nextProps) 是由什么触发的？"><code>componentWillReceiProps(nextProps)</code> 是由什么触发的？</a></li>
                    <li>
                        <a href="#%e7%bb%84%e4%bb%b6%e8%87%aa%e8%ba%ab-setstate-%e8%a7%a6%e5%8f%91%e7%9a%84%e6%9b%b4%e6%96%b0" aria-label="组件自身 setState 触发的更新"><strong>组件自身 setState 触发的更新</strong></a></li>
                    <li>
                        <a href="#render-%e4%b8%8e%e6%80%a7%e8%83%bd-shouldcomponentupdatenextprops-nextstate" aria-label="render 与性能： shouldComponentUpdate(nextProps, nextState)">render 与性能： <code>shouldComponentUpdate(nextProps, nextState)</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#unmounting-%e9%98%b6%e6%ae%b5%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8d%b8%e8%bd%bd" aria-label="Unmounting 阶段：组件的卸载">Unmounting 阶段：组件的卸载</a></li></ul>
                    </li>
                    <li>
                        <a href="#react16-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="React16 的生命周期">React16 的生命周期</a><ul>
                            
                    <li>
                        <a href="#mounting-%e9%98%b6%e6%ae%b5%e7%bb%84%e4%bb%b6%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b8%b2%e6%9f%93-1" aria-label="Mounting 阶段：组件的初始化渲染">Mounting 阶段：组件的初始化渲染</a><ul>
                            
                    <li>
                        <a href="#%e8%ae%a4%e8%af%86-getderivedstatefrompropspropsstate" aria-label="认识 getDerivedStateFromProps(props,state)">认识 getDerivedStateFromProps(props,state)</a></li></ul>
                    </li>
                    <li>
                        <a href="#updating-%e9%98%b6%e6%ae%b5%e7%bb%84%e4%bb%b6%e7%9a%84%e6%9b%b4%e6%96%b0-1" aria-label="Updating 阶段：组件的更新">Updating 阶段：组件的更新</a><ul>
                            
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-getderivedstatefromprops-%e4%bb%a3%e6%9b%bf-componentwillreceiveprops" aria-label="为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？">为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？</a></li>
                    <li>
                        <a href="#%e6%b6%88%e5%a4%b1%e7%9a%84-componentwillupdate-%e4%b8%8e%e6%96%b0%e5%a2%9e%e7%9a%84-getsnapshotbeforeupdateprevprops-prevstate" aria-label="消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState)">消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState)</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#react16-%e4%b8%ba%e4%bd%95%e4%b8%a4%e6%ac%a1%e6%b1%82%e5%8f%98" aria-label="React16 为何两次求变？">React16 为何两次求变？</a><ul>
                            
                    <li>
                        <a href="#fiber-%e4%bc%9a%e4%bd%bf%e5%8e%9f%e6%9c%ac%e5%90%8c%e6%ad%a5%e7%9a%84%e6%b8%b2%e6%9f%93%e8%bf%87%e7%a8%8b%e5%8f%98%e6%88%90%e5%bc%82%e6%ad%a5%e7%9a%84" aria-label="Fiber 会使原本同步的渲染过程变成异步的。">Fiber 会使原本同步的渲染过程变成异步的。</a></li>
                    <li>
                        <a href="#%e6%8d%a2%e4%b8%aa%e8%a7%92%e5%ba%a6%e7%9c%8b%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%b7%a5%e4%bd%9c%e6%b5%81" aria-label="换个角度看生命周期工作流">换个角度看生命周期工作流</a></li>
                    <li>
                        <a href="#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%8f%98%e6%9b%b4%e7%9a%84%e8%80%83%e9%87%8f" aria-label="生命周期变更的考量">生命周期变更的考量</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><h2 id="react15-的生命周期">React15 的生命周期<a hidden class="anchor" aria-hidden="true" href="#react15-的生命周期">#</a></h2>
<p><img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/2-1.png" alt="2-1"  />
</p>
<h3 id="mounting-阶段组件的初始化渲染">Mounting 阶段：组件的初始化渲染<a hidden class="anchor" aria-hidden="true" href="#mounting-阶段组件的初始化渲染">#</a></h3>
<p>挂载过程在组件的一生中<strong>仅会发生一次</strong>，在这个过程中，组件被<strong>初始化</strong>，然后会被渲染到真实 DOM 里，完成“<strong>首次渲染</strong>”。</p>
<p>注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来做的。</p>
<p>componentDidMount 方法在<strong>渲染结束后被触发</strong>，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里<strong>执行真实 DOM 相关的操作</strong>，类似于发起异步请求、数据初始化这样的操作也大可以放在这个生命周期来做。</p>
<h3 id="updating-阶段组件的更新">Updating 阶段：组件的更新<a hidden class="anchor" aria-hidden="true" href="#updating-阶段组件的更新">#</a></h3>
<h4 id="componentwillreceipropsnextprops-是由什么触发的"><code>componentWillReceiProps(nextProps)</code> 是由什么触发的？<a hidden class="anchor" aria-hidden="true" href="#componentwillreceipropsnextprops-是由什么触发的">#</a></h4>
<p>在这个生命周期方法里，<code>nextProps</code> 表示的是接收到新 props 内容，而现有的 props （相对于 <code>nextProps</code> 的“旧 props”）可以通过 <code>this.props</code> 拿到，由此便能够感知到 <code>props</code> 的变化。</p>
<p><code>componentReceiveProps</code> 并不是由 <code>props</code> 的变化触发的，而是<strong>由父组件的更新触发的</strong>。</p>

<div class="notice notice-info" >
    <div class="notice-title"><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v100h12c7 0 12 5 12 12v24z"/></svg></div><p>如果父组件导致组件重新渲染，即使 props 没有更改也会调用此方法（componentWillReceiveProps）
如果只想处理更改，请确保当前值与变更值的比较</p>
<p>&mdash;&mdash; React 官方</p></div>

<h4 id="组件自身-setstate-触发的更新"><strong>组件自身 setState 触发的更新</strong><a hidden class="anchor" aria-hidden="true" href="#组件自身-setstate-触发的更新">#</a></h4>
<p>componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。</p>
<h4 id="render-与性能-shouldcomponentupdatenextprops-nextstate">render 与性能： <code>shouldComponentUpdate(nextProps, nextState)</code><a hidden class="anchor" aria-hidden="true" href="#render-与性能-shouldcomponentupdatenextprops-nextstate">#</a></h4>
<p>React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行<strong>re-render</strong>（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 <code>PureComponent</code> 等最佳实践，来实现“<strong>有条件的</strong> re-render”。</p>
<h3 id="unmounting-阶段组件的卸载">Unmounting 阶段：组件的卸载<a hidden class="anchor" aria-hidden="true" href="#unmounting-阶段组件的卸载">#</a></h3>
<p>组件销毁的常见原因有以下两个。</p>
<ul>
<li>组件在父组件中被移除了：这种情况相对比较直观</li>
<li>组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被销毁。</li>
</ul>
<h2 id="react16-的生命周期">React16 的生命周期<a hidden class="anchor" aria-hidden="true" href="#react16-的生命周期">#</a></h2>
<p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank">推荐 👉🏻 React16 生命周期图示</a></p>
<p><img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/2-2.png" alt="2-2"  />
</p>
<h3 id="mounting-阶段组件的初始化渲染-1">Mounting 阶段：组件的初始化渲染<a hidden class="anchor" aria-hidden="true" href="#mounting-阶段组件的初始化渲染-1">#</a></h3>
<h4 id="认识-getderivedstatefrompropspropsstate">认识 getDerivedStateFromProps(props,state)<a hidden class="anchor" aria-hidden="true" href="#认识-getderivedstatefrompropspropsstate">#</a></h4>
<p>getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉<strong>componentWillMount ，<strong>而是试图替换掉 componentWillReceiveProps，因此它</strong>有且仅有一个用途:使用 props 来派生/更新 state</strong></p>
<p>getDerivedStateFromProps 是一个静态方法，静态方法不依赖组件实例而存在，因此在这个方法内部是访问不到 this 的。</p>
<p>该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自<strong>父组件的 props</strong> 和当前组件自身的 state。</p>
<p>getDerivedStateFromProps 需要一个对象格式的返回值。如果你没有指定这个返回值，那么大概率会被 React 警告一番。</p>
<p>getDerivedStateFromProps 方法<strong>对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新</strong>。比如这里我们在 getDerivedStateFromProps 里返回的是这样一个对象，对象里面有一个 fatherText 属性用于表示“父组件赋予的文本”：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  fatherText: props.text;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>该对象并不会替换掉组件原始的这个 state：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">this</span>.state = { text: <span style="color:#0ff;font-weight:bold">&#34;子组件的文本&#34;</span> };
</span></span></code></pre></td></tr></table>
</div>
</div><p>而是仅仅针对 fatherText 这个属性作更新（这里原有的 state 里没有 fatherText，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示：
<img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/2-3.webp" alt="2-3"  />
</p>
<h3 id="updating-阶段组件的更新-1">Updating 阶段：组件的更新<a hidden class="anchor" aria-hidden="true" href="#updating-阶段组件的更新-1">#</a></h3>
<p><img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/2-4.png" alt="2-4"  />
</p>
<p>React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：</p>
<p>在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；</p>
<p>而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。</p>
<h4 id="为什么要用-getderivedstatefromprops-代替-componentwillreceiveprops">为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？<a hidden class="anchor" aria-hidden="true" href="#为什么要用-getderivedstatefromprops-代替-componentwillreceiveprops">#</a></h4>
<p>做合理的减法：</p>
<ol>
<li>getDerivedStateFromProps 直接被定义为 static 方法，static 方法内部拿不到组件实例的 this，这就导致你无法在 getDerivedStateFromProps 里面做任何类似于 this.fetch()、不合理的 this.setState（会导致死循环的那种）这类可能会产生副作用的操作。</li>
<li>这是 React 16 在<strong>强制推行</strong>“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。</li>
</ol>
<h4 id="消失的-componentwillupdate-与新增的-getsnapshotbeforeupdateprevprops-prevstate">消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate(prevProps, prevState)<a hidden class="anchor" aria-hidden="true" href="#消失的-componentwillupdate-与新增的-getsnapshotbeforeupdateprevprops-prevstate">#</a></h4>
<p>getSnapshotBeforeUpdate 方法需要一个返回值，<strong>它的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state&amp;props 的信息。</strong></p>
<p>重点把握它与 componentDidUpdate 间的通信过程：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#007f7f">// 组件更新时调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>getSnapshotBeforeUpdate(prevProps, prevState) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#0ff;font-weight:bold">&#34;getSnapshotBeforeUpdate方法执行&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;haha&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 组件更新后调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>componentDidUpdate(prevProps, prevState, valueFromSnapshot) {
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#0ff;font-weight:bold">&#34;componentDidUpdate方法执行&#34;</span>);
</span></span><span style="display:flex;"><span>  console.log(<span style="color:#0ff;font-weight:bold">&#34;从 getSnapshotBeforeUpdate 获取到的值是&#34;</span>, valueFromSnapshot);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个生命周期的设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。</p>
<h2 id="react16-为何两次求变">React16 为何两次求变？<a hidden class="anchor" aria-hidden="true" href="#react16-为何两次求变">#</a></h2>
<h3 id="fiber-会使原本同步的渲染过程变成异步的">Fiber 会使原本同步的渲染过程变成异步的。<a hidden class="anchor" aria-hidden="true" href="#fiber-会使原本同步的渲染过程变成异步的">#</a></h3>
<p><a href="https://codesandbox.io/s/concurrent-3h48s?file=/src/index.js" target="_blank">同步更新与异步更新对比 Demo</a></p>
<p>同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。</p>
<p>而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：Fiber 会将一个大的更新任务拆解为许多个小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，调度器会看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”。</p>
<h3 id="换个角度看生命周期工作流">换个角度看生命周期工作流<a hidden class="anchor" aria-hidden="true" href="#换个角度看生命周期工作流">#</a></h3>
<p>Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被划分为了 <strong>render</strong> 和 <strong>commit</strong> 两个阶段，而 commit 阶段又被细分为了 pre-commit 和 commit。每个阶段所涵盖的生命周期如下图所示：</p>
<p><img loading="lazy" src="https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/hfreact/2-4.png" alt="2-4"  />
</p>
<p>总的来说，<strong>render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的</strong>。</p>
<p>为什么这样设计呢？简单来说，由于 <strong>render 阶段的操作对用户来说其实是“不可见”的</strong>，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，这个过程必须用同步渲染。</p>
<h3 id="生命周期变更的考量">生命周期变更的考量<a hidden class="anchor" aria-hidden="true" href="#生命周期变更的考量">#</a></h3>
<p>在 Fiber 机制下，<strong>render 阶段是允许暂停、终止和重启的</strong>。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。<strong>这就导致 render 阶段的生命周期都是有可能被重复执行的</strong>。</p>
<p>带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：</p>
<ul>
<li>componentWillMount；</li>
<li>componentWillUpdate；</li>
<li>componentWillReceiveProps。</li>
</ul>
<p>这些生命周期的共性，<strong>就是它们都处于 render 阶段，都可能重复被执行</strong>，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</p>
<p>在“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:</p>
<ul>
<li>setState()；</li>
<li>fetch 发起异步请求；</li>
<li>操作真实 DOM。</li>
</ul>
<p>这些操作的问题（或不必要性）包括但不限于以下 3 点：</p>
<ol>
<li>
<p><strong>完全可以转移到其他生命周期（尤其是 componentDidxxx）里去做</strong>。</p>
<p>比如在 componentWillMount 里发起异步请求，以为这样做就可以更快得到异步请求返回的结果，从而避免首次渲染白屏。</p>
<p>但是（React 15 下）<strong>同步</strong>的生命周期函数必然先于<strong>异步请求</strong>执行。componentWillMount 结束后，render 会迅速地被触发，所以说<strong>首次渲染依然会在数据返回之前执行</strong>。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题。</p>
</li>
<li>
<p><strong>在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug</strong>。</p>
<p>比如在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被<strong>打断 + 重启多次</strong>后，就会发出多个付款请求。</p>
<p>又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。</p>
<p>getDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了———避免开发者触碰 this，就是在避免各种危险的错误操作。</p>
</li>
<li>
<p><strong>即使你没有开启异步，React 15 下也有不少人能把自己“玩死”。</strong></p>
<p>比如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。</p>
</li>
</ol>
<p>总的来说，<strong>React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制</strong>。在这个改造的过程中，React 团队针对生命周期中长期被滥用的部分推行了具有<strong>强制性</strong>的最佳实践。这一系列的工作做下来，首先是<strong>确保了 Fiber 机制下数据和视图的安全性</strong>，同时也 <strong>确保了生命周期方法的行为更加纯粹、可控、可预测</strong> 。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zzydev.top/tags/react/">react</a></li>
    </ul>
<nav class="paginav">
  
  <a class="prev" href="https://zzydev.top/posts/headfirstreact/1_jsx%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E4%B8%BAdom%E7%9A%84/">
    <span class="title">« Prev</span>
    <br>
    <span>1.JSX 是如何变成为 DOM 的</span>
  </a>
  <a class="next" href="https://zzydev.top/posts/headfirstreact/3_%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8react%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%B5%81%E5%8A%A8%E7%9A%84/">
    <span class="title">Next »</span>
    <br>
    <span>3.数据是如何在React组件之间流动的？</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 2.React生命周期 on twitter"
        href="https://twitter.com/intent/tweet/?text=2.React%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f&amp;hashtags=react">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 2.React生命周期 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f&amp;title=2.React%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&amp;summary=2.React%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&amp;source=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 2.React生命周期 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f&title=2.React%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 2.React生命周期 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 2.React生命周期 on whatsapp"
        href="https://api.whatsapp.com/send?text=2.React%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%20-%20https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 2.React生命周期 on telegram"
        href="https://telegram.me/share/url?text=2.React%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&amp;url=https%3a%2f%2fzzydev.top%2fposts%2fheadfirstreact%2f2_react%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div>
  <div class="pagination__title">
      <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
      <hr />
  </div>
  <div id="tcomment"></div>
  <script src="https://cdn.jsdelivr.net/npm/twikoo@1.5.11/dist/twikoo.all.min.js"></script>
  <script>
      twikoo.init({
          envId: "https://twikoo-ah7vxzqs6-zzydev.vercel.app/",  
          el: "#tcomment",
          lang: 'zh-CN',
          region: 'ap-guangzhou',  
          path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
      });
  </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://zzydev.top">人类低质量男性求职准备</a></span>
    
        
        
        
    
    <span id="busuanzi_container_site_pv">
        本站访问量：<span id="busuanzi_value_site_pv"></span>次
    </span>
    &nbsp;
    <span id="busuanzi_container_site_uv">
        您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
