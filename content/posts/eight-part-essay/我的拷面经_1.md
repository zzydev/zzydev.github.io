---
title: "我的拷面经（一）"
date: 2022-06-08T00:30:50+08:00
lastmod: 2022-06-19 08:09:57
draft: false
tags: ["八股文", "面经"]
author: ["zzydev"]
description: ""
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
comments: true
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: false # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
  image: "https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-kmj.png"
  caption: ""
  alt: ""
  relative: true
---

---

{{<quote-center >}}

我是没事的时候  
在无聊的时候，想的时候  
到一个地方，不相同的地方  
到这个地方来，来到吧  
可以瞧瞧，不一样的地方  
不相同的地方  
很多，很多……

--------- 淳·简·拉基茨德

{{< /quote-center >}}

<br/>

---

{{< spoiler  "Symbol不能使用new操作符，那如何得到一个Symbol类型的对象">}}

```javascript
//利用一个函数的call方法来强迫产生装箱
var symbolObject = function () {
  return this;
}.call(Symbol("a"));

console.log(typeof symbolObject); //object
console.log(symbolObject instanceof Symbol); //true
console.log(symbolObject.constructor == Symbol); //true

//使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力
var symbolObject = Object(Symbol("a"));

console.log(typeof symbolObject); //object
console.log(symbolObject instanceof Symbol); //true
console.log(symbolObject.constructor == Symbol); //true

//每一类装箱对象皆有私有的Class属性，这些属性可以用 Object.prototype.toString 获取：
console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
//在JS中，没有任何方法可以更改私有的Class属性
```

{{< /spoiler >}}

{{< spoiler  "new fn与new fn()有什么区别吗？">}}

```javascript
function Parent() {
  this.num = 1;
}
console.log(new Parent()); //输出Parent对象：{num:1}
console.log(new Parent()); //输出Parent对象：{num:1}

function Parent() {
  this.num = 1;
}
console.log(new Parent().num); //1
console.log(new Parent.num()); //报错
```

从报错信息来看，`new Parent.num`执行顺序是这样的：先执行`Parent.num`，此时返回结果为`undefined`；后执行`new`，因`new`后面必须跟构造函数，所以`new undefined`会报错。

`new Parent().num`相当于`(new Parent()).num`，所以结果返回 1。

{{< /spoiler >}}

{{< spoiler  "拆箱转换相关问题">}}

对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的原始类型。

Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。

```javascript
var o = {
  valueOf: () => {
    console.log("valueOf");
    return {};
  },
  toString: () => {
    console.log("toString");
    return {};
  },
};

o[Symbol.toPrimitive] = () => {
  return "hello";
};
console.log(o + "");
// hello

// 练习一
const arr = [4, 10];
arr[Symbol.toPrimitive] = function (hint) {
  return hint;
};
arr.valueOf = function () {
  return this;
};
const obj = {} + arr + obj + arr + obj; //'NaN[object Object]default[object Object]'
{
}
+arr; //[object Object]default'

// 练习二
const val =
  (([] == ![][(+val, [] + 1)]) == // ''转数字为0
    [1, 1] + [][(+val, [] + 1)]) == //[1, '1'].toString() == [1, 1] + ''  =>  '1, 1' == '1, 1'  true
  [1, "1"]; // false
```

{{< /spoiler >}}

{{< spoiler  "[]➕[]，[]➕{}，{}➕[]，{}➕{}">}}

```javascript
// 二元操作符 + 的规则
// 如果操作数是对象，则对象会转换为原始值
// 如果其中一个操作数是字符串，另一个操作数也会转换为字符串进行拼接
// 否则两个操作数都将转换为数字或者NaN，进行加法操作
10n + 10
Symbol(10) + 10

// 对象转换为原始数据类型的值
// Symbol.toPrimitive 优先级最高
// Object.prototype.valueOf  // 调用 valueOf，如果转换为原始类型，就返回转换的值。如果不返回原始类型的值就调用toString。
// Object.prototype.toString // 调用toString，如果转换为原始类型，就返回转换的值。如果不返回原始类型的值就调用valueOf。
typeof [][Symbol.toPrimitive] // undefined
[].valueOf() // []
[].toString() // ''  所以[]转换为原始值是‘’

typeof {}[Symbol.toPrimitive] //undefined
({}).valueOf() // {}
({}).toString() // '[object Object]'

[] + [] // ""
[] + {} // "[object Object]"
{} + [] // 0  相当于 {}; + []
{} + {} // Chrome '[object Object][object Object]' 其他浏览器 NaN
```

{{< /spoiler >}}

{{< spoiler  "toString相关问题">}}

```javascript
const user = {
  name: "zzy",
  id: 233,
  valueOf() {
    return this.id;
  },
};

console.log(`${user}`); //会调用原型链上的toString 返回[object Object]
Object.prototype.toString = undefined;
console.log(`${user}`); // 233
```

```javascript
Object.prototype.toString.call(Boolean.prototype); // [object Boolean]
```

{{< /spoiler >}}

{{< spoiler  "px % rem vh/vw有什么区别">}}
px 是绝对单位，  
% 是相对于父元素的比例，  
em 是相对于当前元素的 font-size，rem 是相对与根(root)元素的 font-size，

```html
<div style="font-size:20px">
  <p style="text-indent: 2em; font-size: 40px">首行缩进</p>
  <p style="text-indent: 2em">
    这个元素的font-size继承了父元素的font-size，所以缩进比上面的小一些
  </p>
  <p style="font-size: 2rem">相对根元素font-size</p>
</div>
```

vh/vw 是屏幕的百分比  
vmin 是 min(屏幕宽度,屏幕高度)、vmax 是 max(屏幕宽度,屏幕高度)
{{< /spoiler >}}

{{< spoiler  "for in 和 for of的区别">}}
遍历对象：for...in 可以, for...of 不可以  
遍历 Map、Set：for...of 可以, for...in 不可以  
遍历 generator：for...of 可以, for...in 不可以

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
for (let i of gen()) {
  console.log(i);
}
```

for...in 用于**可枚举**数据，如对象、数组、字符串

```javascript
Object.defineProperty(obj, "key", {
  enumerable: true, // 可枚举
  configurable: false,
  writable: false,
  value: "static",
});
```

for...of 用于**可迭代**数据，如数组、字符串、Set、Map

存在 Symbol.iterator 属性的对象，可以用 for...of 迭代

![1-7](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-7.png)

**for await of 有什么作用**

```javascript
function createPromise(val) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(val);
    }, 1000);
  });
}

(async function () {
  const p1 = createPromise(100);
  const p2 = createPromise(200);

  const res1 = await p1;
  console.log(res1);
  const res2 = await p2;
  console.log(res2);

  //直接三个一起打印出来
  const list = [p1, p2];
  Promise.all(list).then((res) => console.log(res));

  // Promise.all的代替品
  //直接三个一起打印出来
  for await (let res of list) {
    console.log(res);
  }

  //每隔一秒打印一个
  const arr = [100, 200];
  for (let num of arr) {
    const res = await createPromise(num);
    console.log(res);
  }
})();
```

{{< /spoiler >}}

{{< spoiler  "offsetHeight、scrollHeight和clientHeight的区别">}}
![1-8](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-8.png)
![1_8](http://cdn.zzydev.top//eight-part-essay/1_8.png)
[scrollHeight](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollHeight)  
[scrollTop](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop)  
[scrollLeft](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollLeft)  
{{< /spoiler >}}

{{< spoiler  "HTMLCollection和NodeList的区别">}}
Node 是 Element 的基类  
Element 是其他 HTML 元素的基类，如 HTMLDivElement
![1-9](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-9.png)
HTMLCollection 是 Element 的集合  
NodeList 是 Node 的集合  
HTMLCollection 和 NodeList 都是类数组

```html
<p id="p1">
  <b>node</b> vs <em>element</em
  ><!--注释-->
</p>
```

```javascript
const p1 = document.getElementById("p1");
console.log(p1.children); // 不包含Text和Comment 是HTMLCollection类型
console.log(p1.childNode); // 包含Text和Comment 是NodeList类型

p1.tagName; // Element类型属性
p1.nodeName; // Node类型属性
```

{{< /spoiler >}}

{{< spoiler  "Node和浏览器的EventLoop有什么区别">}}
{{< notice notice-tip >}}
可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则:
{{< /notice >}}

![1-10](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-10.gif)
浏览器中的 EventLoop
函数会在执行栈中执行，当遇到异步代码的时候，会被挂起在 Task 队列中，一旦执行栈为空，就会从 Task 队列中拿出需要执行的代码执行，所以本质上讲 JS 中的异步还是同步行为。
![1-10-1](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-10-1.png)
不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。

- 宏任务(`script`、`setTimeout`、`setInterval`、`setImmidiate`、`I/O`、`UI Rendering`)
- 微任务(`procress.nextTick`、`Promise.then`、`Object.observe`、`mutataionObserver`)

Event Loop 执行顺序如下所示：</br>

1. 首先执行同步代码，这属于宏任务</br>
2. 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</br>
3. 执行所有微任务</br>
4. 当执行完所有微任务后，如有必要会渲染页面</br>
5. 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 </br>
   ![1-10-2](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-10-2.png)

```javascript
const $p1 = $("<p>一段文字</p>");
const $p2 = $("<p>一段文字</p>");
const $p3 = $("<p>一段文字</p>");
$("#container").append($p1).append($p2).append($p3);
//微任务: DOM渲染前触发
Promise.resolve().then(() => {
  console.log("length1", $("#container").children.length); // 3
  alert("Promise then"); // 出现alert弹窗，DOM此时未渲染
});
//宏任务：DOM渲染后触发
setTimeout(() => {
  console.log("setTimeout");
});
```

![1-10-3](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-10-3.png)
{{<detail "回顾Promise知识点">}}
[手写 Promise](https://zzydev.top/posts/eight-part-essay/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C/#%e6%89%8b%e5%86%99Promise)

```javascript
//Promise 有三种状态：pending、resolved、rejected
//pending 状态的Promise，不会触发 then 或 catch
//resolved 状态的 Promise， 会触发 then 回调函数
//rejected 状态的 Promise， 会触发 catch 回调函数
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve();
  });
});
console.log("p1", p1); // Promise {<pending>}
setTimeout(() => console.log("p1-setTimeout", p1)); // Promise { <resolved> }

// -------------------------------------------------------------------------

// then 正常返回 resolved 状态的 Promise，里面有报错则返回 rejected 状态的 Promise
// catch 正常返回 resolved 状态的 Promise，里面有报错则返回 rejected 状态的 Promise
const p1 = Promise.reject("my error").catch((err) => console.log(err));
console.log("p1", p1); // ⚠️ Promise { <resolved> }
const p2 = Promise.reject("my error").then(
  (err) => throw new Error("catch error")
);
console.log("p2", p2); // ⚠️ Promise { <rejected> }

Promise.resolve()
  .then(() => console.log(1))
  .catch(() => {
    return new Error("err");
  })
  .then(() => console.log(3))
  .catch((err) => console.log(err));
// ⚠️ 1  3

// -------------------------------------------------------------------------

// async 函数返回的是 Promise 对象
// await 相当于 Promise 的 then
// try/catch 可捕获异常，相当于 Promise 的 catch
async function fn1() {
  // return 100; 相当于 return Promise.resolve(100)
  return Promise.resolve(100);
}
const res1 = fn1(); // res1: Promise { <resolved> }
!(async function () {
  const p1 = Promise.resolve(100);
  const data = await p1; // await 相当于 Promise 的 then
  console.log(data);
})();
!(async function () {
  const data = await 100; // 相当于 await Promise.resolve(100);
  console.log(data);
})();
!(async function () {
  const p1 = Promise.reject(new Error("my error"));
  try {
    const data = await p1;
    console.log(data);
  } catch (err) {
    console.error(err); // try catch 相当于 Promise 的 catch
  }
})();

// -------------------------------------------------------------------------

async function async1() {
  console.log("async1 start"); // 2
  await async2(); //先执行 async2,再执行 await 的操作
  // await 后面的内容，都可以看成 callback 的内容，微任务
  console.log("async1 end"); // 6
}

async function async2() {
  console.log("async2 start"); // 3
}

console.log("script start"); // 1
setTimeout(() => {
  // 宏任务
  console.log("setTimeout"); // 8
});
async1();

//初始化Promise时，传入的函数会立刻被执行
new Promise(function (resolve) {
  console.log("Promise1"); // 4
  resolve();
}).then(() => {
  // 微任务
  console.log("Promise2"); // 7
});

console.log("script end"); // 5
//同步代码执行完毕 (call stack被清空)
//执行微任务
//尝试进行DOM渲染
//触发EventLoop 执行宏任务
```

{{< /detail >}}

{{< /spoiler >}}

{{< spoiler  "浏览器缓存:强缓存和协商缓存">}}
强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

![1-10](https://zzydev-1255467326.cos.ap-guangzhou.myqcloud.com/eight-part-essay/1-10.png)

{{< /spoiler >}}
