---
title: "Lc31_下一个排列"
date: 2022-06-06T15:38:55+08:00
draft: true
tags:
  - "找规律"
  - "medium"
author: ["zzydev"]
description: ""
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
comments: true
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: false # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
  image: ""
  caption: ""
  alt: ""
  relative: false
---

[原题链接](https://leetcode.cn/problems/next-permutation/)

解题思路：

1. 先找到第一个降序的位置k，如果k为0，也就是整个数组是降序的，直接翻转整个数组。
2. 找到第一个比nums[k - 1]小的数 nums[t - 1]，交换他们的位置。
3. 再把k后面的数翻转

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int k = nums.size() - 1;
        while (k > 0 && nums[k - 1] >= nums[k]) k --;
        if (k == 0) {
            reverse(nums.begin(), nums.end());
        } else {
            int t = k;
            while (t < nums.size() && nums[t] > nums[k - 1]) t ++;
            swap(nums[t - 1], nums[k - 1]);
            reverse(nums.begin() + k, nums.end());
        }
    }
};


```

